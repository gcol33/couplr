[{"path":"https://gillescolling.com/couplr/ALGORITHM_ROADMAP.html","id":null,"dir":"","previous_headings":"","what":"couplr Algorithm Roadmap","title":"couplr Algorithm Roadmap","text":"Goal: Make couplr definitive LAP solver R","code":""},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":"https://gillescolling.com/couplr/ALGORITHM_ROADMAP.html","id":"id_1-lapmod-sparse-jonker-volgenant","dir":"","previous_headings":"Planned Additions > Tier 1: High Priority","what":"1. LAPMOD (Sparse Jonker-Volgenant)","title":"couplr Algorithm Roadmap","text":"Year: 1996 (Volgenant) Complexity: O(n³) worst-case, O(n^2.5) typical sparse Implementation effort: Medium (3-4 days) 10-100x speedup n > 5000 < 50% finite costs #1 gap R’s LAP ecosystem Python’s lap library’s main advantage scipy Essential large-scale bioinformatics matching Key insight: Exploits sparsity maintaining candidate lists per row","code":""},{"path":"https://gillescolling.com/couplr/ALGORITHM_ROADMAP.html","id":"id_2-bottleneck-assignment-problem-bap","dir":"","previous_headings":"Planned Additions > Tier 1: High Priority","what":"2. Bottleneck Assignment Problem (BAP)","title":"couplr Algorithm Roadmap","text":"Year: 1961 (Gross) Complexity: O(n^2.5) O(n² log n) binary search Implementation effort: Low (1-2 days) Different objective: minimize maximum edge cost Useful fairness-constrained matching R package offers Can reuse Hopcroft-Karp subroutine Algorithm: Binary search threshold + bipartite matching","code":""},{"path":[]},{"path":"https://gillescolling.com/couplr/ALGORITHM_ROADMAP.html","id":"id_4-orlins-algorithm","dir":"","previous_headings":"Planned Additions > Tier 2: Completeness & Theory","what":"4. Orlin’s Algorithm","title":"couplr Algorithm Roadmap","text":"Year: 1993 Complexity: O(m√n log(nC)) sparse graphs Implementation effort: High (5-7 days) Theoretical improvement Gabow-Tarjan sparse Combines scaling blocking flow techniques Academic completeness Note: May beat simpler algorithms practice","code":""},{"path":"https://gillescolling.com/couplr/ALGORITHM_ROADMAP.html","id":"id_5-ramshaw-tarjan-rectangular-specialization","dir":"","previous_headings":"Planned Additions > Tier 2: Completeness & Theory","what":"5. Ramshaw-Tarjan Rectangular Specialization","title":"couplr Algorithm Roadmap","text":"Year: 2012 Complexity: O(nm + n² log n) m >> n Implementation effort: Medium (2-3 days) Elegant handling unbalanced problems Avoids dummy node overhead Published “minimum-cost assignments unbalanced bipartite graphs”","code":""},{"path":"https://gillescolling.com/couplr/ALGORITHM_ROADMAP.html","id":"id_6-push-relabel-assignment","dir":"","previous_headings":"Planned Additions > Tier 2: Completeness & Theory","what":"6. Push-Relabel Assignment","title":"couplr Algorithm Roadmap","text":"Year: 1988 (Goldberg-Tarjan base) Complexity: O(n²m) Implementation effort: Medium (2-3 days) Classic algorithm, good teaching Different cost-scaling variants Basis many modern implementations","code":""},{"path":"https://gillescolling.com/couplr/ALGORITHM_ROADMAP.html","id":"id_7-capacity-scaling-assignment","dir":"","previous_headings":"Planned Additions > Tier 2: Completeness & Theory","what":"7. Capacity-Scaling Assignment","title":"couplr Algorithm Roadmap","text":"Year: 1972 (Edmonds-Karp style) Complexity: O(n²m log n) Implementation effort: Low-Medium (2 days) Bit-scaling approach Bridges network flow theory","code":""},{"path":[]},{"path":"https://gillescolling.com/couplr/ALGORITHM_ROADMAP.html","id":"id_8-sinkhorn-knopp-entropy-regularized-ot","dir":"","previous_headings":"Planned Additions > Tier 3: Cutting Edge","what":"8. Sinkhorn-Knopp (Entropy-Regularized OT)","title":"couplr Algorithm Roadmap","text":"Year: 2013 (Cuturi revival) Complexity: O(n² / ε²) iterations, O(n²) per iteration Implementation effort: Low (1-2 days) Connection optimal transport literature Differentiable (useful ML pipelines) Approximate fast GPU-friendly (future) Note: Returns soft assignment; round hard","code":""},{"path":"https://gillescolling.com/couplr/ALGORITHM_ROADMAP.html","id":"id_9-auction-with-ε-complementary-slackness-proof","dir":"","previous_headings":"Planned Additions > Tier 3: Cutting Edge","what":"9. Auction with ε-Complementary Slackness Proof","title":"couplr Algorithm Roadmap","text":"Year: 1991 (Bertsekas refinement) Complexity: auction Implementation effort: Low (enhance existing) Return dual variables optimality certificate Educational value","code":""},{"path":"https://gillescolling.com/couplr/ALGORITHM_ROADMAP.html","id":"id_10-network-simplex-for-assignment","dir":"","previous_headings":"Planned Additions > Tier 3: Cutting Edge","what":"10. Network Simplex for Assignment","title":"couplr Algorithm Roadmap","text":"Year: 1947 (Dantzig) / 1990s refinements Complexity: O(n³) typical, exponential worst-case Implementation effort: High (5+ days) Classic operations research method Handles side constraints naturally COIN-’s LEMON uses ","code":""},{"path":[]},{"path":"https://gillescolling.com/couplr/ALGORITHM_ROADMAP.html","id":"id_11-gpu-accelerated-hungarian","dir":"","previous_headings":"Planned Additions > Tier 4: Research / Future","what":"11. GPU-Accelerated Hungarian","title":"couplr Algorithm Roadmap","text":"Year: 2016+ Complexity: O(n³/p) p processors Implementation effort: High (requires CUDA/OpenCL) Orders magnitude speedup n > 10,000 Active research area Dependency: need RcppParallel custom CUDA kernels","code":""},{"path":"https://gillescolling.com/couplr/ALGORITHM_ROADMAP.html","id":"id_12-learning-augmented-assignment","dir":"","previous_headings":"Planned Additions > Tier 4: Research / Future","what":"12. Learning-Augmented Assignment","title":"couplr Algorithm Roadmap","text":"Year: 2020+ Complexity: Depends predictor quality Implementation effort: High Use ML warm-start guide search Emerging research direction","code":""},{"path":"https://gillescolling.com/couplr/ALGORITHM_ROADMAP.html","id":"implementation-priority-queue","dir":"","previous_headings":"","what":"Implementation Priority Queue","title":"couplr Algorithm Roadmap","text":"","code":"Phase 1 (Completed):   [✓] LAPMOD (sparse JV) ← DONE! 52 tests passing   [✓] Bottleneck Assignment ← DONE! 59 tests passing   [✓] Goldberg-Kennedy CSA ← DONE! 80 tests passing   [✓] Sinkhorn-Knopp ← DONE! 48 tests passing  Phase 2 (Completed):   [✓] Ramshaw-Tarjan rectangular ← DONE! 77 tests passing  Phase 3 (Completed):   [✓] Push-Relabel Assignment ← DONE! 77 tests passing  Phase 4 (Completed):   [✓] Return dual variables from existing solvers ← DONE! 86 tests passing       - assignment_duals() function for sensitivity analysis       - Complementary slackness: u[i] + v[j] = cost[i,j] for assigned pairs       - Strong duality: sum(u) + sum(v) = total_cost  Future:   [6] Orlin's algorithm   [7] Network Simplex   [8] GPU acceleration (if demand exists)"},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":"https://gillescolling.com/couplr/ALGORITHM_ROADMAP.html","id":"references","dir":"","previous_headings":"","what":"References","title":"couplr Algorithm Roadmap","text":"Classical: - Kuhn (1955): Hungarian Method - Jonker & Volgenant (1987): shortest augmenting path algorithm - Bertsekas (1988): auction algorithm - Gabow & Tarjan (1989): Faster scaling algorithms Sparse: - Volgenant (1996): Linear semi-assignment problems: core oriented approach Modern: - Ramshaw & Tarjan (2012): minimum-cost assignments unbalanced bipartite graphs - Cuturi (2013): Sinkhorn distances (optimal transport) Bottleneck: - Gross (1959): bottleneck assignment problem - Garfinkel (1971): improved algorithm bottleneck assignment problem","code":""},{"path":"https://gillescolling.com/couplr/ALGORITHM_ROADMAP.html","id":"notes","dir":"","previous_headings":"","what":"Notes","title":"couplr Algorithm Roadmap","text":"new algorithms follow existing export pattern: _impl subdirectory, wrapper rcpp_interface.cpp Test files go tests/testthat/test-assignment-{name}.R Method string added assignment() switch R/lap_solve.R Benchmark existing methods merging","code":""},{"path":"https://gillescolling.com/couplr/articles/algorithms.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"The Algorithm Collection","text":"Hungarian algorithm published 1955. Sixty years later, R packages still use nothing else. couplr implements eighteen algorithms, including methods exist R package: Gabow-Tarjan, Orlin-Ahuja, Network Simplex, Ramshaw-Tarjan.","code":""},{"path":"https://gillescolling.com/couplr/articles/algorithms.html","id":"who-this-vignette-is-for","dir":"Articles","previous_headings":"Overview","what":"Who This Vignette Is For","title":"The Algorithm Collection","text":"Audience: Researchers curious optimization algorithms, developers choosing right method problem, anyone wondering modern algorithms beat Hungarian 20x . Prerequisites: Basic understanding assignment problems (matching rows columns) Familiarity cost matrices (want minimize total cost) Comfort big-O notation (helpful required) ’ll Learn: Hungarian slow later algorithms improved primal-dual, auction, network flow approaches work algorithm choose problem couplr’s automatic selection works","code":""},{"path":"https://gillescolling.com/couplr/articles/algorithms.html","id":"the-race","dir":"Articles","previous_headings":"","what":"The Race","title":"The Algorithm Collection","text":"first: problem, five different solutions.  run five different assignment algorithms identical input, find optimal answer, fastest finishes 22 times quicker slowest. slowest happens Hungarian, algorithm everyone learns textbooks. CSA, fastest , came four decades later. gap represents years algorithmic refinement production software never adopted. anyone need five ways solve problem? don’t behave different conditions. Hungarian method handles 100x100 matrix without complaint becomes painfully slow 1000x1000. Auction algorithm dominates large dense problems stumbles small sparse ones. Different matrix sizes, different sparsity patterns, different cost distributions: situation favors different algorithm. couplr gives , picks right one automatically.","code":""},{"path":"https://gillescolling.com/couplr/articles/algorithms.html","id":"the-problem","dir":"Articles","previous_headings":"","what":"The Problem","title":"The Algorithm Collection","text":"algorithms, problem. ’s simple state: Given nn workers nn jobs, assigning worker ii job jj costs cijc_{ij}, find assignment minimizes total cost. Mathematically: minπ∑=1nci,π() \\min_{\\pi} \\sum_{=1}^{n} c_{,\\pi()} π\\pi permutation (worker gets exactly one job, job gets exactly one worker).  Simple state. simple solve efficiently. n!n! possible assignments. n=20n = 20, ’s 2.4 quintillion possibilities. Brute force impossible. need structure.","code":""},{"path":"https://gillescolling.com/couplr/articles/algorithms.html","id":"the-lp-formulation","dir":"Articles","previous_headings":"The Problem","what":"The LP Formulation","title":"The Algorithm Collection","text":"assignment problem linear program. Let xij∈{0,1}x_{ij} \\\\{0,1\\} indicate whether worker ii assigned job jj: min⁡∑,jcijxijs.t.∑jxij=1∀(worker assigned )∑ixij=1∀j(job filled )xij≥0 \\begin{aligned} \\min \\quad & \\sum_{,j} c_{ij} x_{ij} \\\\ \\text{s.t.} \\quad & \\sum_j x_{ij} = 1 \\quad \\forall \\quad \\text{(worker assigned )} \\\\ & \\sum_i x_{ij} = 1 \\quad \\forall j \\quad \\text{(job filled )} \\\\ & x_{ij} \\geq 0 \\end{aligned} constraint matrix totally unimodular: every square submatrix determinant 0, 1, -1. guarantees integer solutions even relax xij∈{0,1}x_{ij} \\\\{0,1\\} xij≥0x_{ij} \\geq 0.","code":""},{"path":"https://gillescolling.com/couplr/articles/algorithms.html","id":"duality-the-key-to-efficiency","dir":"Articles","previous_headings":"The Problem","what":"Duality: The Key to Efficiency","title":"The Algorithm Collection","text":"dual LP introduces prices uiu_i workers vjv_j jobs: max⁡∑iui+∑jvjs.t.ui+vj≤cij∀,j \\begin{aligned} \\max \\quad & \\sum_i u_i + \\sum_j v_j \\\\ \\text{s.t.} \\quad & u_i + v_j \\leq c_{ij} \\quad \\forall ,j \\end{aligned} Complementary slackness links primal dual: xij=1x_{ij} = 1 optimal assignment, ui+vj=ciju_i + v_j = c_{ij} (constraint tight). means optimal assignments use tight edges dual constraint holds equality. reduced cost edge (,j)(,j) c‾ij=cij−ui−vj\\bar{c}_{ij} = c_{ij} - u_i - v_j. edge tight c‾ij=0\\bar{c}_{ij} = 0. Different algorithms exploit duality different ways.","code":""},{"path":[]},{"path":"https://gillescolling.com/couplr/articles/algorithms.html","id":"hungarian-algorithm-1955","dir":"Articles","previous_headings":"The Classics","what":"Hungarian Algorithm (1955)","title":"The Algorithm Collection","text":"algorithm everyone learns. Published Harold Kuhn, based work Hungarian mathematicians Koenig Egervary. idea: Maintain dual prices (ui,vj)(u_i, v_j) ui+vj≤ciju_i + v_j \\leq c_{ij} pairs. Edges equality holds “tight”: edges can appear optimal solution.  algorithm: Initialize prices. Find tight edges. Find maximum matching using tight edges. matching complete, done. Otherwise, update prices create new tight edges. Repeat. Complexity: O(n3)O(n^3) problem: O(n3)O(n^3) hides large constant. price updates augmenting path searches expensive. 1000x1000 matrix, might wait 10+ seconds. Hungarian works. ’s clean easy teach. 1987, two Dutch researchers found something faster.","code":"cost <- matrix(c(10, 19, 8, 15, 10, 11, 9, 12, 14), nrow = 3, byrow = TRUE) result <- lap_solve(cost, method = \"hungarian\") print(result) #> Assignment Result #> ================= #>  #> # A tibble: 3 × 3 #>   source target  cost #>    <int>  <int> <dbl> #> 1      1      3     8 #> 2      2      2    10 #> 3      3      1     9 #>  #> Total cost: 27  #> Method: hungarian"},{"path":"https://gillescolling.com/couplr/articles/algorithms.html","id":"jonker-volgenant-algorithm-1987","dir":"Articles","previous_headings":"The Classics","what":"Jonker-Volgenant Algorithm (1987)","title":"The Algorithm Collection","text":"Roy Jonker Anton Volgenant asked: start good guess fix ? key insight: Column reduction. sophisticated search, greedily assign row cheapest available column. often gets matching right immediately.  algorithm: Column reduction: column, find two smallest costs. difference “advantage” best row. Reduction transfer: Assign rows columns, handling conflicts dual variable updates. Augmentation: remaining unmatched rows, use Dijkstra-style shortest path search. Complexity: Still O(n3)O(n^3), much smaller constant. Often 10-50x faster Hungarian practice. JV became de facto standard. dense problems thousand rows, ’s hard beat. JV limitation: ’s fundamentally serial. augmenting path depends previous. large problems, need different approach.","code":"set.seed(123) n <- 100 cost <- matrix(runif(n * n, 0, 100), n, n) result <- lap_solve(cost, method = \"jv\") cat(\"Total cost:\", round(get_total_cost(result), 2), \"\\n\") #> Total cost: 149.09"},{"path":"https://gillescolling.com/couplr/articles/algorithms.html","id":"the-scaling-revolution","dir":"Articles","previous_headings":"","what":"The Scaling Revolution","title":"The Algorithm Collection","text":"late 1980s, researchers discovered powerful trick called epsilon-scaling. idea: relax optimality requirement. Instead demanding exact answers every step, tolerate small error epsilon. Start large epsilon, lets make big sloppy steps rapid progress. shrink epsilon multiple phases ’s essentially zero. Now exact answer. transforms algorithm behaves. Large epsilon means big steps rapid progress; small epsilon means careful refinement. total work can end less everything exactly start. Four algorithms exploit insight: Auction, CSA, Gabow-Tarjan, Orlin-Ahuja.","code":""},{"path":"https://gillescolling.com/couplr/articles/algorithms.html","id":"auction-algorithm-1988","dir":"Articles","previous_headings":"The Scaling Revolution","what":"Auction Algorithm (1988)","title":"The Algorithm Collection","text":"Dimitri Bertsekas asked: thought assignment economics problem? metaphor: Workers buyers. Jobs goods. job price. Workers bid favorite jobs. Prices rise ’s competition. Equilibrium = optimal assignment.  algorithm: unassigned worker finds best job (highest value minus price). worker bids: new price = old price + (best value - second-best value) + epsilon. someone else held job, become unassigned. Repeat everyone assigned. epsilon matters: Without epsilon, two workers bid infinitely , raising price 0. epsilon ensures progress. Complexity: O(n2log⁡(nC)/ϵ)O(n^2 \\log(nC) / \\epsilon) CC cost range. couplr offers three Auction variants: Auction shines large dense problems. ’s sensitive epsilon. Get wrong performance degrades, algorithm cycles forever. next algorithm makes epsilon-scaling systematic.","code":"set.seed(123) n <- 100 cost <- matrix(runif(n * n, 0, 100), n, n) result <- lap_solve(cost, method = \"auction\") cat(\"Total cost:\", round(get_total_cost(result), 2), \"\\n\") #> Total cost: 149.09"},{"path":"https://gillescolling.com/couplr/articles/algorithms.html","id":"cost-scaling-algorithm-csa-1995","dir":"Articles","previous_headings":"The Scaling Revolution","what":"Cost-Scaling Algorithm / CSA (1995)","title":"The Algorithm Collection","text":"Andrew Goldberg Robert Kennedy asked: scale epsilon automatically? idea: Start ϵ=max⁡(cij)\\epsilon = \\max(c_{ij}). phase, halve epsilon refine current solution. O(log⁡C)O(\\log C) phases, epsilon essentially zero: optimality.  ’s fast: phase cheap previous phase’s solution good starting point. algorithm exploits progress. Complexity: O(n3)O(n^3) amortized, often faster practice. CSA often wins benchmarks medium-large dense problems. ’s workhorse. ’s even stranger approach: instead scaling costs, scaled bits?","code":"set.seed(456) n <- 100 cost <- matrix(runif(n * n, 0, 100), n, n) result <- lap_solve(cost, method = \"csa\") cat(\"Total cost:\", round(get_total_cost(result), 2), \"\\n\") #> Total cost: 192.48"},{"path":"https://gillescolling.com/couplr/articles/algorithms.html","id":"gabow-tarjan-algorithm-1989","dir":"Articles","previous_headings":"The Scaling Revolution","what":"Gabow-Tarjan Algorithm (1989)","title":"The Algorithm Collection","text":"Harold Gabow Robert Tarjan developed clever algorithm based binary representations. ’s also one complex implement. insight: Integer costs natural scale: binary digits. Process costs significant least significant bit. scale, solve simpler problem. Use solution warm-start next scale.  algorithm (simplified): Initialize coarsest scale (significant bit ). Double scale: multiply costs 2. “doubles” current solution’s slack. Restore 1-feasibility (see ). Use Hungarian-style search augmenting paths. Repeat bits processed. 1-feasibility? Standard dual feasibility requires ui+vj≤ciju_i + v_j \\leq c_{ij} edges. 1-feasibility relaxes : allow ui+vj≤cij+1u_i + v_j \\leq c_{ij} + 1. “1” comes current bit position. scaling phase, need reduced costs within 1 optimal. refine next bit, tighten bound. processing log⁡C\\log C bits, slack less 1, integers means exactly 0: true optimality. Complexity: O(n3log⁡C)O(n^3 \\log C) CC maximum cost. Rarely seen outside academic papers. bookkeeping across scaling phases complex enough implementations skip . Gabow-Tarjan primarily theoretical interest. provides best known worst-case bounds integer costs. ’s one scaling algorithm, even better theoretical complexity.","code":"set.seed(42) n <- 50 # Use integer costs with large range - Gabow-Tarjan's strength cost <- matrix(sample(1:100000, n * n, replace = TRUE), n, n) result <- lap_solve(cost, method = \"gabow_tarjan\") cat(\"Total cost:\", get_total_cost(result), \"\\n\") #> Total cost: 151632"},{"path":"https://gillescolling.com/couplr/articles/algorithms.html","id":"orlin-ahuja-algorithm-1992","dir":"Articles","previous_headings":"The Scaling Revolution","what":"Orlin-Ahuja Algorithm (1992)","title":"The Algorithm Collection","text":"James Orlin Ravindra Ahuja developed double-scaling algorithm scales costs capacities simultaneously. insight: Cost-scaling alone gives O(n3log⁡C)O(n^3 \\log C). also scale flow capacities, can exploit structure sparse graphs. scale, need push O(n)O(\\sqrt{n}) units flow refining. algorithm: Scale costs Gabow-Tarjan (process bits high low). cost scale, use capacity scaling: Start large capacity increments Δ=2k\\Delta = 2^k Find augmenting paths can carry Δ\\Delta flow Halve Δ\\Delta repeat Δ=1\\Delta = 1 capacity scaling limits work per phase O(m)O(m) augmentations. n\\sqrt{n} appears: assignment problem nn units flow total. capacity scaling, phase handles O(n)O(\\sqrt{n}) flow units, O(n)O(\\sqrt{n}) phases per cost scale. geometric structure yields improved bound. Complexity: O(n⋅m⋅log⁡(nC))O(\\sqrt{n} \\cdot m \\cdot \\log(nC)) mm number edges. sparse problems m≪n2m \\ll n^2, dramatically better O(n3)O(n^3). Orlin-Ahuja provides best theoretical bounds sparse problems large cost ranges. implementation complexity substantial: maintaining blocking flows across scaling phases requires careful data structure engineering. practice, overhead often makes slower CSA dense problems. large sparse instances, ’s asymptotically optimal. ’s four scaling algorithms, trading precision speed different way. ’s completely different way think problem entirely.","code":"set.seed(111) n <- 50 cost <- matrix(sample(1:100000, n * n, replace = TRUE), n, n) result <- lap_solve(cost, method = \"orlin\") cat(\"Total cost:\", get_total_cost(result), \"\\n\") #> Total cost: 123035"},{"path":"https://gillescolling.com/couplr/articles/algorithms.html","id":"the-network-view","dir":"Articles","previous_headings":"","what":"The Network View","title":"The Algorithm Collection","text":"Every algorithm far thinks terms assignments: matching workers jobs. assignment problems secretly flow problems. Model assignment network: - source node connected workers (capacity 1 ) Workers connected jobs (costs) Jobs connected sink node (capacity 1 ) Find minimum-cost flow value nn perspective gives us two algorithms.","code":""},{"path":"https://gillescolling.com/couplr/articles/algorithms.html","id":"network-simplex","dir":"Articles","previous_headings":"The Network View","what":"Network Simplex","title":"The Algorithm Collection","text":"simplex method, specialized networks. key insight: network flow problems, simplex basis corresponds spanning tree graph. makes basis operations (pivoting) much faster general LP.  algorithm: Initialize: Find spanning tree TT supports feasible flow (e.g., flow single hub). Compute potentials: tree edges, set πi−πj=cij\\pi_i - \\pi_j = c_{ij}. determines node potentials uniquely (constant). Price non-tree edges: edge (,j)∉T(,j) \\notin T, compute reduced cost c‾ij=cij−πi+πj\\bar{c}_{ij} = c_{ij} - \\pi_i + \\pi_j. Pivot: non-tree edge c‾ij<0\\bar{c}_{ij} < 0, adding TT creates cycle. Push flow around cycle tree edge saturates. Remove edge; non-tree edge enters basis. Repeat reduced costs non-negative (optimality). trees?: tree, ’s exactly one path two nodes. means: - Flow uniquely determined supplies/demands Potentials can computed O(n)O(n) tree traversal pivot changes O(n)O(n) potentials (along tree path), O(n2)O(n^2) Complexity: O(n3)O(n^3) typical, strongly polynomial anti-cycling rules. Best : Problems need dual variables sensitivity analysis. Problems already formulated network flows. Cases want guaranteed finite convergence. Network Simplex standard tool operations research. always fastest, reliable provides rich dual information.","code":"set.seed(789) n <- 100 cost <- matrix(runif(n * n, 0, 100), n, n) result <- lap_solve(cost, method = \"network_simplex\") cat(\"Total cost:\", round(get_total_cost(result), 2), \"\\n\") #> Total cost: 156.88"},{"path":"https://gillescolling.com/couplr/articles/algorithms.html","id":"push-relabel-algorithm","dir":"Articles","previous_headings":"The Network View","what":"Push-Relabel Algorithm","title":"The Algorithm Collection","text":"Goldberg Tarjan’s push-relabel algorithm (1988), adapted minimum-cost flow. key idea: Traditional algorithms maintain valid flow search augmenting paths. Push-relabel inverts : maintain preflow (flow may violate conservation intermediate nodes) work locally eliminate violations. Key concepts: Excess: e(v)=flow −flow oute(v) = \\text{flow } - \\text{flow }. Preflow allows e(v)≥0e(v) \\geq 0 non-sink nodes. Height function: h:V→ℤ≥0h: V \\\\mathbb{Z}_{\\geq 0} h(t)=0h(t) = 0 h(u)≤h(v)+1h(u) \\leq h(v) + 1 residual edges (u,v)(u,v). Admissible edge: Residual edge (u,v)(u,v) h(u)=h(v)+1h(u) = h(v) + 1 (flow goes “downhill”). algorithm: Initialize: Saturate edges source. Set h(s)=nh(s) = n, h(v)=0h(v) = 0 v≠sv \\neq s. node vv excess e(v)>0e(v) > 0: Push: admissible edge (v,w)(v, w) exists, push min⁡(e(v),capacity)\\min(e(v), \\text{capacity}) flow along . Relabel: admissible edge, set h(v)=1+min⁡{h(w):(v,w) residual}h(v) = 1 + \\min\\{h(w) : (v,w) \\text{ residual}\\}. excess remains intermediate nodes, valid maximum flow. minimum-cost flow: Modify push along edges zero reduced cost, relabel using potential updates. gives cost-scaling push-relabel variant. Complexity: O(n2m)O(n^2 m) max-flow, O(n3log⁡(nC))O(n^3 \\log(nC)) min-cost flow. Strengths: Highly parallelizable since pushes local operations. Excellent cache behavior. Dominates practice max-flow; competitive min-cost flow dense graphs. Two network perspectives. problem. Different algorithmic approaches. algorithms assume dense, square matrices. Real problems messier.","code":"set.seed(222) n <- 100 cost <- matrix(runif(n * n, 0, 100), n, n) result <- lap_solve(cost, method = \"push_relabel\") cat(\"Total cost:\", round(get_total_cost(result), 2), \"\\n\") #> Total cost: 169.7"},{"path":[]},{"path":"https://gillescolling.com/couplr/articles/algorithms.html","id":"hk01-binary-costs","dir":"Articles","previous_headings":"The Specialists","what":"HK01: Binary Costs","title":"The Algorithm Collection","text":"costs 0 1, don’t need full machinery. algorithm: Hopcroft-Karp maximum cardinality matching, run zero-cost edges first. add 1-cost edges needed. Complexity: O(n2.5)O(n^{2.5}) binary costs. binary costs large nn, HK01 dramatically faster.","code":"set.seed(101) n <- 100 cost <- matrix(sample(0:1, n^2, replace = TRUE, prob = c(0.3, 0.7)), n, n) result <- lap_solve(cost, method = \"hk01\") cat(\"Total cost:\", get_total_cost(result), \"\\n\") #> Total cost: 0"},{"path":"https://gillescolling.com/couplr/articles/algorithms.html","id":"sap-and-lapmod-sparse-problems","dir":"Articles","previous_headings":"The Specialists","what":"SAP and LAPMOD: Sparse Problems","title":"The Algorithm Collection","text":"80% entries forbidden (Inf NA), store ? SAP (Shortest Augmenting Path) LAPMOD use sparse representations: adjacency lists instead dense matrices. Complexity: O(n2+nm)O(n^2 + nm) mm number allowed edges. sparse problems, SAP can orders magnitude faster dense algorithms.","code":"set.seed(789) n <- 100 cost <- matrix(Inf, n, n) edges <- sample(1:(n^2), floor(0.2 * n^2))  # Only 20% allowed cost[edges] <- runif(length(edges), 0, 100) result <- lap_solve(cost, method = \"sap\") cat(\"Total cost:\", round(get_total_cost(result), 2), \"\\n\") #> Total cost: 794.94"},{"path":"https://gillescolling.com/couplr/articles/algorithms.html","id":"ramshaw-tarjan-rectangular-problems-2012","dir":"Articles","previous_headings":"The Specialists","what":"Ramshaw-Tarjan: Rectangular Problems (2012)","title":"The Algorithm Collection","text":"algorithms assume square matrices. nn workers m>nm > n jobs, standard approaches pad m−nm - n dummy workers zero cost. works wastes effort: algorithm processes m×mm \\times m entries n×mn \\times m matter. Ramshaw Tarjan (2012) developed algorithm handles rectangularity natively exploiting structure unbalanced bipartite graphs. key insight: rectangular assignment, match nn rows nn mm columns. dual problem different structure: row duals uiu_i unconstrained, column duals vjv_j must satisfy vj≤0v_j \\leq 0 unmatched columns. algorithm: Maintain dual variables (u,v)(u, v) ui+vj≤ciju_i + v_j \\leq c_{ij} vj≤0v_j \\leq 0 free columns. Use modified Dijkstra search respects asymmetric dual constraints. augmenting, update duals preserve feasibility without padding. Complexity: O(nmlog⁡n)O(nm \\log n) using Fibonacci heaps, O(nm+n2log⁡n)O(nm + n^2 \\log n) simpler structures. highly rectangular problems (e.g., matching 100 treatments 10,000 controls), avoids O(m3)O(m^3) cost padding square. significantly columns rows (vice versa), Ramshaw-Tarjan avoids wasted work padding. newest algorithm couplr’s collection, essential large-scale matching problems treatment control pools different sizes.","code":"set.seed(333) n_rows <- 30 n_cols <- 100  # Highly rectangular: 30 x 100 cost <- matrix(runif(n_rows * n_cols, 0, 100), n_rows, n_cols) result <- lap_solve(cost, method = \"ramshaw_tarjan\") cat(\"Matched\", sum(result$assignment > 0), \"of\", n_rows, \"rows\\n\") #> Warning: Unknown or uninitialised column: `assignment`. #> Matched 0 of 30 rows"},{"path":"https://gillescolling.com/couplr/articles/algorithms.html","id":"beyond-standard-assignment","dir":"Articles","previous_headings":"","what":"Beyond Standard Assignment","title":"The Algorithm Collection","text":"couplr includes specialized solvers variations assignment problem.","code":""},{"path":"https://gillescolling.com/couplr/articles/algorithms.html","id":"k-best-solutions-murtys-algorithm","dir":"Articles","previous_headings":"Beyond Standard Assignment","what":"K-Best Solutions (Murty’s Algorithm)","title":"The Algorithm Collection","text":"want 2nd best assignment? 3rd best? k-th best? Use cases: Sensitivity analysis. Alternative plans optimal infeasible. Understanding costs affect solutions.","code":"cost <- matrix(c(10, 19, 8, 15, 10, 18, 7, 17, 13, 16, 9, 14, 12, 19, 8, 18),                nrow = 4, byrow = TRUE) kbest <- lap_solve_kbest(cost, k = 5) summary(kbest) #> # A tibble: 5 × 4 #>    rank solution_id total_cost n_assignments #>   <int>       <int>      <dbl>         <int> #> 1     1           1         49             4 #> 2     2           2         50             4 #> 3     3           3         50             4 #> 4     4           4         51             4 #> 5     5           5         51             4"},{"path":"https://gillescolling.com/couplr/articles/algorithms.html","id":"bottleneck-assignment","dir":"Articles","previous_headings":"Beyond Standard Assignment","what":"Bottleneck Assignment","title":"The Algorithm Collection","text":"Minimize maximum edge cost instead sum. Use cases: Load balancing. Fairness constraints. Worst-case optimization.","code":"cost <- matrix(c(5, 9, 2, 10, 3, 7, 8, 4, 6), nrow = 3, byrow = TRUE) result <- bottleneck_assignment(cost) cat(\"Bottleneck (max edge):\", result$bottleneck, \"\\n\") #> Bottleneck (max edge): 6"},{"path":"https://gillescolling.com/couplr/articles/algorithms.html","id":"sinkhorn-soft-assignment","dir":"Articles","previous_headings":"Beyond Standard Assignment","what":"Sinkhorn: Soft Assignment","title":"The Algorithm Collection","text":"Entropy-regularized optimal transport. Instead hard 0/1 assignment, produce doubly-stochastic transport plan. Use cases: Probabilistic matching. Domain adaptation. Wasserstein distances.","code":"cost <- matrix(c(1, 2, 3, 4), nrow = 2) result <- sinkhorn(cost, lambda = 10) print(round(result$transport_plan, 3)) #>      [,1] [,2] #> [1,] 0.25 0.25 #> [2,] 0.25 0.25"},{"path":"https://gillescolling.com/couplr/articles/algorithms.html","id":"dual-variables","dir":"Articles","previous_headings":"Beyond Standard Assignment","what":"Dual Variables","title":"The Algorithm Collection","text":"Extract dual prices sensitivity analysis. Use cases: Shadow prices. Identifying critical assignments. Marginal cost analysis.","code":"cost <- matrix(c(10, 19, 8, 15, 10, 18, 7, 17, 13), nrow = 3, byrow = TRUE) result <- assignment_duals(cost) cat(\"Row duals (u):\", result$u, \"\\n\") #> Row duals (u): 8 10 7 cat(\"Col duals (v):\", result$v, \"\\n\") #> Col duals (v): 0 0 0"},{"path":"https://gillescolling.com/couplr/articles/algorithms.html","id":"the-benchmark","dir":"Articles","previous_headings":"","what":"The Benchmark","title":"The Algorithm Collection","text":"’ve seen algorithms . Now: fast?  dense matrices: CSA JV consistently fastest. Hungarian falls behind rapidly. Auction Network Simplex solid middle-ground choices.  sparse matrices: SAP LAPMOD 10x faster dense algorithms. Use .","code":""},{"path":"https://gillescolling.com/couplr/articles/algorithms.html","id":"quick-reference","dir":"Articles","previous_headings":"","what":"Quick Reference","title":"The Algorithm Collection","text":"just use method = \"auto\" let couplr choose.","code":""},{"path":"https://gillescolling.com/couplr/articles/algorithms.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"The Algorithm Collection","text":"Kuhn, H. W. (1955). Hungarian method assignment problem. Naval Research Logistics Quarterly. Jonker, R., & Volgenant, . (1987). shortest augmenting path algorithm dense sparse linear assignment problems. Computing. Bertsekas, D. P. (1988). auction algorithm: distributed relaxation method. Annals Operations Research. Gabow, H. N., & Tarjan, R. E. (1989). Faster scaling algorithms network problems. SIAM Journal Computing. Goldberg, . V., & Kennedy, R. (1995). efficient cost scaling algorithm assignment problem. Mathematical Programming. Orlin, J. B., & Ahuja, R. K. (1992). New scaling algorithms assignment minimum mean cycle problems. Mathematical Programming. Ramshaw, L., & Tarjan, R. E. (2012). minimum-cost assignments unbalanced bipartite graphs. HP Labs Technical Report. Goldberg, . V., & Tarjan, R. E. (1988). new approach maximum-flow problem. Journal ACM. Murty, K. G. (1968). algorithm ranking assignments order increasing cost. Operations Research. Cuturi, M. (2013). Sinkhorn distances: Lightspeed computation optimal transport. NeurIPS. Burkard, R., Dell’Amico, M., & Martello, S. (2009). Assignment Problems. SIAM.","code":""},{"path":"https://gillescolling.com/couplr/articles/comparison.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"Comparison with Alternatives","text":"vignette compares couplr’s approach matching established R packages: 1. MatchIt - popular matching package R optmatch - Optimal full matching constraints designmatch - Optimization-based matching balance constraints Matching - Genetic matching multivariate matching comparison examines algorithmic differences, API design, performance characteristics, appropriate use cases. use simulated observational data demonstrate practical differences. Prerequisites: Familiarity vignette(\"matching-workflows\") couplr’s matching approach.","code":""},{"path":"https://gillescolling.com/couplr/articles/comparison.html","id":"evaluation-dataset","dir":"Articles","previous_headings":"","what":"Evaluation Dataset","title":"Comparison with Alternatives","text":"simulate job training evaluation scenario selection bias: Substantial baseline imbalance exists: treatment group younger (-0.9 SD), educated (+0.7 SD), higher prior earnings (+0.6 SD).","code":"set.seed(42)  # Treatment group: younger, more educated, higher prior earnings treatment <- tibble(    id = 1:200,   age = rnorm(200, mean = 35, sd = 8),   education = rnorm(200, mean = 14, sd = 2),   prior_earnings = rnorm(200, mean = 40000, sd = 12000),   employed = rbinom(200, 1, 0.7),   group = \"treatment\" )  # Control group: older, less educated, lower prior earnings (selection bias) control <- tibble(   id = 201:700,   age = rnorm(500, mean = 45, sd = 12),   education = rnorm(500, mean = 12, sd = 3),   prior_earnings = rnorm(500, mean = 32000, sd = 15000),   employed = rbinom(500, 1, 0.5),   group = \"control\" )  # Combine for packages that expect single data frame combined <- bind_rows(treatment, control) %>%   mutate(treated = as.integer(group == \"treatment\"))  cat(\"Treatment units:\", nrow(treatment), \"\\n\") #> Treatment units: 200 cat(\"Control units:\", nrow(control), \"\\n\") #> Control units: 500  # Baseline imbalance vars <- c(\"age\", \"education\", \"prior_earnings\", \"employed\") for (v in vars) {   diff <- mean(treatment[[v]]) - mean(control[[v]])   pooled_sd <- sqrt((var(treatment[[v]]) + var(control[[v]])) / 2)   std_diff <- diff / pooled_sd   cat(sprintf(\"%s: std diff = %.3f\\n\", v, std_diff)) } #> age: std diff = -0.967 #> education: std diff = 0.775 #> prior_earnings: std diff = 0.576 #> employed: std diff = 0.365"},{"path":[]},{"path":"https://gillescolling.com/couplr/articles/comparison.html","id":"overview-1","dir":"Articles","previous_headings":"Comparison 1: MatchIt","what":"Overview","title":"Comparison with Alternatives","text":"MatchIt (Ho et al., 2011) widely used matching package R. emphasizes propensity score methods provides unified interface multiple matching algorithms. Key difference: MatchIt typically matches estimated propensity scores (single summary measure), couplr matches directly covariates (multivariate distance).","code":""},{"path":"https://gillescolling.com/couplr/articles/comparison.html","id":"matchit-approach","dir":"Articles","previous_headings":"Comparison 1: MatchIt","what":"MatchIt Approach","title":"Comparison with Alternatives","text":"","code":"if (requireNamespace(\"MatchIt\", quietly = TRUE)) {   library(MatchIt)    # MatchIt: Propensity score matching (default)   m_ps <- matchit(     treated ~ age + education + prior_earnings + employed,     data = combined,     method = \"nearest\",     distance = \"glm\"  # Propensity score via logistic regression   )    cat(\"MatchIt (propensity score, nearest neighbor):\\n\")   cat(\"  Matched pairs:\", sum(m_ps$weights[combined$treated == 1] > 0), \"\\n\")    # Extract matched data   matched_ps <- match.data(m_ps) }"},{"path":"https://gillescolling.com/couplr/articles/comparison.html","id":"couplr-approach","dir":"Articles","previous_headings":"Comparison 1: MatchIt","what":"couplr Approach","title":"Comparison with Alternatives","text":"","code":"# couplr: Direct covariate matching result_couplr <- match_couples(   left = treatment,   right = control,   vars = c(\"age\", \"education\", \"prior_earnings\", \"employed\"),   auto_scale = TRUE,   scale = \"robust\" )  cat(\"\\ncouplr (direct covariate matching):\\n\") #>  #> couplr (direct covariate matching): cat(\"  Matched pairs:\", result_couplr$info$n_matched, \"\\n\") #>   Matched pairs: 200 cat(\"  Mean distance:\", round(mean(result_couplr$pairs$distance), 4), \"\\n\") #>   Mean distance: 0.5844"},{"path":"https://gillescolling.com/couplr/articles/comparison.html","id":"balance-comparison","dir":"Articles","previous_headings":"Comparison 1: MatchIt","what":"Balance Comparison","title":"Comparison with Alternatives","text":"","code":"if (requireNamespace(\"MatchIt\", quietly = TRUE)) {   # MatchIt balance   matched_treated_ps <- matched_ps %>% filter(treated == 1)   matched_control_ps <- matched_ps %>% filter(treated == 0)    matchit_balance <- tibble(     variable = vars,     std_diff = sapply(vars, function(v) {       diff <- mean(matched_treated_ps[[v]]) - mean(matched_control_ps[[v]])       pooled_sd <- sqrt((var(matched_treated_ps[[v]]) + var(matched_control_ps[[v]])) / 2)       diff / pooled_sd     }),     method = \"MatchIt\"   )    # couplr balance   couplr_balance <- balance_diagnostics(     result_couplr, treatment, control, vars   )    couplr_balance_df <- couplr_balance$var_stats %>%     dplyr::select(variable, std_diff) %>%     mutate(method = \"couplr\")    # Combine and plot   balance_comparison <- bind_rows(matchit_balance, couplr_balance_df)    ggplot(balance_comparison, aes(x = variable, y = abs(std_diff), fill = method)) +     geom_col(position = \"dodge\") +     geom_hline(yintercept = 0.1, linetype = \"dashed\", color = \"#93c54b\") +     geom_hline(yintercept = 0.25, linetype = \"dashed\", color = \"#f47c3c\") +     labs(       title = \"Covariate Balance: MatchIt vs couplr\",       subtitle = \"Green line = 0.1 (excellent), Orange line = 0.25 (acceptable)\",       x = \"Variable\",       y = \"|Standardized Difference|\",       fill = \"Method\"     ) +     scale_fill_manual(values = c(\"MatchIt\" = \"#29abe0\", \"couplr\" = \"#93c54b\")) +     theme_minimal() +     theme(       plot.background = element_rect(fill = \"transparent\", color = NA),       panel.background = element_rect(fill = \"transparent\", color = NA),       legend.position = \"bottom\"     ) }"},{"path":[]},{"path":"https://gillescolling.com/couplr/articles/comparison.html","id":"when-to-use-each","dir":"Articles","previous_headings":"Comparison 1: MatchIt","what":"When to Use Each","title":"Comparison with Alternatives","text":"MatchIt: - Propensity score methods preferred (common epidemiology) Need full matching, CEM, genetic matching Following published protocols specify MatchIt Familiar propensity score theory couplr: - Direct covariate matching preferred (model treatment) Need optimal (minimum distance) one--one matching Working large datasets (20+ LAP algorithms different scales) Need fine-grained control distance computation Matching continuous variables Euclidean distance natural","code":""},{"path":[]},{"path":"https://gillescolling.com/couplr/articles/comparison.html","id":"overview-2","dir":"Articles","previous_headings":"Comparison 2: optmatch","what":"Overview","title":"Comparison with Alternatives","text":"optmatch (Hansen & Klopfer, 2006) specializes optimal matching using network flow algorithms. emphasizes full matching variable ratio matching. Key difference: optmatch excels optimal full matching (variable ratios); couplr focuses optimal one--one matching 20+ algorithm choices.","code":""},{"path":"https://gillescolling.com/couplr/articles/comparison.html","id":"optmatch-approach","dir":"Articles","previous_headings":"Comparison 2: optmatch","what":"optmatch Approach","title":"Comparison with Alternatives","text":"","code":"if (requireNamespace(\"optmatch\", quietly = TRUE)) {   library(optmatch)    # Create distance matrix   dist_mat <- match_on(     treated ~ age + education + prior_earnings + employed,     data = combined,     method = \"mahalanobis\"   )    # Optimal pair matching   m_opt <- pairmatch(dist_mat, data = combined)    n_matched <- sum(!is.na(m_opt)) / 2   cat(\"optmatch (optimal pair matching):\\n\")   cat(\"  Matched pairs:\", n_matched, \"\\n\") }"},{"path":"https://gillescolling.com/couplr/articles/comparison.html","id":"couplr-approach-1","dir":"Articles","previous_headings":"Comparison 2: optmatch","what":"couplr Approach","title":"Comparison with Alternatives","text":"","code":"# couplr with Mahalanobis-like scaling result_couplr_maha <- match_couples(   left = treatment,   right = control,   vars = vars,   auto_scale = TRUE,   scale = \"standardize\"  # Similar to Mahalanobis diagonal )  cat(\"\\ncouplr (optimal pair matching):\\n\") #>  #> couplr (optimal pair matching): cat(\"  Matched pairs:\", result_couplr_maha$info$n_matched, \"\\n\") #>   Matched pairs: 200"},{"path":"https://gillescolling.com/couplr/articles/comparison.html","id":"performance-comparison","dir":"Articles","previous_headings":"Comparison 2: optmatch","what":"Performance Comparison","title":"Comparison with Alternatives","text":"packages use optimal assignment algorithms, achieve similar total distances. key differences : API design: optmatch uses formula interface; couplr uses separate data frames Algorithm selection: optmatch uses RELAX-IV; couplr offers 20+ algorithms Full matching: optmatch supports variable-ratio matching; couplr one--one ","code":"if (requireNamespace(\"optmatch\", quietly = TRUE)) {   # Compare total distances   # (Note: Direct comparison is complex due to different distance scaling)   cat(\"\\nBoth packages find globally optimal one-to-one assignments.\\n\")   cat(\"Total distance differences arise from distance metric choices.\\n\") }"},{"path":[]},{"path":"https://gillescolling.com/couplr/articles/comparison.html","id":"when-to-use-each-1","dir":"Articles","previous_headings":"Comparison 2: optmatch","what":"When to Use Each","title":"Comparison with Alternatives","text":"optmatch: - Full matching variable ratio matching needed Network flow formulation preferred Integration RItools diagnostics couplr: - One--one matching sufficient Need algorithm flexibility (auction n > 1000, sparse methods, etc.) Large-scale problems requiring greedy approximations Distance caching iterative analysis","code":""},{"path":[]},{"path":"https://gillescolling.com/couplr/articles/comparison.html","id":"overview-3","dir":"Articles","previous_headings":"Comparison 3: designmatch","what":"Overview","title":"Comparison with Alternatives","text":"designmatch (Zubizarreta et al., 2018) uses mixed-integer programming find matches satisfying explicit balance constraints. Rather minimizing distance, finds feasible matches meet user-specified balance criteria. Key difference: designmatch optimizes balance constraints directly; couplr minimizes total distance (balance consequence, constraint).","code":""},{"path":"https://gillescolling.com/couplr/articles/comparison.html","id":"designmatch-approach","dir":"Articles","previous_headings":"Comparison 3: designmatch","what":"designmatch Approach","title":"Comparison with Alternatives","text":"","code":"if (requireNamespace(\"designmatch\", quietly = TRUE)) {   library(designmatch)    # Prepare data for designmatch   t_ind <- combined$treated    # Distance matrix (Mahalanobis)   X <- as.matrix(combined[, vars])   dist_mat_dm <- distmat(t_ind, X)    # Balance constraints: mean differences   mom <- list(     covs = X,     tols = rep(0.1, ncol(X))  # Tolerance for standardized difference   )    # Solve with balance constraints   tryCatch({     m_dm <- bmatch(       t_ind = t_ind,       dist_mat = dist_mat_dm,       mom = mom,       solver = list(name = \"glpk\", approximate = 1)     )      cat(\"designmatch (balance-constrained matching):\\n\")     cat(\"  Matched pairs:\", sum(m_dm$t_id > 0), \"\\n\")   }, error = function(e) {     cat(\"designmatch: Balance constraints may be infeasible\\n\")     cat(\"  Try relaxing tolerances or reducing constraint count\\n\")   }) }"},{"path":"https://gillescolling.com/couplr/articles/comparison.html","id":"couplr-approach-2","dir":"Articles","previous_headings":"Comparison 3: designmatch","what":"couplr Approach","title":"Comparison with Alternatives","text":"couplr doesn’t constrain balance directly achieves balance distance minimization:","code":"# couplr: Optimize distance, then check balance result_couplr_dm <- match_couples(   left = treatment,   right = control,   vars = vars,   auto_scale = TRUE   # No caliper - let algorithm find optimal matches ) #> Auto-selected scaling method: standardize  balance_dm <- balance_diagnostics(result_couplr_dm, treatment, control, vars) #> Warning in ks.test.default(left_clean, right_clean): p-value will be #> approximate in the presence of ties  cat(\"\\ncouplr (distance-minimizing):\\n\") #>  #> couplr (distance-minimizing): cat(\"  Matched pairs:\", result_couplr_dm$info$n_matched, \"\\n\") #>   Matched pairs: 200 cat(\"  Mean |std diff|:\", round(balance_dm$overall$mean_abs_std_diff, 4), \"\\n\") #>   Mean |std diff|: 0.2343 cat(\"  Max |std diff|:\", round(balance_dm$overall$max_abs_std_diff, 4), \"\\n\") #>   Max |std diff|: 0.4387"},{"path":[]},{"path":"https://gillescolling.com/couplr/articles/comparison.html","id":"when-to-use-each-2","dir":"Articles","previous_headings":"Comparison 3: designmatch","what":"When to Use Each","title":"Comparison with Alternatives","text":"designmatch: - Specific balance requirements must guaranteed Cardinality matching (fixed sample sizes) Fine-grained moment balancing (means, variances, quantiles) Willing accept solution constraints infeasible couplr: - Distance minimization goal Balance assessed post-hoc (typical workflow) Need guaranteed solutions Iterative refinement (match, assess, refine)","code":""},{"path":[]},{"path":"https://gillescolling.com/couplr/articles/comparison.html","id":"overview-4","dir":"Articles","previous_headings":"Comparison 4: Matching Package","what":"Overview","title":"Comparison with Alternatives","text":"Matching package (Sekhon, 2011) provides genetic matching multivariate matching automatic balance optimization. Key difference: Matching uses genetic algorithms find weights optimize balance; couplr uses fixed weights (scaling) optimizes assignment.","code":""},{"path":"https://gillescolling.com/couplr/articles/comparison.html","id":"matching-package-approach","dir":"Articles","previous_headings":"Comparison 4: Matching Package","what":"Matching Package Approach","title":"Comparison with Alternatives","text":"","code":"if (requireNamespace(\"Matching\", quietly = TRUE)) {   library(Matching)    # Genetic matching (finds optimal weights)   X <- as.matrix(combined[, vars])    set.seed(123)   m_gen <- Match(     Tr = combined$treated,     X = X,     M = 1,  # 1:1 matching     estimand = \"ATT\",     replace = FALSE   )    cat(\"Matching package (multivariate matching):\\n\")   cat(\"  Matched pairs:\", length(m_gen$index.treated), \"\\n\") }"},{"path":"https://gillescolling.com/couplr/articles/comparison.html","id":"balance-comparison-1","dir":"Articles","previous_headings":"Comparison 4: Matching Package","what":"Balance Comparison","title":"Comparison with Alternatives","text":"","code":"if (requireNamespace(\"Matching\", quietly = TRUE)) {   # Check balance from Matching package   mb <- MatchBalance(     treated ~ age + education + prior_earnings + employed,     data = combined,     match.out = m_gen,     nboots = 0   ) }"},{"path":[]},{"path":"https://gillescolling.com/couplr/articles/comparison.html","id":"when-to-use-each-3","dir":"Articles","previous_headings":"Comparison 4: Matching Package","what":"When to Use Each","title":"Comparison with Alternatives","text":"Matching: - Need automatic weight selection via genetic optimization Matching replacement acceptable Need ATE ATC estimands (just ATT) Willing accept stochastic results couplr: - Deterministic, reproducible matching Matching without replacement Direct control variable scaling Large problems (couplr scales better)","code":""},{"path":[]},{"path":"https://gillescolling.com/couplr/articles/comparison.html","id":"runtime-scaling","dir":"Articles","previous_headings":"Performance Comparison","what":"Runtime Scaling","title":"Comparison with Alternatives","text":"packages slow problem size, different rates: Note: couplr’s greedy matching fastest large problems. optimal matching, optmatch’s RELAX-IV competitive. couplr offers algorithm choices different scenarios.","code":""},{"path":"https://gillescolling.com/couplr/articles/comparison.html","id":"memory-usage","dir":"Articles","previous_headings":"Performance Comparison","what":"Memory Usage","title":"Comparison with Alternatives","text":"large problems (n > 10,000), use couplr’s blocking greedy modes.","code":""},{"path":[]},{"path":[]},{"path":"https://gillescolling.com/couplr/articles/comparison.html","id":"choose-couplr-when","dir":"Articles","previous_headings":"Decision Guide","what":"Choose couplr when:","title":"Comparison with Alternatives","text":"Direct covariate matching preferred propensity scores Optimal one--one matching goal Large datasets (n > 5,000) greedy blocking options Algorithm flexibility needed (auction large dense, sparse many forbidden) Distance caching helps iterative analysis Tidy workflow tibble outputs preferred Reproducibility requires deterministic algorithms","code":""},{"path":"https://gillescolling.com/couplr/articles/comparison.html","id":"choose-matchit-when","dir":"Articles","previous_headings":"Decision Guide","what":"Choose MatchIt when:","title":"Comparison with Alternatives","text":"Propensity score matching standard field Need full matching CEM (coarsened exact matching) Following published protocol specifies MatchIt Need genetic matching automatic weight selection Integration existing MatchIt workflows","code":""},{"path":"https://gillescolling.com/couplr/articles/comparison.html","id":"choose-optmatch-when","dir":"Articles","previous_headings":"Decision Guide","what":"Choose optmatch when:","title":"Comparison with Alternatives","text":"Full matching variable ratios needed Network flow formulation preferred Working RItools diagnostics Need optimal pair matching sparse distance matrices","code":""},{"path":"https://gillescolling.com/couplr/articles/comparison.html","id":"choose-designmatch-when","dir":"Articles","previous_headings":"Decision Guide","what":"Choose designmatch when:","title":"Comparison with Alternatives","text":"Specific balance constraints must guaranteed Cardinality matching (exact sample sizes) needed Fine-grained moment balancing required MIP solvers (Gurobi) available speed","code":""},{"path":[]},{"path":"https://gillescolling.com/couplr/articles/comparison.html","id":"sequential-pipeline","dir":"Articles","previous_headings":"Workflow Integration","what":"Sequential Pipeline","title":"Comparison with Alternatives","text":"","code":"# Stage 1: couplr for initial matching matched <- match_couples(   left = treatment_data,   right = control_data,   vars = covariates,   auto_scale = TRUE )  # Stage 2: Check balance balance <- balance_diagnostics(matched, treatment_data, control_data, covariates)  # Stage 3: If balance insufficient, consider alternatives if (balance$overall$max_abs_std_diff > 0.25) {   # Try MatchIt with propensity scores   library(MatchIt)   combined <- bind_rows(treatment_data, control_data)   m_ps <- matchit(treated ~ ., data = combined, method = \"full\") }  # Stage 4: Analysis on matched data matched_data <- join_matched(matched, treatment_data, control_data) model <- lm(outcome ~ treatment, data = matched_data)"},{"path":"https://gillescolling.com/couplr/articles/comparison.html","id":"complementary-use","dir":"Articles","previous_headings":"Workflow Integration","what":"Complementary Use","title":"Comparison with Alternatives","text":"Different packages excel different tasks: {r, eval = FALSE } # Use couplr : initial exploration, large-scale matching, distance caching # Use MatchIt : propensity scores, full matching, published protocols # Use optmatch : optimal full matching sparse distances # Use designmatch : guaranteed balance constraints","code":""},{"path":"https://gillescolling.com/couplr/articles/comparison.html","id":"real-world-case-study-job-training-evaluation","dir":"Articles","previous_headings":"","what":"Real-World Case Study: Job Training Evaluation","title":"Comparison with Alternatives","text":"section applies couplr dataset inspired classic Lalonde (1986) job training evaluation, demonstrating full workflow realistic data.","code":""},{"path":"https://gillescolling.com/couplr/articles/comparison.html","id":"background","dir":"Articles","previous_headings":"Real-World Case Study: Job Training Evaluation","what":"Background","title":"Comparison with Alternatives","text":"National Supported Work (NSW) demonstration randomized job training program. methodological challenge evaluating program using observational (non-randomized) comparison groups, introduces selection bias. Typical covariates: age, education, race, marital status, prior earnings (re74, re75), employment status.","code":""},{"path":"https://gillescolling.com/couplr/articles/comparison.html","id":"simulating-lalonde-style-data","dir":"Articles","previous_headings":"Real-World Case Study: Job Training Evaluation","what":"Simulating Lalonde-Style Data","title":"Comparison with Alternatives","text":"","code":"set.seed(1986)  # NSW treatment group (randomized) - smaller sample for CRAN nsw_treat <- tibble(   id = 1:100,   age = pmax(17, rnorm(100, 25, 7)),   education = pmax(0, pmin(16, rnorm(100, 10, 2))),   black = rbinom(100, 1, 0.84),   hispanic = rbinom(100, 1, 0.06),   married = rbinom(100, 1, 0.19),   nodegree = rbinom(100, 1, 0.71),   re74 = pmax(0, rnorm(100, 2100, 5000)),   re75 = pmax(0, rnorm(100, 1500, 3500)),   group = \"treatment\" )  # CPS comparison group (observational - very different!) # Reduced from 15,815 to 500 for CRAN timing compliance cps_control <- tibble(   id = 101:600,   age = pmax(17, rnorm(500, 33, 11)),   education = pmax(0, pmin(16, rnorm(500, 12, 3))),   black = rbinom(500, 1, 0.07),   hispanic = rbinom(500, 1, 0.07),   married = rbinom(500, 1, 0.71),   nodegree = rbinom(500, 1, 0.30),   re74 = pmax(0, rnorm(500, 14000, 9000)),   re75 = pmax(0, rnorm(500, 13500, 9000)),   group = \"control\" )  cat(\"NSW treatment:\", nrow(nsw_treat), \"individuals\\n\") #> NSW treatment: 100 individuals cat(\"CPS control:\", nrow(cps_control), \"individuals\\n\") #> CPS control: 500 individuals cat(\"(Note: Real CPS has ~16,000 controls; reduced here for vignette timing)\\n\") #> (Note: Real CPS has ~16,000 controls; reduced here for vignette timing)  # Baseline imbalance is severe vars_lalonde <- c(\"age\", \"education\", \"black\", \"hispanic\", \"married\",                   \"nodegree\", \"re74\", \"re75\") cat(\"\\nBaseline standardized differences:\\n\") #>  #> Baseline standardized differences: for (v in vars_lalonde) {   t_mean <- mean(nsw_treat[[v]])   c_mean <- mean(cps_control[[v]])   pooled_sd <- sqrt((var(nsw_treat[[v]]) + var(cps_control[[v]])) / 2)   std_diff <- (t_mean - c_mean) / pooled_sd   cat(sprintf(\"  %s: %.2f\\n\", v, std_diff)) } #>   age: -0.87 #>   education: -0.78 #>   black: 2.27 #>   hispanic: -0.07 #>   married: -1.21 #>   nodegree: 0.75 #>   re74: -1.60 #>   re75: -1.83"},{"path":"https://gillescolling.com/couplr/articles/comparison.html","id":"challenge-large-control-pool","dir":"Articles","previous_headings":"Real-World Case Study: Job Training Evaluation","what":"Challenge: Large Control Pool","title":"Comparison with Alternatives","text":"treatment vs control groups different sizes, need efficient matching. couplr handles greedy matching:","code":"# Greedy matching (fast for large control pools) result_lalonde <- greedy_couples(   left = nsw_treat,   right = cps_control,   vars = vars_lalonde,   strategy = \"pq\",       # Priority queue - efficient for large pools   auto_scale = TRUE,   scale = \"robust\" )  cat(\"Matched\", result_lalonde$info$n_matched, \"of\", nrow(nsw_treat), \"treatment units\\n\") #> Matched 100 of 100 treatment units cat(\"Mean distance:\", round(mean(result_lalonde$pairs$distance), 4), \"\\n\") #> Mean distance: 1.5267"},{"path":"https://gillescolling.com/couplr/articles/comparison.html","id":"balance-assessment","dir":"Articles","previous_headings":"Real-World Case Study: Job Training Evaluation","what":"Balance Assessment","title":"Comparison with Alternatives","text":"","code":"balance_lalonde <- balance_diagnostics(   result_lalonde, nsw_treat, cps_control, vars_lalonde ) #> Warning in ks.test.default(left_clean, right_clean): p-value will be #> approximate in the presence of ties #> Warning in ks.test.default(left_clean, right_clean): p-value will be #> approximate in the presence of ties #> Warning in ks.test.default(left_clean, right_clean): p-value will be #> approximate in the presence of ties #> Warning in ks.test.default(left_clean, right_clean): p-value will be #> approximate in the presence of ties #> Warning in ks.test.default(left_clean, right_clean): p-value will be #> approximate in the presence of ties #> Warning in ks.test.default(left_clean, right_clean): p-value will be #> approximate in the presence of ties #> Warning in ks.test.default(left_clean, right_clean): p-value will be #> approximate in the presence of ties  # Before/after comparison before_df <- tibble(   variable = vars_lalonde,   std_diff = sapply(vars_lalonde, function(v) {     t_mean <- mean(nsw_treat[[v]])     c_mean <- mean(cps_control[[v]])     pooled_sd <- sqrt((var(nsw_treat[[v]]) + var(cps_control[[v]])) / 2)     (t_mean - c_mean) / pooled_sd   }),   stage = \"Before\" )  after_df <- balance_lalonde$var_stats %>%   dplyr::select(variable, std_diff) %>%   mutate(stage = \"After\")  balance_plot_df <- bind_rows(before_df, after_df) %>%   mutate(stage = factor(stage, levels = c(\"Before\", \"After\")))  ggplot(balance_plot_df, aes(x = reorder(variable, abs(std_diff)),                              y = std_diff, fill = stage)) +   geom_col(position = \"dodge\") +   geom_hline(yintercept = c(-0.1, 0.1), linetype = \"dashed\", color = \"#93c54b\") +   geom_hline(yintercept = c(-0.25, 0.25), linetype = \"dashed\", color = \"#f47c3c\") +   coord_flip() +   labs(     title = \"Covariate Balance: Before vs After Matching\",     subtitle = \"Lalonde-style job training evaluation\",     x = \"\",     y = \"Standardized Difference\",     fill = \"\"   ) +   scale_fill_manual(values = c(\"Before\" = \"#d9534f\", \"After\" = \"#93c54b\")) +   theme_minimal() +   theme(     legend.position = \"bottom\",     plot.title = element_text(face = \"bold\")   )"},{"path":"https://gillescolling.com/couplr/articles/comparison.html","id":"interpretation","dir":"Articles","previous_headings":"Real-World Case Study: Job Training Evaluation","what":"Interpretation","title":"Comparison with Alternatives","text":"matching dramatically reduces imbalance:","code":"cat(\"Balance summary:\\n\") #> Balance summary: cat(\"  Mean |std diff| before:\",     round(mean(abs(before_df$std_diff)), 3), \"\\n\") #>   Mean |std diff| before: 1.171 cat(\"  Mean |std diff| after:\",     round(balance_lalonde$overall$mean_abs_std_diff, 3), \"\\n\") #>   Mean |std diff| after: 0.748 cat(\"  Max |std diff| after:\",     round(balance_lalonde$overall$max_abs_std_diff, 3), \"\\n\") #>   Max |std diff| after: 1.97  if (balance_lalonde$overall$max_abs_std_diff < 0.25) {   cat(\"\\nYes All variables within acceptable balance threshold (0.25)\\n\") } else {   cat(\"\\n⚠ Some variables exceed 0.25 threshold - consider calipers or blocking\\n\") } #>  #> ⚠ Some variables exceed 0.25 threshold - consider calipers or blocking"},{"path":"https://gillescolling.com/couplr/articles/comparison.html","id":"key-takeaways","dir":"Articles","previous_headings":"Real-World Case Study: Job Training Evaluation","what":"Key Takeaways","title":"Comparison with Alternatives","text":"Greedy matching handles 185:15,815 ratio efficiently Robust scaling handles skewed earnings distributions Balance diagnostics quantify improvement Large control pools actually help - options good matches comparison, optimal matching require full distance matrix computation (n × m entries), greedy matching finds excellent matches milliseconds. real CPS data (15,815 controls), efficiency becomes critical.","code":""},{"path":"https://gillescolling.com/couplr/articles/comparison.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"Comparison with Alternatives","text":"Ho, D. E., Imai, K., King, G., & Stuart, E. . (2011). MatchIt: Nonparametric preprocessing parametric causal inference. Journal Statistical Software, 42(8), 1-28. doi:10.18637/jss.v042.i08 Hansen, B. B., & Klopfer, S. O. (2006). Optimal full matching related designs via network flows. Journal Computational Graphical Statistics, 15(3), 609-627. doi:10.1198/106186006X137047 Zubizarreta, J. R., Kilcioglu, C., & Vielma, J. P. (2018). designmatch: Matched samples balanced representative design. R package. CRAN Sekhon, J. S. (2011). Multivariate propensity score matching software automated balance optimization: Matching package R. Journal Statistical Software, 42(7), 1-52. doi:10.18637/jss.v042.i07 LaLonde, R. J. (1986). Evaluating econometric evaluations training programs experimental data. American Economic Review, 76(4), 604-620.","code":""},{"path":"https://gillescolling.com/couplr/articles/comparison.html","id":"see-also","dir":"Articles","previous_headings":"","what":"See Also","title":"Comparison with Alternatives","text":"vignette(\"getting-started\") - Basic couplr usage vignette(\"matching-workflows\") - Production matching pipelines vignette(\"algorithms\") - LAP algorithm selection guide vignette(\"troubleshooting\") - Common issues solutions","code":""},{"path":"https://gillescolling.com/couplr/articles/getting-started.html","id":"what-couplr-does","dir":"Articles","previous_headings":"","what":"What couplr Does","title":"Quick Start","text":"couplr creates matched pairs two groups observations. Given “left” group (e.g., treatment) “right” group (e.g., control), finds best one--one pairing based similarity across variables specify. Common use cases: Matching treated patients similar controls observational studies Pairing survey respondents comparison Creating balanced samples causal inference","code":""},{"path":"https://gillescolling.com/couplr/articles/getting-started.html","id":"documentation-roadmap","dir":"Articles","previous_headings":"What couplr Does","what":"Documentation Roadmap","title":"Quick Start","text":"Start , proceed whichever vignette matches use case.","code":""},{"path":"https://gillescolling.com/couplr/articles/getting-started.html","id":"your-first-match","dir":"Articles","previous_headings":"","what":"Your First Match","title":"Quick Start","text":"simplest workflow uses match_couples(): happened: couplr calculated similar treatment unit control unit found optimal one--one pairing minimizes total distance treatment unit gets matched exactly one control unit","code":"library(couplr) library(dplyr)  # Create example data: treatment and control groups set.seed(123) treatment <- tibble(   id = 1:50,   age = rnorm(50, mean = 45, sd = 10),   income = rnorm(50, mean = 55000, sd = 12000) )  control <- tibble(   id = 1:80,   age = rnorm(80, mean = 50, sd = 12),   income = rnorm(80, mean = 48000, sd = 15000) )  # Match on age and income result <- match_couples(   left = treatment,   right = control,   vars = c(\"age\", \"income\"),   auto_scale = TRUE ) #> Auto-selected scaling method: standardize  # View matched pairs head(result$pairs) #> # A tibble: 6 × 5 #>   left_id right_id distance .age_diff .income_diff #>   <chr>   <chr>       <dbl>     <dbl>        <dbl> #> 1 1       46          0.779    -4.23        9144.  #> 2 2       11          0.257    -0.398       3441.  #> 3 3       52          0.594     1.36        7840.  #> 4 4       66          0.809    -7.87       -5112.  #> 5 5       65          0.530     1.30        6977.  #> 6 6       36          0.130    -1.43          62.2"},{"path":"https://gillescolling.com/couplr/articles/getting-started.html","id":"understanding-the-output","dir":"Articles","previous_headings":"Your First Match","what":"Understanding the Output","title":"Quick Start","text":"result$pairs table contains: left_id: Row number treatment group right_id: Row number control group distance: different matched units (lower = similar)","code":"# Quick overview with summary() summary(result) #> Matching Result Summary #> ======================= #>  #> Method: lap #> Pairs matched: 50  #> Unmatched: 0 left, 30 right #>  #> Distance Statistics: #>   Total: 19.6423  #>   Mean: 0.3928  #>   Min: 0.0615  #>   Q1: 0.1845  #>   Median: 0.2967  #>   Q3: 0.5039  #>   Max: 1.2184  #>   SD: 0.2863  # Or access specific info result$info$n_matched #> [1] 50"},{"path":"https://gillescolling.com/couplr/articles/getting-started.html","id":"why-scaling-matters","dir":"Articles","previous_headings":"","what":"Why Scaling Matters","title":"Quick Start","text":"Without scaling, variables larger values dominate matching. Income (measured thousands) overwhelm age (measured decades): Rule thumb: Always use auto_scale = TRUE unless specific reason .","code":"# BAD: Without scaling, income dominates result_unscaled <- match_couples(   treatment, control,   vars = c(\"age\", \"income\"),   auto_scale = FALSE )  # GOOD: With scaling, both variables contribute equally result_scaled <- match_couples(   treatment, control,   vars = c(\"age\", \"income\"),   auto_scale = TRUE ) #> Auto-selected scaling method: standardize  # Compare mean distances cat(\"Unscaled mean distance:\", round(mean(result_unscaled$pairs$distance), 1), \"\\n\") #> Unscaled mean distance: 2769.1 cat(\"Scaled mean distance:\", round(mean(result_scaled$pairs$distance), 3), \"\\n\") #> Scaled mean distance: 0.393"},{"path":"https://gillescolling.com/couplr/articles/getting-started.html","id":"checking-match-quality","dir":"Articles","previous_headings":"","what":"Checking Match Quality","title":"Quick Start","text":"matching, verify treatment control groups now balanced: formal balance assessment, use balance_diagnostics() (covered Matching Workflows).","code":"# Get the matched observations matched_treatment <- treatment[result$pairs$left_id, ] matched_control <- control[result$pairs$right_id, ]  # Compare means before and after matching cat(\"BEFORE matching:\\n\") #> BEFORE matching: cat(\"  Age difference:\", round(mean(treatment$age) - mean(control$age), 1), \"years\\n\") #>   Age difference: -3.4 years cat(\"  Income difference: $\", round(mean(treatment$income) - mean(control$income), 0), \"\\n\\n\") #>   Income difference: $ 9266  cat(\"AFTER matching:\\n\") #> AFTER matching: cat(\"  Age difference:\", round(mean(matched_treatment$age) - mean(matched_control$age), 1), \"years\\n\") #>   Age difference: -1.3 years cat(\"  Income difference: $\", round(mean(matched_treatment$income) - mean(matched_control$income), 0), \"\\n\") #>   Income difference: $ 2667"},{"path":"https://gillescolling.com/couplr/articles/getting-started.html","id":"visualizing-match-quality","dir":"Articles","previous_headings":"Checking Match Quality","what":"Visualizing Match Quality","title":"Quick Start","text":"Use plot() see distribution match distances:  histogram shows similar matched pairs . distribution concentrated near zero indicates good matches.","code":"plot(result)"},{"path":"https://gillescolling.com/couplr/articles/getting-started.html","id":"large-datasets-use-greedy-matching","dir":"Articles","previous_headings":"","what":"Large Datasets: Use Greedy Matching","title":"Quick Start","text":"datasets larger thousand observations, optimal matching becomes slow. Use greedy_couples() instead; ’s 10-100x faster nearly identical results: use :","code":"# Create larger datasets set.seed(456) large_treatment <- tibble(   id = 1:2000,   age = rnorm(2000, 45, 10),   income = rnorm(2000, 55000, 12000) )  large_control <- tibble(   id = 1:3000,   age = rnorm(3000, 50, 12),   income = rnorm(3000, 48000, 15000) )  # Fast greedy matching result_greedy <- greedy_couples(   large_treatment, large_control,   vars = c(\"age\", \"income\"),   auto_scale = TRUE,   strategy = \"row_best\"  # fastest strategy ) #> Auto-selected scaling method: standardize  cat(\"Matched\", result_greedy$info$n_matched, \"pairs\\n\") #> Matched 2000 pairs cat(\"Mean distance:\", round(mean(result_greedy$pairs$distance), 3), \"\\n\") #> Mean distance: 0.201"},{"path":"https://gillescolling.com/couplr/articles/getting-started.html","id":"setting-a-maximum-distance-caliper","dir":"Articles","previous_headings":"","what":"Setting a Maximum Distance (Caliper)","title":"Quick Start","text":"Sometimes want reject poor matches rather force bad pairings. Use max_distance set caliper: Stricter calipers mean fewer better matches.","code":"# Allow any match result_loose <- match_couples(   treatment, control,   vars = c(\"age\", \"income\"),   auto_scale = TRUE ) #> Auto-selected scaling method: standardize  # Only allow close matches result_strict <- match_couples(   treatment, control,   vars = c(\"age\", \"income\"),   auto_scale = TRUE,   max_distance = 0.5  # reject pairs more different than this ) #> Auto-selected scaling method: standardize  cat(\"Without caliper:\", result_loose$info$n_matched, \"pairs\\n\") #> Without caliper: 50 pairs cat(\"With caliper:\", result_strict$info$n_matched, \"pairs\\n\") #> With caliper: 40 pairs"},{"path":"https://gillescolling.com/couplr/articles/getting-started.html","id":"matching-within-groups-blocking","dir":"Articles","previous_headings":"","what":"Matching Within Groups (Blocking)","title":"Quick Start","text":"natural groups data (e.g., hospitals, regions, study sites), can match within group separately. ensures exact balance grouping variable. First, create blocks matchmaker(), pass result match_couples(): Blocking guarantees Hospital patients matched Hospital controls, etc.","code":"# Data from multiple hospital sites set.seed(321) treated <- tibble(   id = 1:60,   site = rep(c(\"Hospital A\", \"Hospital B\", \"Hospital C\"), each = 20),   age = rnorm(60, 55, 10),   severity = rnorm(60, 5, 2) )  controls <- tibble(   id = 1:90,   site = rep(c(\"Hospital A\", \"Hospital B\", \"Hospital C\"), each = 30),   age = rnorm(90, 52, 12),   severity = rnorm(90, 4.5, 2.5) )  # Step 1: Create blocks by hospital site blocks <- matchmaker(   left = treated,   right = controls,   block_type = \"group\",   block_by = \"site\" )  # Step 2: Match within each block result_blocked <- match_couples(   left = blocks$left,   right = blocks$right,   vars = c(\"age\", \"severity\"),   block_id = \"block_id\",   auto_scale = TRUE ) #> Auto-selected scaling method: standardize  # Verify: matches stay within their block result_blocked$pairs |> count(block_id) #> # A tibble: 3 × 2 #>   block_id       n #>   <chr>      <int> #> 1 Hospital A    20 #> 2 Hospital B    20 #> 3 Hospital C    20"},{"path":"https://gillescolling.com/couplr/articles/getting-started.html","id":"complete-example","dir":"Articles","previous_headings":"","what":"Complete Example","title":"Quick Start","text":"’s realistic workflow start finish:","code":"# 1. Prepare your data set.seed(789) patients_treated <- tibble(   patient_id = paste0(\"T\", 1:100),   age = rnorm(100, 62, 8),   bmi = rnorm(100, 28, 4),   smoker = sample(0:1, 100, replace = TRUE, prob = c(0.6, 0.4)) )  patients_control <- tibble(   patient_id = paste0(\"C\", 1:200),   age = rnorm(200, 58, 10),   bmi = rnorm(200, 26, 5),   smoker = sample(0:1, 200, replace = TRUE, prob = c(0.7, 0.3)) )  # 2. Match on clinical variables matched <- match_couples(   left = patients_treated,   right = patients_control,   vars = c(\"age\", \"bmi\", \"smoker\"),   auto_scale = TRUE ) #> Auto-selected scaling method: standardize  # 3. Check how many matched cat(\"Treated patients:\", nrow(patients_treated), \"\\n\") #> Treated patients: 100 cat(\"Successfully matched:\", matched$info$n_matched, \"\\n\") #> Successfully matched: 100 cat(\"Match rate:\", round(100 * matched$info$n_matched / nrow(patients_treated), 1), \"%\\n\") #> Match rate: 100 %  # 4. Extract matched samples for analysis treated_matched <- patients_treated[matched$pairs$left_id, ] control_matched <- patients_control[matched$pairs$right_id, ]  # 5. Verify balance cat(\"\\nBalance check (difference in means):\\n\") #>  #> Balance check (difference in means): cat(\"  Age:\", round(mean(treated_matched$age) - mean(control_matched$age), 2), \"\\n\") #>   Age: NA cat(\"  BMI:\", round(mean(treated_matched$bmi) - mean(control_matched$bmi), 2), \"\\n\") #>   BMI: NA cat(\"  Smoker %:\", round(100*(mean(treated_matched$smoker) - mean(control_matched$smoker)), 1), \"\\n\") #>   Smoker %: NA"},{"path":"https://gillescolling.com/couplr/articles/getting-started.html","id":"next-steps","dir":"Articles","previous_headings":"","what":"Next Steps","title":"Quick Start","text":"now know basics matching couplr. ’s go next: production research workflows: Matching Workflows covers preprocessing, blocking, formal balance diagnostics, publication-ready output understanding algorithm choices: Algorithms explains different solvers faster appropriate comparing packages: Comparison shows couplr differs MatchIt, optmatch, designmatch","code":""},{"path":"https://gillescolling.com/couplr/articles/getting-started.html","id":"additional-direct-assignment-problem-solving","dir":"Articles","previous_headings":"","what":"Additional: Direct Assignment Problem Solving","title":"Quick Start","text":"need solve assignment problems directly (matching workflows), couplr also provides lower-level functions.","code":""},{"path":"https://gillescolling.com/couplr/articles/getting-started.html","id":"lap_solve-matrix-based-assignment","dir":"Articles","previous_headings":"Additional: Direct Assignment Problem Solving","what":"lap_solve(): Matrix-Based Assignment","title":"Quick Start","text":"Given cost matrix entry (,j) cost assigning row column j: Row 1 assigned column 2 (cost 2), row 2 column 1 (cost 3), row 3 column 3 (cost 4). Total cost: 9.","code":"# Cost matrix: 3 workers x 3 tasks cost <- matrix(c(   4, 2, 5,   3, 3, 6,   7, 5, 4 ), nrow = 3, byrow = TRUE)  result <- lap_solve(cost) print(result) #> Assignment Result #> ================= #>  #> # A tibble: 3 × 3 #>   source target  cost #>    <int>  <int> <dbl> #> 1      1      2     2 #> 2      2      1     3 #> 3      3      3     4 #>  #> Total cost: 9  #> Method: bruteforce"},{"path":"https://gillescolling.com/couplr/articles/getting-started.html","id":"forbidden-assignments","dir":"Articles","previous_headings":"Additional: Direct Assignment Problem Solving","what":"Forbidden Assignments","title":"Quick Start","text":"Use NA Inf impossible assignments:","code":"cost_forbidden <- matrix(c(   4, 2, NA,   # Row 1 cannot go to column 3   Inf, 3, 6,  # Row 2 cannot go to column 1   7, 5, 4 ), nrow = 3, byrow = TRUE)  lap_solve(cost_forbidden) #> Assignment Result #> ================= #>  #> # A tibble: 3 × 3 #>   source target  cost #>    <int>  <int> <dbl> #> 1      1      1     4 #> 2      2      2     3 #> 3      3      3     4 #>  #> Total cost: 11  #> Method: bruteforce"},{"path":"https://gillescolling.com/couplr/articles/getting-started.html","id":"maximization","dir":"Articles","previous_headings":"Additional: Direct Assignment Problem Solving","what":"Maximization","title":"Quick Start","text":"preference profit maximization:","code":"preferences <- matrix(c(   8, 5, 3,   4, 7, 6,   2, 4, 9 ), nrow = 3, byrow = TRUE)  lap_solve(preferences, maximize = TRUE) #> Assignment Result #> ================= #>  #> # A tibble: 3 × 3 #>   source target  cost #>    <int>  <int> <dbl> #> 1      1      1     8 #> 2      2      2     7 #> 3      3      3     9 #>  #> Total cost: 24  #> Method: bruteforce"},{"path":"https://gillescolling.com/couplr/articles/getting-started.html","id":"grouped-data","dir":"Articles","previous_headings":"Additional: Direct Assignment Problem Solving","what":"Grouped Data","title":"Quick Start","text":"Solve multiple assignment problems using grouped data frames: solves day’s assignment problem independently returns results one tidy table.","code":"# Weekly nurse-shift scheduling: solve each day separately schedule <- tibble(   day = rep(c(\"Mon\", \"Tue\", \"Wed\"), each = 9),   nurse = rep(rep(1:3, each = 3), 3),   shift = rep(1:3, 9),   cost = c(4,2,5, 3,3,6, 7,5,4,   # Monday costs            5,3,4, 2,4,5, 6,4,3,   # Tuesday costs            3,4,5, 4,2,6, 5,5,4)   # Wednesday costs )  # Solve all three days at once schedule |>   group_by(day) |>   lap_solve(nurse, shift, cost) #> # A tibble: 9 × 4 #>   day   source target  cost #>   <chr>  <int>  <int> <dbl> #> 1 Mon        1      2     2 #> 2 Mon        2      1     3 #> 3 Mon        3      3     4 #> 4 Tue        1      2     3 #> 5 Tue        2      1     2 #> 6 Tue        3      3     3 #> 7 Wed        1      1     3 #> 8 Wed        2      2     2 #> 9 Wed        3      3     4"},{"path":"https://gillescolling.com/couplr/articles/getting-started.html","id":"k-best-solutions","dir":"Articles","previous_headings":"Additional: Direct Assignment Problem Solving","what":"K-Best Solutions","title":"Quick Start","text":"Find multiple near-optimal solutions:","code":"cost <- matrix(c(1, 2, 3, 4, 3, 2, 5, 4, 1), nrow = 3, byrow = TRUE)  kbest <- lap_solve_kbest(cost, k = 3) print(kbest) #> K-Best Assignment Results #> ========================= #>  #> Number of solutions: 3  #>  #> Solution costs: #>   Rank 1: 5.0000 #>   Rank 2: 7.0000 #>   Rank 3: 7.0000 #>  #> Assignments: #> # A tibble: 9 × 6 #>    rank solution_id source target  cost total_cost #>   <int>       <int>  <int>  <int> <dbl>      <dbl> #> 1     1           1      1      1     1          5 #> 2     1           1      2      2     3          5 #> 3     1           1      3      3     1          5 #> 4     2           2      1      2     2          7 #> 5     2           2      2      1     4          7 #> 6     2           2      3      3     1          7 #> 7     3           3      1      1     1          7 #> 8     3           3      2      3     2          7 #> 9     3           3      3      2     4          7"},{"path":"https://gillescolling.com/couplr/articles/getting-started.html","id":"see-also","dir":"Articles","previous_headings":"","what":"See Also","title":"Quick Start","text":"?match_couples - Optimal matching function reference ?greedy_couples - Fast approximate matching ?balance_diagnostics - Formal balance assessment ?lap_solve - Direct assignment problem solving","code":""},{"path":"https://gillescolling.com/couplr/articles/matching-workflows.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"Matching Workflows","text":"Matching fundamental technique creating comparable groups observational studies. Unlike random assignment, observational data often contain systematic differences treatment control groups confound causal inference. Matching addresses pairing similar units based observed characteristics, creating “apples--apples” comparisons. vignette follows complete workflow raw data publication-ready results, using realistic job training evaluation running example. ’ll learn handle full pipeline: preprocessing, matching, assessment, reporting.","code":""},{"path":"https://gillescolling.com/couplr/articles/matching-workflows.html","id":"who-this-vignette-is-for","dir":"Articles","previous_headings":"Overview","what":"Who This Vignette Is For","title":"Matching Workflows","text":"Audience: Researchers, epidemiologists, economists, data scientists working observational data Prerequisites: Familiarity basic couplr usage (vignette(\"getting-started\")) Understanding causal inference concepts (treatment effects, confounding) Basic statistics (means, standard deviations, t-tests) ’ll Learn: match treatment control units match_couples() Automatic preprocessing: scaling, health checks, categorical encoding Assessing match quality balance_diagnostics() use optimal vs greedy matching Creating publication-ready balance tables Time complete: 30-45 minutes","code":""},{"path":"https://gillescolling.com/couplr/articles/matching-workflows.html","id":"documentation-roadmap","dir":"Articles","previous_headings":"Overview","what":"Documentation Roadmap","title":"Matching Workflows","text":": Matching Workflows","code":""},{"path":"https://gillescolling.com/couplr/articles/matching-workflows.html","id":"the-running-example-job-training-evaluation","dir":"Articles","previous_headings":"Overview","what":"The Running Example: Job Training Evaluation","title":"Matching Workflows","text":"Throughout vignette, evaluate job training program’s effect earnings. challenge: participants self-selected program, differ systematically non-participants age, education, prior earnings. Without matching, earnings difference due baseline differences rather program . goal: Create comparable treatment control groups, assess balance quality, estimate treatment effect credibly.","code":""},{"path":"https://gillescolling.com/couplr/articles/matching-workflows.html","id":"key-features","dir":"Articles","previous_headings":"Overview","what":"Key Features","title":"Matching Workflows","text":"Automatic preprocessing health checks smart scaling Optimal matching via linear assignment algorithms Fast greedy matching large datasets (n > 5,000) Blocking stratification support Comprehensive balance diagnostics Publication-ready output tables","code":""},{"path":[]},{"path":"https://gillescolling.com/couplr/articles/matching-workflows.html","id":"the-matching-problem","dir":"Articles","previous_headings":"Problem Definition","what":"The Matching Problem","title":"Matching Workflows","text":"Given two groups units: Left group (treatment, exposed, cases): nLn_L units Right group (control, unexposed, controls): nRn_R units unit ii covariate vector 𝐱∈ℝp\\mathbf{x}_i \\\\mathbb{R}^p describing characteristics want balance (age, income, education, etc.). Goal: Find one--one matches minimize total distance: minπ∑=1nd(𝐱iL,𝐱π()R) \\min_{\\pi} \\sum_{=1}^{n} d(\\mathbf{x}_i^L, \\mathbf{x}_{\\pi()}^R) d(⋅,⋅)d(\\cdot, \\cdot) distance function (typically Euclidean Mahalanobis) π\\pi matching assignment.","code":""},{"path":"https://gillescolling.com/couplr/articles/matching-workflows.html","id":"why-matching-matters","dir":"Articles","previous_headings":"Problem Definition","what":"Why Matching Matters","title":"Matching Workflows","text":"Without matching: Groups may differ systematically important covariates Treatment effect estimates confounded differences Statistical adjustments (regression) rely untestable assumptions matching: Create comparable groups differ primarily treatment status Balance covariates reduce confounding Improve causal inference mimicking randomized experiments Transparent, non-parametric preprocessing step","code":""},{"path":"https://gillescolling.com/couplr/articles/matching-workflows.html","id":"distance-metrics","dir":"Articles","previous_headings":"Problem Definition","what":"Distance Metrics","title":"Matching Workflows","text":"quality matching depends distance metric: Euclidean distance (scaling): d(𝐱,𝐱j)=∑k=1p(xik−xjk)2 d(\\mathbf{x}_i, \\mathbf{x}_j) = \\sqrt{\\sum_{k=1}^{p} (x_{ik} - x_{jk})^2} Mahalanobis distance (accounts correlations): d(𝐱,𝐱j)=(𝐱−𝐱j)⊤Σ−1(𝐱−𝐱j) d(\\mathbf{x}_i, \\mathbf{x}_j) = \\sqrt{(\\mathbf{x}_i - \\mathbf{x}_j)^\\top \\Sigma^{-1} (\\mathbf{x}_i - \\mathbf{x}_j)} Propensity score distance (single dimension): d(,j)=|pi−pj| d(, j) = |p_i - p_j| pi=P(treatment∣𝐱)p_i = P(\\text{treatment} \\mid \\mathbf{x}_i) propensity score. couplr defaults Euclidean distance automatic scaling, works well applications.","code":""},{"path":[]},{"path":"https://gillescolling.com/couplr/articles/matching-workflows.html","id":"creating-a-matched-sample","dir":"Articles","previous_headings":"Basic Usage","what":"Creating a Matched Sample","title":"Matching Workflows","text":"simplest workflow uses match_couples() automatic preprocessing: result contains: pairs: Matched pairs IDs distances info: Matching method, counts, total distance left_unmatched, right_unmatched: Units without matches cost_matrix: Full distance matrix (return_diagnostics = TRUE)","code":"# Simulate observational data set.seed(123) n_left <- 100 n_right <- 150  # Treatment group (tends to be younger, higher income) left_data <- tibble(   id = 1:n_left,   age = rnorm(n_left, mean = 45, sd = 10),   income = rnorm(n_left, mean = 60000, sd = 15000),   education = sample(c(\"HS\", \"BA\", \"MA\"), n_left, replace = TRUE),   group = \"treatment\" )  # Control group (older, lower income on average) right_data <- tibble(   id = 1:n_right,   age = rnorm(n_right, mean = 52, sd = 12),   income = rnorm(n_right, mean = 50000, sd = 18000),   education = sample(c(\"HS\", \"BA\", \"MA\"), n_right, replace = TRUE),   group = \"control\" )  # Perform optimal matching result <- match_couples(   left = left_data,   right = right_data,   vars = c(\"age\", \"income\"),   auto_scale = TRUE,   return_diagnostics = TRUE ) #> Auto-selected scaling method: standardize  # View matched pairs head(result$pairs) #> # A tibble: 6 × 5 #>   left_id right_id distance .age_diff .income_diff #>   <chr>   <chr>       <dbl>     <dbl>        <dbl> #> 1 1       27         0.530   -5.68           2942. #> 2 2       37         0.299    3.33            980. #> 3 3       15         0.0382  -0.251          -512. #> 4 4       11         0.691   -7.19           4587. #> 5 5       73         0.425   -4.48           2583. #> 6 6       131        0.133    0.00187       -2186.  # Summary statistics result$info #> $solver #> [1] \"auction_scaled\" #>  #> $n_matched #> [1] 100 #>  #> $total_distance #> [1] 33.77392 #>  #> $method #> [1] \"lap\" #>  #> $distance_metric #> [1] \"euclidean\" #>  #> $scaled #> [1] TRUE #>  #> $n_left #> [1] 100 #>  #> $n_right #> [1] 150"},{"path":"https://gillescolling.com/couplr/articles/matching-workflows.html","id":"understanding-the-output","dir":"Articles","previous_headings":"Basic Usage","what":"Understanding the Output","title":"Matching Workflows","text":"Interpretation: Lower distances indicate better matches (similar units) Median distance provides typical match quality Large distances suggest poor matches (consider caliper constraints)","code":"# How many matched? cat(\"Matched pairs:\", result$info$n_matched, \"\\n\") #> Matched pairs: 100 cat(\"Unmatched left:\", nrow(result$left_unmatched), \"\\n\") #> Unmatched left: cat(\"Unmatched right:\", nrow(result$right_unmatched), \"\\n\") #> Unmatched right:  # Distribution of match distances summary(result$pairs$distance) #>     Min.  1st Qu.   Median     Mean  3rd Qu.     Max.  #> 0.002044 0.139855 0.249548 0.337739 0.466174 1.939711  # Visualize match quality ggplot(result$pairs, aes(x = distance)) +   geom_histogram(bins = 30, fill = \"#29abe0\", alpha = 0.7) +   labs(     title = \"Distribution of Match Distances\",     x = \"Euclidean Distance (scaled)\",     y = \"Count\"   ) +   theme_minimal() +   theme(plot.background = element_rect(fill = \"transparent\", color = NA),         panel.background = element_rect(fill = \"transparent\", color = NA),         panel.grid = element_blank())"},{"path":[]},{"path":"https://gillescolling.com/couplr/articles/matching-workflows.html","id":"why-preprocessing-matters","dir":"Articles","previous_headings":"Automatic Preprocessing","what":"Why Preprocessing Matters","title":"Matching Workflows","text":"Raw covariates often : Different scales: Age years (20-80), income dollars (20,000-200,000) Different units: Continuous (age), categorical (education), binary (smoker) Data quality issues: Missing values, constant variables, extreme outliers Without preprocessing, high-variance variables dominate distance calculations.","code":""},{"path":"https://gillescolling.com/couplr/articles/matching-workflows.html","id":"smart-scaling-with-auto_scale-true","dir":"Articles","previous_headings":"Automatic Preprocessing","what":"Smart Scaling with auto_scale = TRUE","title":"Matching Workflows","text":"auto_scale = TRUE, match_couples() automatically: Detects problematic variables Constant variables (SD = 0) -> excluded warning High missingness (>50%) -> warned Extreme skewness (|skew| > 2) -> informed Applies appropriate scaling Continuous variables -> scaled selected method Binary variables (0/1) -> used -Categorical -> converted numeric ordered Handles categorical variables Unordered factors -> converted binary indicators Ordered factors -> converted numeric ranks","code":"# Create data with scaling challenges set.seed(456) challenging_data <- tibble(   id = 1:50,   age = rnorm(50, 50, 10),                    # Years (reasonable scale)   income = rnorm(50, 60000, 20000),           # Dollars (large scale)   bmi = rnorm(50, 25, 5),                     # Ratio (small scale)   smoker = sample(0:1, 50, replace = TRUE),   # Binary   education = factor(     sample(c(\"HS\", \"BA\", \"MA\", \"PhD\"), 50, replace = TRUE),     ordered = TRUE,     levels = c(\"HS\", \"BA\", \"MA\", \"PhD\")   ) )  left_chal <- challenging_data[1:25, ] right_chal <- challenging_data[26:50, ]  # Match WITHOUT auto-scaling (income dominates) result_no_scale <- match_couples(   left_chal, right_chal,   vars = c(\"age\", \"income\", \"bmi\"),   auto_scale = FALSE )  # Match WITH auto-scaling (all variables contribute) result_scaled <- match_couples(   left_chal, right_chal,   vars = c(\"age\", \"income\", \"bmi\"),   auto_scale = TRUE,   scale = \"robust\"  # Median/MAD scaling (robust to outliers) )  # Compare match quality cat(\"Without scaling - mean distance:\", mean(result_no_scale$pairs$distance), \"\\n\") #> Without scaling - mean distance: 3572.096 cat(\"With scaling - mean distance:\", mean(result_scaled$pairs$distance), \"\\n\") #> With scaling - mean distance: 0.9784372"},{"path":"https://gillescolling.com/couplr/articles/matching-workflows.html","id":"scaling-methods","dir":"Articles","previous_headings":"Automatic Preprocessing","what":"Scaling Methods","title":"Matching Workflows","text":"Three scaling strategies available via scale parameter: 1. Robust scaling (scale = \"robust\", default): xscaled=x−median(x)MAD(x) x_{\\text{scaled}} = \\frac{x - \\text{median}(x)}{\\text{MAD}(x)} Uses median median absolute deviation (MAD) Resistant outliers skewness Best : Real-world data potential outliers 2. Standardization (scale = \"standardize\"): xscaled=x−mean(x)SD(x) x_{\\text{scaled}} = \\frac{x - \\text{mean}(x)}{\\text{SD}(x)} Classical z-score normalization Assumes approximate normality Best : Clean, normally-distributed data 3. Range scaling (scale = \"range\"): xscaled=x−min⁡(x)max⁡(x)−min⁡(x) x_{\\text{scaled}} = \\frac{x - \\min(x)}{\\max(x) - \\min(x)} Scales [0, 1] range Preserves exact relationships Best : Bounded variables, visualization","code":"# Demonstrate scaling methods demo_var <- c(10, 20, 25, 30, 100)  # Contains outlier (100)  # Function to show scaling show_scaling <- function(x, method) {   left_demo <- tibble(id = 1:3, var = x[1:3])   right_demo <- tibble(id = 1:2, var = x[4:5])    result <- match_couples(     left_demo, right_demo,     vars = \"var\",     auto_scale = TRUE,     scale = method,     return_diagnostics = TRUE   )    # Extract scaled values from cost matrix   cat(method, \"scaling:\\n\")   cat(\"  Original:\", x, \"\\n\")   cat(\"  Distance matrix diagonal:\", diag(result$cost_matrix)[1:2], \"\\n\\n\") }  show_scaling(demo_var, \"robust\") #> robust scaling: #>   Original: 10 20 25 30 100  #>   Distance matrix diagonal: NA NA show_scaling(demo_var, \"standardize\") #> standardize scaling: #>   Original: 10 20 25 30 100  #>   Distance matrix diagonal: NA NA show_scaling(demo_var, \"range\") #> range scaling: #>   Original: 10 20 25 30 100  #>   Distance matrix diagonal: NA NA"},{"path":"https://gillescolling.com/couplr/articles/matching-workflows.html","id":"health-checks-and-warnings","dir":"Articles","previous_headings":"Automatic Preprocessing","what":"Health Checks and Warnings","title":"Matching Workflows","text":"preprocessing system provides informative diagnostics:","code":"# Create data with issues problematic_data <- tibble(   id = 1:100,   age = rnorm(100, 50, 10),   constant_var = 5,                           # No variation - will warn   mostly_missing = c(rnorm(20, 50, 10), rep(NA, 80)),  # >50% missing   extreme_skew = rexp(100, rate = 0.1)       # Very skewed )  # Attempt matching - will show warnings result <- match_couples(   problematic_data[1:50, ],   problematic_data[51:100, ],   vars = c(\"age\", \"constant_var\", \"mostly_missing\", \"extreme_skew\"),   auto_scale = TRUE )  # Warning messages will indicate: # - \"constant_var excluded (SD = 0)\" # - \"mostly_missing has 80% missing values\" # - \"extreme_skew has high skewness (3.2)\""},{"path":"https://gillescolling.com/couplr/articles/matching-workflows.html","id":"optimal-vs-greedy-matching","dir":"Articles","previous_headings":"","what":"Optimal vs Greedy Matching","title":"Matching Workflows","text":"large datasets (n > 5,000), optimal matching becomes computationally expensive. couplr provides fast greedy alternatives.","code":""},{"path":"https://gillescolling.com/couplr/articles/matching-workflows.html","id":"when-to-use-each-approach","dir":"Articles","previous_headings":"Optimal vs Greedy Matching","what":"When to Use Each Approach","title":"Matching Workflows","text":"Optimal matching (method = \"optimal\"): Minimizes total distance (globally optimal solution) Uses linear assignment algorithms (O(n3)O(n^3) complexity) Suitable : n < 5,000, optimality critical Typical runtime: <1 second n=1,000, ~10 seconds n=3,000 Greedy matching (method = \"greedy\"): Fast approximation (10-100x faster) Three strategies: sorted, row_best, pq Suitable : n > 5,000, exploratory analysis, speed matters Typical runtime: <1 second n=10,000","code":"# Create moderately large dataset set.seed(789) n <- 1000 large_left <- tibble(   id = 1:n,   x1 = rnorm(n),   x2 = rnorm(n),   x3 = rnorm(n) ) large_right <- tibble(   id = 1:n,   x1 = rnorm(n),   x2 = rnorm(n),   x3 = rnorm(n) )  # Optimal matching time_optimal <- system.time({   result_optimal <- match_couples(     large_left, large_right,     vars = c(\"x1\", \"x2\", \"x3\"),     method = \"hungarian\"   ) })  # Greedy matching (row_best strategy) time_greedy <- system.time({   result_greedy <- greedy_couples(     large_left, large_right,     vars = c(\"x1\", \"x2\", \"x3\"),     strategy = \"row_best\"   ) })  # Compare cat(\"Optimal matching:\\n\") #> Optimal matching: cat(\"  Time:\", round(time_optimal[\"elapsed\"], 3), \"seconds\\n\") #>   Time: 96.42 seconds cat(\"  Mean distance:\", round(mean(result_optimal$pairs$distance), 4), \"\\n\\n\") #>   Mean distance: 0.3368  cat(\"Greedy matching:\\n\") #> Greedy matching: cat(\"  Time:\", round(time_greedy[\"elapsed\"], 3), \"seconds\\n\") #>   Time: 0.94 seconds cat(\"  Mean distance:\", round(mean(result_greedy$pairs$distance), 4), \"\\n\") #>   Mean distance: 0.4667 cat(\"  Speedup:\", round(time_optimal[\"elapsed\"] / time_greedy[\"elapsed\"], 1), \"x\\n\") #>   Speedup: 102.6 x"},{"path":"https://gillescolling.com/couplr/articles/matching-workflows.html","id":"greedy-strategies","dir":"Articles","previous_headings":"Optimal vs Greedy Matching","what":"Greedy Strategies","title":"Matching Workflows","text":"Three greedy strategies available via greedy_couples(): 1. Sorted (strategy = \"sorted\"): Sort possible pairs distance Assign greedily best worst Best quality among greedy methods Slowest greedy option (still much faster optimal) 2. Row-best (strategy = \"row_best\", default): left unit, find best available right unit Process left units order Fast simple Medium quality 3. Priority queue (strategy = \"pq\"): Maintains priority queue potential matches Updates dynamically assignments made Best large problems Fastest option Recommendation: Default strategy = \"row_best\" good speed/quality balance Use strategy = \"sorted\" quality important optimal slow Use strategy = \"pq\" n > 10,000","code":"Algorithm: 1. Compute all n_L × n_R distances  2. Sort pairs by distance (ascending)  3. For each pair in sorted order:     - If both units unmatched, assign them  4. Stop when no more matches possible Algorithm: 1. For i = 1 to n_L:     - Find unmatched right unit j with minimum distance to i     - Assign (i, j)  2. Return all assignments # Compare greedy strategies on same data set.seed(101) test_left <- tibble(id = 1:200, x = rnorm(200)) test_right <- tibble(id = 1:200, x = rnorm(200))  strategies <- c(\"sorted\", \"row_best\", \"pq\") results <- list()  for (strat in strategies) {   time <- system.time({     result <- greedy_couples(       test_left, test_right,       vars = \"x\",       strategy = strat     )   })    results[[strat]] <- list(     time = time[\"elapsed\"],     mean_dist = mean(result$pairs$distance),     total_dist = result$info$total_distance   ) }  # Display comparison comparison <- do.call(rbind, lapply(names(results), function(s) {   data.frame(     strategy = s,     time_sec = round(results[[s]]$time, 4),     mean_distance = round(results[[s]]$mean_dist, 4),     total_distance = round(results[[s]]$total_dist, 2)   ) }))  print(comparison) #>          strategy time_sec mean_distance total_distance #> elapsed    sorted     0.03        0.0912          18.24 #> elapsed1 row_best     0.05        0.0968          19.36 #> elapsed2       pq     0.10        0.0912          18.24"},{"path":"https://gillescolling.com/couplr/articles/matching-workflows.html","id":"caliper-constraints","dir":"Articles","previous_headings":"","what":"Caliper Constraints","title":"Matching Workflows","text":"Calipers impose maximum allowable match distances ensure minimum quality.","code":""},{"path":"https://gillescolling.com/couplr/articles/matching-workflows.html","id":"why-use-calipers","dir":"Articles","previous_headings":"Caliper Constraints","what":"Why Use Calipers","title":"Matching Workflows","text":"Without calipers, optimal matching may pair dissimilar units just maximize number matches. Calipers prevent : Setting distance threshold beyond matches forbidden Reducing number matches improve average quality Implementing “common support” requirement propensity score matching","code":"# Create data where some units are far apart set.seed(202) left_cal <- tibble(   id = 1:50,   x = c(rnorm(40, mean = 0, sd = 1), rnorm(10, mean = 5, sd = 0.5))  # Some outliers ) right_cal <- tibble(   id = 1:50,   x = rnorm(50, mean = 0, sd = 1) )  # Match without caliper - pairs everything result_no_cal <- match_couples(   left_cal, right_cal,   vars = \"x\",   auto_scale = FALSE )  # Match with caliper - excludes poor matches result_with_cal <- match_couples(   left_cal, right_cal,   vars = \"x\",   max_distance = 1.5,  # Caliper: max distance = 1.5   auto_scale = FALSE )  cat(\"Without caliper:\\n\") #> Without caliper: cat(\"  Matched:\", result_no_cal$info$n_matched, \"\\n\") #>   Matched: 50 cat(\"  Mean distance:\", round(mean(result_no_cal$pairs$distance), 3), \"\\n\") #>   Mean distance: 1.129 cat(\"  Max distance:\", round(max(result_no_cal$pairs$distance), 3), \"\\n\\n\") #>   Max distance: 5.453  cat(\"With caliper (1.5):\\n\") #> With caliper (1.5): cat(\"  Matched:\", result_with_cal$info$n_matched, \"\\n\") #>   Matched: 40 cat(\"  Mean distance:\", round(mean(result_with_cal$pairs$distance), 3), \"\\n\") #>   Mean distance: 0.143 cat(\"  Max distance:\", round(max(result_with_cal$pairs$distance), 3), \"\\n\") #>   Max distance: 0.763  # Visualize caliper effect ggplot(result_no_cal$pairs, aes(x = distance)) +   geom_histogram(aes(fill = \"No caliper\"), bins = 30, alpha = 0.5) +   geom_histogram(     data = result_with_cal$pairs,     aes(fill = \"With caliper\"),     bins = 30,     alpha = 0.5   ) +   geom_vline(xintercept = 1.5, linetype = \"dashed\", color = \"red\") +   labs(     title = \"Caliper Effect on Match Distances\",     x = \"Distance\",     y = \"Count\",     fill = \"Condition\"   ) +   theme_minimal() +   theme(plot.background = element_rect(fill = \"transparent\", color = NA),         panel.background = element_rect(fill = \"transparent\", color = NA),         legend.background = element_rect(fill = \"transparent\", color = NA),         panel.grid = element_blank())"},{"path":"https://gillescolling.com/couplr/articles/matching-workflows.html","id":"choosing-caliper-width","dir":"Articles","previous_headings":"Caliper Constraints","what":"Choosing Caliper Width","title":"Matching Workflows","text":"Common approaches: 1. Standard deviation rule: Caliper = 0.1 0.25 pooled SD 2. Propensity score rule: 0.1 0.25 SD propensity score logit 3. Empirical rule: Examine distance distribution, exclude extreme tail","code":"# Calculate pooled SD combined <- bind_rows(   left_data %>% mutate(group = \"left\"),   right_data %>% mutate(group = \"right\") )  pooled_sd <- sd(combined$age)  # For single variable caliper_width <- 0.2 * pooled_sd  result <- match_couples(   left_data, right_data,   vars = \"age\",   max_distance = caliper_width ) # Fit all matches first all_matches <- match_couples(left_cal, right_cal, vars = \"x\")  # Choose caliper at 90th percentile caliper_90 <- quantile(all_matches$pairs$distance, 0.90)  # Refit with caliper refined_matches <- match_couples(   left_cal, right_cal,   vars = \"x\",   max_distance = caliper_90 )  cat(\"90th percentile caliper:\", round(caliper_90, 3), \"\\n\") #> 90th percentile caliper: 4.532 cat(\"Matches retained:\",     round(100 * refined_matches$info$n_matched / all_matches$info$n_matched, 1), \"%\\n\") #> Matches retained: 100 %"},{"path":"https://gillescolling.com/couplr/articles/matching-workflows.html","id":"blocking-and-stratification","dir":"Articles","previous_headings":"","what":"Blocking and Stratification","title":"Matching Workflows","text":"Blocking (exact matching key variables) combined distance matching remaining covariates powerful strategy.","code":""},{"path":"https://gillescolling.com/couplr/articles/matching-workflows.html","id":"why-use-blocking","dir":"Articles","previous_headings":"Blocking and Stratification","what":"Why Use Blocking","title":"Matching Workflows","text":"Benefits: Ensures exact balance critical variables (site, gender, age category) Reduces problem size (smaller within-block matching problems) Prevents poor cross-block matches Transparent interpretable use: Strong domain knowledge important stratification variables Variables absolutely must balanced (e.g., study site multi-center trials) Large datasets blocking reduces computational burden","code":""},{"path":"https://gillescolling.com/couplr/articles/matching-workflows.html","id":"exact-blocking-with-matchmaker","dir":"Articles","previous_headings":"Blocking and Stratification","what":"Exact Blocking with matchmaker()","title":"Matching Workflows","text":"","code":"# Create multi-site data set.seed(303) multi_site <- bind_rows(   tibble(     id = 1:100,     site = sample(c(\"A\", \"B\", \"C\"), 100, replace = TRUE),     age = rnorm(100, 50, 10),     income = rnorm(100, 55000, 15000),     group = \"treatment\"   ),   tibble(     id = 101:250,     site = sample(c(\"A\", \"B\", \"C\"), 150, replace = TRUE),     age = rnorm(150, 50, 10),     income = rnorm(150, 55000, 15000),     group = \"control\"   ) )  left_site <- multi_site %>% filter(group == \"treatment\") right_site <- multi_site %>% filter(group == \"control\")  # Create exact blocks by site blocks <- matchmaker(   left = left_site,   right = right_site,   block_type = \"group\",   block_by = \"site\" )  cat(\"Blocking structure:\\n\") #> Blocking structure: print(blocks$block_summary) #> # A tibble: 3 × 3 #>   block_id n_left n_right #>   <chr>     <dbl>   <dbl> #> 1 A            36      58 #> 2 B            26      42 #> 3 C            38      50  # Match within blocks result_blocked <- match_couples(   left = blocks$left,   right = blocks$right,   vars = c(\"age\", \"income\"),   block_id = \"block_id\",  # Use block IDs from matchmaker   auto_scale = TRUE ) #> Auto-selected scaling method: standardize  # Verify exact site balance result_blocked$pairs %>%   mutate(left_id = as.integer(left_id), right_id = as.integer(right_id)) %>%   left_join(left_site %>% dplyr::select(id, site), by = c(\"left_id\" = \"id\")) %>%   left_join(right_site %>% dplyr::select(id, site), by = c(\"right_id\" = \"id\"), suffix = c(\"_left\", \"_right\")) %>%   count(site_left, site_right) #> # A tibble: 3 × 3 #>   site_left site_right     n #>   <chr>     <chr>      <int> #> 1 A         A             36 #> 2 B         B             26 #> 3 C         C             38"},{"path":"https://gillescolling.com/couplr/articles/matching-workflows.html","id":"cluster-based-blocking","dir":"Articles","previous_headings":"Blocking and Stratification","what":"Cluster-Based Blocking","title":"Matching Workflows","text":"continuous variables, use k-means clustering create blocks:","code":"# Create blocks based on age groups (data-driven) cluster_blocks <- matchmaker(   left = left_site,   right = right_site,   block_type = \"cluster\",   block_vars = \"age\",   n_blocks = 3 )  cat(\"Cluster-based blocks:\\n\") #> Cluster-based blocks: print(cluster_blocks$block_summary) #> # A tibble: 3 × 4 #>   block_id  n_left n_right mean_age #>   <chr>      <dbl>   <dbl>    <dbl> #> 1 cluster_1     37      56     61.2 #> 2 cluster_2     41      65     48.4 #> 3 cluster_3     22      29     37.9  # Match within clusters result_clustered <- match_couples(   left = cluster_blocks$left,   right = cluster_blocks$right,   vars = c(\"age\", \"income\"),   block_id = \"block_id\",   auto_scale = TRUE ) #> Auto-selected scaling method: standardize  # Show age distribution by cluster cluster_blocks$left %>%   group_by(block_id) %>%   summarise(     n = n(),     mean_age = mean(age),     sd_age = sd(age)   ) #> # A tibble: 3 × 4 #>   block_id      n mean_age sd_age #>   <chr>     <int>    <dbl>  <dbl> #> 1 cluster_1    37     61.2   4.59 #> 2 cluster_2    41     48.4   3.27 #> 3 cluster_3    22     37.9   4.42"},{"path":"https://gillescolling.com/couplr/articles/matching-workflows.html","id":"balance-diagnostics","dir":"Articles","previous_headings":"","what":"Balance Diagnostics","title":"Matching Workflows","text":"matching, assess balance quality using balance_diagnostics().","code":""},{"path":"https://gillescolling.com/couplr/articles/matching-workflows.html","id":"key-balance-metrics","dir":"Articles","previous_headings":"Balance Diagnostics","what":"Key Balance Metrics","title":"Matching Workflows","text":"1. Standardized differences: Std Diff=x‾left−x‾right(sleft2+sright2)/2 \\text{Std Diff} = \\frac{\\bar{x}_{\\text{left}} - \\bar{x}_{\\text{right}}}{\\sqrt{(s_{\\text{left}}^2 + s_{\\text{right}}^2) / 2}} Thresholds: < 0.1: Excellent balance 0.1 - 0.25: Good balance 0.25 - 0.5: Acceptable (may need adjustment) 0.5: Poor balance (reconsider matching strategy) 2. Variance ratios: VR=sleft2sright2 \\text{VR} = \\frac{s_{\\text{left}}^2}{s_{\\text{right}}^2} Interpretation: Close 1.0: Similar variability (good) < 0.5 > 2.0: Concerning imbalance spread 3. Kolmogorov-Smirnov tests: Non-parametric test distributional differences Sensitive differences beyond mean/variance P-value > 0.05 suggests similar distributions","code":"# Perform matching match_result <- match_couples(   left = left_data,   right = right_data,   vars = c(\"age\", \"income\"),   auto_scale = TRUE ) #> Auto-selected scaling method: standardize  # Get matched samples matched_left <- left_data %>%   filter(id %in% match_result$pairs$left_id)  matched_right <- right_data %>%   filter(id %in% match_result$pairs$right_id)  # Compute balance diagnostics balance <- balance_diagnostics(   result = match_result,   left = left_data,   right = right_data,   vars = c(\"age\", \"income\") )  # Print balance summary print(balance) #>  #> Balance Diagnostics for Matched Pairs #> ====================================== #>  #> Matching Summary: #>   Method: lap #>   Matched pairs: 100 #>   Unmatched left: 0 (of 100) #>   Unmatched right: 50 (of 150) #>  #> Variable-level Balance: #> # A tibble: 2 × 7 #>   Variable `Mean Left` `Mean Right` `Mean Diff` `Std Diff` `Var Ratio` `KS Stat` #>   <chr>          <dbl>        <dbl>       <dbl>      <dbl>       <dbl>     <dbl> #> 1 age             45.9         47.3       -1.43     -0.148       0.891      0.18 #> 2 income       58387.       56118.      2269.        0.155       0.982      0.09 #>  #> Overall Balance: #>   Mean |Std Diff|: 0.151 (Good) #>   Max |Std Diff|: 0.155 #>   Vars with |Std Diff| > 0.25: 0.0% #>  #> Balance Interpretation: #>   |Std Diff| < 0.10: Excellent balance #>   |Std Diff| 0.10-0.25: Good balance #>   |Std Diff| 0.25-0.50: Acceptable balance #>   |Std Diff| > 0.50: Poor balance  # Extract balance table for reporting balance_table(balance) #> # A tibble: 2 × 7 #>   Variable `Mean Left` `Mean Right` `Mean Diff` `Std Diff` `Var Ratio` `KS Stat` #>   <chr>          <dbl>        <dbl>       <dbl>      <dbl>       <dbl>     <dbl> #> 1 age             45.9         47.3       -1.43     -0.148       0.891      0.18 #> 2 income       58387.       56118.      2269.        0.155       0.982      0.09"},{"path":"https://gillescolling.com/couplr/articles/matching-workflows.html","id":"how-to-interpret-balance-results","dir":"Articles","previous_headings":"Balance Diagnostics","what":"How to Interpret Balance Results","title":"Matching Workflows","text":"balance diagnostics output tells whether match succeeded. ’s read : Reading column: Quality thresholds standardized differences: < 0.1: Excellent balance (treat successfully matched) 0.1-0.25: Good balance (acceptable purposes) 0.25-0.5: Marginal (consider refinement sensitivity analysis) > 0.5: Poor balance (matching strategy needs revision) balance poor: Add matching variables explain imbalance Tighten calipers (accept fewer matches better quality) Try blocking problematic variable Report discuss limitations section","code":"Balance Diagnostics ------------------- Variables: age, income  Variable Statistics:   variable mean_left mean_right std_diff var_ratio ks_stat ks_p   age      45.2      45.8       -0.08    0.95      0.06    0.89   income   58000     56500      0.12     1.08      0.09    0.45"},{"path":"https://gillescolling.com/couplr/articles/matching-workflows.html","id":"visualizing-balance","dir":"Articles","previous_headings":"Balance Diagnostics","what":"Visualizing Balance","title":"Matching Workflows","text":"","code":"# Before-after balance plot # (Requires creating pre-match balance for comparison)  # For pre-match comparison, just compute summary statistics directly pre_match_stats <- tibble(   variable = c(\"age\", \"income\"),   std_diff = c(     (mean(left_data$age) - mean(right_data$age)) / sqrt((sd(left_data$age)^2 + sd(right_data$age)^2) / 2),     (mean(left_data$income) - mean(right_data$income)) / sqrt((sd(left_data$income)^2 + sd(right_data$income)^2) / 2)   ),   when = \"Before\" )  # Combine for plotting balance_comparison <- bind_rows(   pre_match_stats,   balance$var_stats %>% dplyr::select(variable, std_diff) %>% mutate(when = \"After\") )  ggplot(balance_comparison, aes(x = variable, y = std_diff, fill = when)) +   geom_hline(yintercept = c(-0.1, 0.1), linetype = \"dashed\", color = \"#93c54b\", linewidth = 0.8) +   geom_hline(yintercept = c(-0.25, 0.25), linetype = \"dashed\", color = \"#f47c3c\", linewidth = 0.8) +   geom_col(position = \"dodge\", width = 0.5) +   geom_label(aes(x = 1.5, y = -0.1, label = \"±0.1 excellent\"),              fill = \"#93c54b\", color = \"white\", inherit.aes = FALSE,              size = 3, fontface = \"bold\", label.padding = unit(0.2, \"lines\")) +   geom_label(aes(x = 1.5, y = 0.25, label = \"±0.25 acceptable\"),              fill = \"#f47c3c\", color = \"white\", inherit.aes = FALSE,              size = 3, fontface = \"bold\", label.padding = unit(0.2, \"lines\")) +   labs(     title = \"Covariate Balance Before and After Matching\",     x = \"Variable\",     y = \"Standardized Difference\",     fill = \"Timing\"   ) +   theme_minimal() +   theme(plot.background = element_rect(fill = \"transparent\", color = NA),         panel.background = element_rect(fill = \"transparent\", color = NA),         legend.background = element_rect(fill = \"transparent\", color = NA),         panel.grid = element_blank()) +   coord_flip() #> Warning in geom_label(aes(x = 1.5, y = -0.1, label = \"±0.1 excellent\"), : All aesthetics have length 1, but the data has 4 rows. #> ℹ Please consider using `annotate()` or provide this layer with data containing #>   a single row. #> Warning in geom_label(aes(x = 1.5, y = 0.25, label = \"±0.25 acceptable\"), : All aesthetics have length 1, but the data has 4 rows. #> ℹ Please consider using `annotate()` or provide this layer with data containing #>   a single row."},{"path":"https://gillescolling.com/couplr/articles/matching-workflows.html","id":"real-world-example-treatment-effect-estimation","dir":"Articles","previous_headings":"","what":"Real-World Example: Treatment Effect Estimation","title":"Matching Workflows","text":"Complete workflow estimating treatment effects observational study.","code":""},{"path":"https://gillescolling.com/couplr/articles/matching-workflows.html","id":"scenario","dir":"Articles","previous_headings":"Real-World Example: Treatment Effect Estimation","what":"Scenario","title":"Matching Workflows","text":"Evaluate effect job training program earnings. Participants self-selected program, creating potential selection bias. Data: Treatment: 200 program participants Control: 500 non-participants Covariates: age, education, prior earnings, employment status Outcome: Earnings one year program","code":""},{"path":"https://gillescolling.com/couplr/articles/matching-workflows.html","id":"step-1-data-preparation","dir":"Articles","previous_headings":"Real-World Example: Treatment Effect Estimation","what":"Step 1: Data Preparation","title":"Matching Workflows","text":"","code":"set.seed(404)  # Simulate realistic scenario with selection bias # Program attracts younger, more educated, currently employed individuals create_participant <- function(n, is_treatment) {   if (is_treatment) {     tibble(       id = 1:n,       age = rnorm(n, mean = 35, sd = 8),       education_years = rnorm(n, mean = 14, sd = 2),       prior_earnings = rnorm(n, mean = 35000, sd = 10000),       employed = sample(c(0, 1), n, replace = TRUE, prob = c(0.3, 0.7)),       treatment = 1     )   } else {     tibble(       id = (n+1):(n+500),       age = rnorm(500, mean = 42, sd = 12),       education_years = rnorm(500, mean = 12, sd = 3),       prior_earnings = rnorm(500, mean = 30000, sd = 12000),       employed = sample(c(0, 1), 500, replace = TRUE, prob = c(0.5, 0.5)),       treatment = 0     )   } }  treatment_group <- create_participant(200, TRUE) control_group <- create_participant(500, FALSE)  # Simulate outcome (earnings) with treatment effect # True effect: +$5,000, with heterogeneity treatment_group <- treatment_group %>%   mutate(     earnings = prior_earnings +       5000 +  # True treatment effect       2000 * rnorm(n()) +  # Random variation       100 * education_years  # Education effect   )  control_group <- control_group %>%   mutate(     earnings = prior_earnings +       2000 * rnorm(n()) +       100 * education_years   )  # Examine baseline imbalance cat(\"Pre-matching differences:\\n\") #> Pre-matching differences: cat(\"Age diff:\",     mean(treatment_group$age) - mean(control_group$age), \"\\n\") #> Age diff: -5.525329 cat(\"Education diff:\",     mean(treatment_group$education_years) - mean(control_group$education_years), \"\\n\") #> Education diff: 1.801605 cat(\"Prior earnings diff:\",     mean(treatment_group$prior_earnings) - mean(control_group$prior_earnings), \"\\n\") #> Prior earnings diff: 5420.931"},{"path":"https://gillescolling.com/couplr/articles/matching-workflows.html","id":"step-2-perform-matching","dir":"Articles","previous_headings":"Real-World Example: Treatment Effect Estimation","what":"Step 2: Perform Matching","title":"Matching Workflows","text":"","code":"# Match on baseline covariates job_match <- match_couples(   left = treatment_group,   right = control_group,   vars = c(\"age\", \"education_years\", \"prior_earnings\", \"employed\"),   auto_scale = TRUE,   scale = \"robust\",   return_diagnostics = TRUE )  cat(\"Matching summary:\\n\") #> Matching summary: cat(\"  Treated units:\", nrow(treatment_group), \"\\n\") #>   Treated units: 200 cat(\"  Matched treated:\", job_match$info$n_matched, \"\\n\") #>   Matched treated: 200 cat(\"  Match rate:\",     round(100 * job_match$info$n_matched / nrow(treatment_group), 1), \"%\\n\") #>   Match rate: 100 %"},{"path":"https://gillescolling.com/couplr/articles/matching-workflows.html","id":"step-3-assess-balance","dir":"Articles","previous_headings":"Real-World Example: Treatment Effect Estimation","what":"Step 3: Assess Balance","title":"Matching Workflows","text":"","code":"# Extract matched samples matched_treated <- treatment_group %>%   filter(id %in% job_match$pairs$left_id)  matched_control <- control_group %>%   filter(id %in% job_match$pairs$right_id)  # Compute balance job_balance <- balance_diagnostics(   result = job_match,   left = treatment_group,   right = control_group,   vars = c(\"age\", \"education_years\", \"prior_earnings\", \"employed\") ) #> Warning in ks.test.default(left_clean, right_clean): p-value will be #> approximate in the presence of ties  print(job_balance) #>  #> Balance Diagnostics for Matched Pairs #> ====================================== #>  #> Matching Summary: #>   Method: lap #>   Matched pairs: 200 #>   Unmatched left: 0 (of 200) #>   Unmatched right: 300 (of 500) #>  #> Variable-level Balance: #> # A tibble: 4 × 7 #>   Variable `Mean Left` `Mean Right` `Mean Diff` `Std Diff` `Var Ratio` `KS Stat` #>   <chr>          <dbl>        <dbl>       <dbl>      <dbl>       <dbl>     <dbl> #> 1 age             35.4       36.0        -0.656     -0.081       0.869     0.1   #> 2 educati…        13.9       13.5         0.4        0.195       0.93      0.18  #> 3 prior_e…     35015.     33795.       1219.         0.121       1.01      0.08  #> 4 employed         0.7        0.635       0.065      0.138       0.952     0.065 #>  #> Overall Balance: #>   Mean |Std Diff|: 0.134 (Good) #>   Max |Std Diff|: 0.195 #>   Vars with |Std Diff| > 0.25: 0.0% #>  #> Balance Interpretation: #>   |Std Diff| < 0.10: Excellent balance #>   |Std Diff| 0.10-0.25: Good balance #>   |Std Diff| 0.25-0.50: Acceptable balance #>   |Std Diff| > 0.50: Poor balance  # Check overall balance quality cat(\"\\nOverall balance:\\n\") #>  #> Overall balance: cat(\"  Mean |std diff|:\", round(job_balance$overall$mean_abs_std_diff, 3), \"\\n\") #>   Mean |std diff|: 0.134 cat(\"  Max |std diff|:\", round(job_balance$overall$max_abs_std_diff, 3), \"\\n\") #>   Max |std diff|: 0.195 cat(\"  % with |std diff| > 0.1:\",     round(job_balance$overall$pct_large_imbalance, 1), \"%\\n\") #>   % with |std diff| > 0.1: 0 %"},{"path":"https://gillescolling.com/couplr/articles/matching-workflows.html","id":"step-4-estimate-treatment-effect","dir":"Articles","previous_headings":"Real-World Example: Treatment Effect Estimation","what":"Step 4: Estimate Treatment Effect","title":"Matching Workflows","text":"","code":"# Naive estimate (without matching) - BIASED naive_effect <- mean(treatment_group$earnings) - mean(control_group$earnings)  # Matched estimate - accounts for baseline differences matched_effect <- mean(matched_treated$earnings) - mean(matched_control$earnings)  # Paired t-test for significance paired_comparison <- tibble(   treated = matched_treated$earnings,   control = matched_control$earnings[match(     matched_treated$id,     job_match$pairs$left_id   )] )  t_test <- t.test(paired_comparison$treated, paired_comparison$control, paired = TRUE)  # Report results cat(\"Treatment Effect Estimates:\\n\\n\") #> Treatment Effect Estimates: cat(\"Naive (unmatched):\\n\") #> Naive (unmatched): cat(\"  Difference: $\", round(naive_effect, 0), \"\\n\") #>   Difference: $ 10680 cat(\"  (Upward biased due to selection)\\n\\n\") #>   (Upward biased due to selection)  cat(\"Matched estimate:\\n\") #> Matched estimate: cat(\"  Difference: $\", round(matched_effect, 0), \"\\n\") #>   Difference: $ 6276 cat(\"  95% CI: ($\", round(t_test$conf.int[1], 0), \", $\",     round(t_test$conf.int[2], 0), \")\\n\") #>   95% CI: ($ 4301 , $ 8252 ) cat(\"  P-value:\", format.pval(t_test$p.value, digits = 3), \"\\n\") #>   P-value: 2.26e-09 cat(\"  (Closer to true effect of $5,000)\\n\") #>   (Closer to true effect of $5,000)"},{"path":"https://gillescolling.com/couplr/articles/matching-workflows.html","id":"step-5-publication-ready-output","dir":"Articles","previous_headings":"Real-World Example: Treatment Effect Estimation","what":"Step 5: Publication-Ready Output","title":"Matching Workflows","text":"","code":"# Table 1: Balance table balance_publication <- balance_table(job_balance) print(balance_publication)  # Table 2: Sample characteristics sample_table <- bind_rows(   matched_treated %>%     summarise(       Group = \"Treatment\",       N = n(),       `Age (mean ± SD)` = sprintf(\"%.1f ± %.1f\", mean(age), sd(age)),       `Education (years)` = sprintf(\"%.1f ± %.1f\", mean(education_years), sd(education_years)),       `Prior Earnings` = sprintf(\"$%s ± %s\",                                  format(round(mean(prior_earnings)), big.mark = \",\"),                                  format(round(sd(prior_earnings)), big.mark = \",\")),       `Employed (%)` = sprintf(\"%.1f\", 100 * mean(employed))     ),   matched_control %>%     summarise(       Group = \"Control\",       N = n(),       `Age (mean ± SD)` = sprintf(\"%.1f ± %.1f\", mean(age), sd(age)),       `Education (years)` = sprintf(\"%.1f ± %.1f\", mean(education_years), sd(education_years)),       `Prior Earnings` = sprintf(\"$%s ± %s\",                                  format(round(mean(prior_earnings)), big.mark = \",\"),                                  format(round(sd(prior_earnings)), big.mark = \",\")),       `Employed (%)` = sprintf(\"%.1f\", 100 * mean(employed))     ) )  print(sample_table)  # Table 3: Treatment effect effect_table <- tibble(   Method = c(\"Unmatched\", \"Matched\"),   `N (Treated)` = c(nrow(treatment_group), nrow(matched_treated)),   `N (Control)` = c(nrow(control_group), nrow(matched_control)),   `Effect Estimate` = sprintf(\"$%s\", format(round(c(naive_effect, matched_effect)), big.mark = \",\")),   `95% CI` = c(\"--\", sprintf(\"($%s, $%s)\",                             format(round(t_test$conf.int[1]), big.mark = \",\"),                             format(round(t_test$conf.int[2]), big.mark = \",\"))) )  print(effect_table)"},{"path":[]},{"path":"https://gillescolling.com/couplr/articles/matching-workflows.html","id":"scalability","dir":"Articles","previous_headings":"Performance Considerations","what":"Scalability","title":"Matching Workflows","text":"Optimal matching complexity: O(n3)O(n^3) using Jonker-Volgenant n = 100: < 0.01 seconds n = 500: ~ 0.1 seconds n = 1,000: ~ 1 second n = 3,000: ~ 10 seconds n = 5,000: ~ 30-60 seconds Greedy matching complexity: O(n2log⁡n)O(n^2 \\log n) sorted, O(n2)O(n^2) row-best n = 5,000: ~ 1 second n = 10,000: ~ 3-5 seconds n = 50,000: ~ 30-60 seconds","code":""},{"path":"https://gillescolling.com/couplr/articles/matching-workflows.html","id":"memory-usage","dir":"Articles","previous_headings":"Performance Considerations","what":"Memory Usage","title":"Matching Workflows","text":"Cost matrix: 8n² bytes (n×n problem) n = 1,000: ~ 8 MB n = 5,000: ~ 200 MB n = 10,000: ~ 800 MB large problems: Use greedy matching avoid full cost matrix Use blocking reduce within-block size Consider approximate methods (upcoming vignette)","code":""},{"path":"https://gillescolling.com/couplr/articles/matching-workflows.html","id":"optimization-tips","dir":"Articles","previous_headings":"Performance Considerations","what":"Optimization Tips","title":"Matching Workflows","text":"1. Use blocking large datasets 2. Start greedy, refine needed 3. Use calipers reduce problem size","code":"# Instead of matching 10,000 × 10,000: # Create 10 blocks of ~1,000 × 1,000 each blocks <- matchmaker(   left_large, right_large,   block_type = \"cluster\",   cluster_vars = \"age\",   n_clusters = 10 )  # Much faster: 10 * O(1000^3) << O(10000^3) result <- match_couples(   blocks$left, blocks$right,   vars = covariates,   block_id = \"block_id\" ) # Quick greedy match for exploration quick <- greedy_couples(   left_data, right_data,   vars = covariates,   strategy = \"row_best\" )  # Assess balance balance_quick <- balance_diagnostics(quick, left_data, right_data, vars = covariates)  # If balance is acceptable, done! # If not, try optimal or add blocking # Caliper removes distant pairs from cost matrix # Can dramatically reduce effective problem size result <- match_couples(   left_data, right_data,   vars = covariates,   max_distance = 0.25,  # Strict caliper   auto_scale = TRUE )"},{"path":"https://gillescolling.com/couplr/articles/matching-workflows.html","id":"what-can-go-wrong","dir":"Articles","previous_headings":"","what":"What Can Go Wrong","title":"Matching Workflows","text":"Matching doesn’t always succeed. common problems solutions.","code":""},{"path":"https://gillescolling.com/couplr/articles/matching-workflows.html","id":"problem-poor-balance-despite-matching","dir":"Articles","previous_headings":"What Can Go Wrong","what":"Problem: Poor Balance Despite Matching","title":"Matching Workflows","text":"Symptom: balance_diagnostics() shows |std_diff| > 0.25 variables. Causes: - Groups fundamentally different (weak overlap) Important confounders included matching variables Caliper loose Solutions:","code":"# 1. Add more matching variables result <- match_couples(left, right,                         vars = c(\"age\", \"income\", \"education\", \"region\"),  # Added!                         auto_scale = TRUE)  # 2. Tighten caliper (fewer but better matches) result <- match_couples(left, right, vars = vars,                         max_distance = 0.1)  # Was 0.5  # 3. Block on the problematic variable blocks <- matchmaker(left, right, block_type = \"group\", block_by = \"region\") result <- match_couples(blocks$left, blocks$right, vars = other_vars,                         block_id = \"block_id\")"},{"path":"https://gillescolling.com/couplr/articles/matching-workflows.html","id":"problem-very-few-matches","dir":"Articles","previous_headings":"What Can Go Wrong","what":"Problem: Very Few Matches","title":"Matching Workflows","text":"Symptom: n_matched much smaller nrow(left). Causes: - Caliper strict Non-overlapping covariate distributions Blocking creates small strata Diagnosis: Solutions: - Relax caliper Use coarser blocking categories Accept treatment units unmatchable (report !)","code":"# Check covariate overlap library(ggplot2) combined <- bind_rows(   left %>% mutate(group = \"treatment\"),   right %>% mutate(group = \"control\") ) ggplot(combined, aes(x = age, fill = group)) +   geom_density(alpha = 0.5) +   labs(title = \"Check for Overlap\")"},{"path":"https://gillescolling.com/couplr/articles/matching-workflows.html","id":"problem-matching-takes-too-long","dir":"Articles","previous_headings":"What Can Go Wrong","what":"Problem: Matching Takes Too Long","title":"Matching Workflows","text":"Symptom: match_couples() runs minutes doesn’t complete. Cause: O(n3)O(n^3) complexity optimal matching. Solutions:","code":"# For n > 3000: use greedy result <- greedy_couples(left, right, vars = vars, strategy = \"sorted\")  # For n > 5000: add blocking blocks <- matchmaker(left, right, block_type = \"cluster\", n_blocks = 20) result <- match_couples(blocks$left, blocks$right, vars = vars,                         block_id = \"block_id\")"},{"path":"https://gillescolling.com/couplr/articles/matching-workflows.html","id":"problem-memory-error","dir":"Articles","previous_headings":"What Can Go Wrong","what":"Problem: Memory Error","title":"Matching Workflows","text":"Symptom: R crashes reports “allocate vector size X”. Cause: Full cost matrix doesn’t fit RAM. 10,000×10,000 matrix needs ~800 MB. Solutions: - Use greedy_couples() doesn’t require full matrix Use blocking create smaller sub-problems Consider random sampling sample size permits","code":""},{"path":"https://gillescolling.com/couplr/articles/matching-workflows.html","id":"summary","dir":"Articles","previous_headings":"","what":"Summary","title":"Matching Workflows","text":"vignette walked complete matching workflow using job training evaluation example: Problem framing: Treatment effect estimation selection bias Matching: Creating comparable groups match_couples() Preprocessing: Automatic scaling variable health checks Assessment: Balance diagnostics interpretation Refinement: Calipers, blocking, greedy alternatives Estimation: Treatment effect confidence intervals Key Takeaways: Recommended Workflow:","code":""},{"path":"https://gillescolling.com/couplr/articles/matching-workflows.html","id":"see-also","dir":"Articles","previous_headings":"","what":"See Also","title":"Matching Workflows","text":"vignette(\"getting-started\") - Basic LAP solving vignette(\"algorithms\") - Mathematical foundations vignette(\"comparison\") - couplr compares MatchIt, optmatch, designmatch vignette(\"troubleshooting\") - Common issues solutions vignette(\"pixel-morphing\") - Large-scale approximation strategies ?match_couples, ?greedy_couples, ?balance_diagnostics, ?matchmaker","code":""},{"path":"https://gillescolling.com/couplr/articles/pixel-morphing.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"Advanced Topics","text":"vignette serves three purposes: Build intuition: Use pixel morphing visual analogy assignment problems Scale : Demonstrate approximation strategies exact LAP becomes infeasible Scientific applications: Show matching applies ecology, physics, chemistry vignette different: Unlike couplr documentation, emphasizes understanding . ’re looking solve matching problem today, start vignette(\"getting-started\") vignette(\"matching-workflows\"). Come want understand algorithms work approximations appropriate.","code":""},{"path":"https://gillescolling.com/couplr/articles/pixel-morphing.html","id":"who-this-vignette-is-for","dir":"Articles","previous_headings":"Overview","what":"Who This Vignette Is For","title":"Advanced Topics","text":"Audience: Advanced users, researchers, algorithm developers, curious minds Prerequisites: Familiarity lap_solve() (vignette(\"getting-started\")) Basic complexity analysis (Big-O notation) Interest algorithm design scientific computing ’ll Learn: exact LAP becomes infeasible large n Three approximation strategies trade-offs matching problems appear ecology, physics, chemistry Mathematical connections optimal transport theory Time complete: 45-60 minutes (conceptual reading)","code":""},{"path":"https://gillescolling.com/couplr/articles/pixel-morphing.html","id":"documentation-roadmap","dir":"Articles","previous_headings":"Overview","what":"Documentation Roadmap","title":"Advanced Topics","text":": Pixel Morphing (Advanced)","code":""},{"path":"https://gillescolling.com/couplr/articles/pixel-morphing.html","id":"why-pixels","dir":"Articles","previous_headings":"Overview","what":"Why Pixels?","title":"Advanced Topics","text":"Pixels provide ideal testbed understanding assignment problems: pixel entity measurable properties Color = feature (looks like) Position = spatial location () matching visually verifiable: can see worked algorithms morph images smoothly also track particles physics, align molecules chemistry, match vegetation plots ecology.","code":""},{"path":[]},{"path":[]},{"path":"https://gillescolling.com/couplr/articles/pixel-morphing.html","id":"problem-formulation","dir":"Articles","previous_headings":"The General Matching Problem","what":"Problem Formulation","title":"Advanced Topics","text":"Given two sets entities ={a1,…,}= \\{a_1, \\ldots, a_n\\} B={b1,…,bn}B = \\{b_1, \\ldots, b_n\\}, find optimal one--one correspondence minimizing minπ∑=1nci,π() \\min_{\\pi} \\sum_{=1}^{n} c_{,\\pi()} cost combines feature similarity spatial proximity: cij=αdfeature(ai,bj)+βdspatial(𝐱,𝐱j). c_{ij} = \\alpha \\, d_{\\text{feature}}(a_i, b_j) + \\beta \\, d_{\\text{spatial}}(\\mathbf{x}_i, \\mathbf{x}_j). Feature distance dfeatured_{\\text{feature}}: domain-specific similarity Ecology: Bray-Curtis dissimilarity species vectors Physics: difference particle intensity size Chemistry: penalty mismatched atom types Images: Euclidean distance RGB color space Spatial distance dspatiald_{\\text{spatial}}: physical proximity Ecology: geographic distance plot centers Physics: Euclidean distance accounting predicted motion Chemistry: 3D distance atomic coordinates Images: 2D pixel position distance Weights α,β≥0\\alpha, \\beta \\ge 0 balance feature matching vs. spatial coherence.","code":""},{"path":"https://gillescolling.com/couplr/articles/pixel-morphing.html","id":"computational-challenge","dir":"Articles","previous_headings":"The General Matching Problem","what":"Computational Challenge","title":"Advanced Topics","text":"Exact solution: solve full n×nn \\times n LAP. Complexity: O(n3)O(n^3) using Jonker-Volgenant Feasible: n≈1000n \\approx 1000 (30×3030 \\times 30 images, 10001000 plots/particles/atoms) Prohibitive: n=10000n = 10\\,000 (100×100100 \\times 100 images), runtime memory become expensive Real applications often involve High-resolution images: 200×200=40000200 \\times 200 = 40\\,000 pixels Large ecological surveys: 5000+5000+ plots Particle tracking: 10000+10\\,000+ particles per frame Molecular dynamics: 100000+100\\,000+ atoms therefore need approximations much faster still produce high-quality matchings.","code":""},{"path":"https://gillescolling.com/couplr/articles/pixel-morphing.html","id":"visual-illustration-pixel-morphing","dir":"Articles","previous_headings":"","what":"Visual Illustration: Pixel Morphing","title":"Advanced Topics","text":"make abstract ideas concrete, visualize using image morphing entities = pixels features = RGB color values spatial position = (x,y)(x, y) coordinates first show static input images (80×8080 \\times 80 display), animated morphs produced different matching strategies.  first pair real photographs, second pair simple geometric shapes. Internally, matching computed logical 40×4040 \\times 40 grids; upscale 80×8080 \\times 80 purely clearer display.","code":""},{"path":"https://gillescolling.com/couplr/articles/pixel-morphing.html","id":"exact-pixel-matching","dir":"Articles","previous_headings":"Visual Illustration: Pixel Morphing","what":"Exact Pixel Matching","title":"Advanced Topics","text":"exact pixel morph uses full LAP solution 1600×16001600 \\times 1600 cost matrix. pair pixels (,j)(, j) compute cij=α‖RGBiA−RGBjB‖2+β‖(xi,yi)−(xj,yj)‖2, c_{ij} = \\alpha \\,\\lVert \\text{RGB}_i^- \\text{RGB}_j^B \\rVert_2 +          \\beta \\,\\lVert (x_i, y_i) - (x_j, y_j) \\rVert_2, color distances normalized [0,3][0, \\sqrt{3}] (RGB [0,1][0,1]) spatial distances [0,1][0,1] using image diagonal.  yields optimal one--one assignment pixels. resulting animations smooth artifact-free require solving full LAP.","code":""},{"path":"https://gillescolling.com/couplr/articles/pixel-morphing.html","id":"feature-quantization-morph-strategy-1","dir":"Articles","previous_headings":"Visual Illustration: Pixel Morphing","what":"Feature Quantization Morph (Strategy 1)","title":"Advanced Topics","text":"feature quantization morph, similar colors grouped, groups matched rather individual pixels. Colors move coherent “bands,” preserving global color structure losing fine-grained per-pixel detail.","code":""},{"path":"https://gillescolling.com/couplr/articles/pixel-morphing.html","id":"hierarchical-morph-strategy-2","dir":"Articles","previous_headings":"Visual Illustration: Pixel Morphing","what":"Hierarchical Morph (Strategy 2)","title":"Advanced Topics","text":"hierarchical morph first matches large patches, refines within patches. motion locally coherent scales well large problems, price potentially missing globally optimal cross-patch matches.","code":""},{"path":"https://gillescolling.com/couplr/articles/pixel-morphing.html","id":"three-approximation-strategies","dir":"Articles","previous_headings":"","what":"Three Approximation Strategies","title":"Advanced Topics","text":"now describe three approximation strategies detail. animations correspond directly methods.","code":""},{"path":"https://gillescolling.com/couplr/articles/pixel-morphing.html","id":"strategy-1-feature-quantization","dir":"Articles","previous_headings":"Three Approximation Strategies","what":"Strategy 1: Feature Quantization","title":"Advanced Topics","text":"Core idea: reduce problem size grouping entities similar features, match groups.","code":""},{"path":"https://gillescolling.com/couplr/articles/pixel-morphing.html","id":"mathematical-formulation","dir":"Articles","previous_headings":"Three Approximation Strategies > Strategy 1: Feature Quantization","what":"Mathematical Formulation","title":"Advanced Topics","text":"Quantize features Map continuous feature space finite palette quantize:ℝd→{1,…,k}, \\text{quantize}: \\mathbb{R}^d \\\\{1, \\ldots, k\\}, k≪nk \\ll n (example k≈64k \\approx 64 n=1600n = 1600). Group palette Form groups GA(c)={:quantize(fi)=c} G_A^{(c)} = \\{ : \\text{quantize}(f_i) = c \\}  similarly BB. Match groups Solve k×kk \\times k LAP palette entries costs cij′=αd(pi,pj)+βd(𝐱‾,𝐱‾j), c'_{ij} = \\alpha \\, d(p_i, p_j) + \\beta \\, d(\\bar{\\mathbf{x}}_i, \\bar{\\mathbf{x}}_j), pip_i palette color 𝐱‾\\bar{\\mathbf{x}}_i centroid position group ii. Assign entities Every entity GA(c)G_A^{(c)} assigned according group--group match.","code":""},{"path":"https://gillescolling.com/couplr/articles/pixel-morphing.html","id":"complexity-reduction","dir":"Articles","previous_headings":"Three Approximation Strategies > Strategy 1: Feature Quantization","what":"Complexity Reduction","title":"Advanced Topics","text":"Original: O(n3)O(n^3) n×nn \\times n LAP Quantized: O(k3+nk)O(k^3 + n k) k×kk \\times k LAP plus group assignment Speedup: approximately (n/k)3(n/k)^3 example, n=1600n = 1600 (40×4040 \\times 40 image) k=64k = 64 get (160064)3=253≈15000 \\left(\\frac{1600}{64}\\right)^3 = 25^3 \\approx 15\\,000 times fewer LAP operations.","code":""},{"path":"https://gillescolling.com/couplr/articles/pixel-morphing.html","id":"quality-trade-offs","dir":"Articles","previous_headings":"Three Approximation Strategies > Strategy 1: Feature Quantization","what":"Quality Trade-offs","title":"Advanced Topics","text":"Advantages large speedups big nn Preserves global structure (similar features stay together) Produces smooth, band-like motion without large jumps Disadvantages Loses detail within palette group Quantization artifacts kk small May miss optimal local pairings similar distinct feature values corresponding GIFs color walk morphs shown earlier.","code":""},{"path":"https://gillescolling.com/couplr/articles/pixel-morphing.html","id":"strategy-2-hierarchical-decomposition","dir":"Articles","previous_headings":"Three Approximation Strategies","what":"Strategy 2: Hierarchical Decomposition","title":"Advanced Topics","text":"Core idea: split domain smaller subproblems spatial partitioning, solve subproblems, combine.","code":""},{"path":"https://gillescolling.com/couplr/articles/pixel-morphing.html","id":"mathematical-formulation-1","dir":"Articles","previous_headings":"Three Approximation Strategies > Strategy 2: Hierarchical Decomposition","what":"Mathematical Formulation","title":"Advanced Topics","text":"Spatial partitioning Divide domain m×mm \\times m patches (example m=4m = 4 get 1616 patches). Denote subset entities AA patch kk PA(k)={ai:𝐱∈Patchk}. P_A^{(k)} = \\{ a_i : \\mathbf{x}_i \\\\text{Patch}_k \\}. Patch-level matching Form patch representatives: centroid position mean features per patch. Solve m2×m2m^2 \\times m^2 LAP patches, costs defined using feature spatial distances now patch level. Recursive refinement Within matched patch pair (PA(k),PB(l))(P_A^{(k)}, P_B^{(l)}): |PA(k)|≤τ\\lvert P_A^{(k)} \\rvert \\le \\tau (threshold, e.g. τ=50\\tau = 50) solve subproblem exactly. Otherwise, partition patch pair repeat. Combine solutions Concatenate assignments leaf subproblems obtain global matching.","code":""},{"path":"https://gillescolling.com/couplr/articles/pixel-morphing.html","id":"complexity-sketch","dir":"Articles","previous_headings":"Three Approximation Strategies > Strategy 2: Hierarchical Decomposition","what":"Complexity (Sketch)","title":"Advanced Topics","text":"dd levels decomposition (level splitting four patches), work can made close O(nlog⁡n)O(n \\log n) practice, compared O(n3)O(n^3) single full LAP. Intuitively, LAPs near leaves small, costly large LAP replaced series much smaller ones.","code":""},{"path":"https://gillescolling.com/couplr/articles/pixel-morphing.html","id":"quality-trade-offs-1","dir":"Articles","previous_headings":"Three Approximation Strategies > Strategy 2: Hierarchical Decomposition","what":"Quality Trade-offs","title":"Advanced Topics","text":"Advantages Scales large nn (tens thousands entities) Preserves local structure: nearby entities tend matched within spatial patch feature discretization, feature precision retained Disadvantages May miss globally optimal cross-patch matches Quality depends partitioning scheme threshold τ\\tau Possible boundary artifacts important structure crosses patch boundaries","code":""},{"path":"https://gillescolling.com/couplr/articles/pixel-morphing.html","id":"high-level-algorithm","dir":"Articles","previous_headings":"Three Approximation Strategies > Strategy 2: Hierarchical Decomposition","what":"High-Level Algorithm","title":"Advanced Topics","text":"couplr implementation adds pragmatic details normalization color spatial distances, conversion (x,y)(x, y) coordinates raster indexing, handling remainder patches grid divide evenly.","code":"// Pseudocode for hierarchical LAP matching  FUNCTION match_hierarchical(region_A, region_B, threshold, level):    // Base case: region small enough for exact LAP   IF size(region_A) <= threshold THEN     cost <- compute_cost_matrix(region_A, region_B, α, β)     RETURN lap_solve(cost)   END IF    // Divide into 2x2 spatial grid (4 patches)   patches_A <- spatial_partition(region_A, grid = 2x2)   patches_B <- spatial_partition(region_B, grid = 2x2)    // Compute patch representatives   FOR each patch p DO     centroid[p]      <- mean(positions in p)     mean_feature[p]  <- mean(features in p)   END FOR    // Match patches using 4x4 LAP   patch_cost <- matrix(4, 4)   FOR i = 1 TO 4 DO     FOR j = 1 TO 4 DO       patch_cost[i, j] <- α·distance(mean_feature_A[i], mean_feature_B[j]) +                          β·distance(centroid_A[i], centroid_B[j])     END FOR   END FOR    patch_assignment <- lap_solve(patch_cost)    // Recursively solve within matched patches   assignments <- []   FOR i = 1 TO 4 DO     j <- patch_assignment[i]     sub_assignment <- match_hierarchical(       patches_A[i],       patches_B[j],       threshold,       level + 1     )     assignments <- append(assignments, sub_assignment)   END FOR    RETURN concatenate(assignments) END FUNCTION"},{"path":"https://gillescolling.com/couplr/articles/pixel-morphing.html","id":"strategy-3-resolution-reduction","dir":"Articles","previous_headings":"Three Approximation Strategies","what":"Strategy 3: Resolution Reduction","title":"Advanced Topics","text":"Core idea: solve LAP coarse grid, lift/upscale assignment full-resolution grid.","code":""},{"path":"https://gillescolling.com/couplr/articles/pixel-morphing.html","id":"mathematical-formulation-2","dir":"Articles","previous_headings":"Three Approximation Strategies > Strategy 3: Resolution Reduction","what":"Mathematical Formulation","title":"Advanced Topics","text":"Downscale Reduce spatial resolution factor ss (example s=2s = 2): ′=downsample(,s),B′=downsample(B,s). ' = \\text{downsample}(, s), \\qquad B' = \\text{downsample}(B, s). Now ′' B′B' n′=n/s2n' = n / s^2 entities. Solve low resolution Compute exact LAP solution n′×n′n' \\times n' problem: π′=arg⁡minπ′∑=1n′ci,π′()′. \\pi' = \\arg\\min_{\\pi'} \\sum_{=1}^{n'} c'_{,\\pi'()}. Upscale assignment Map low-resolution assignment back full resolution: π()=upscale(π′(coarse_index()),s), \\pi() = \\text{upscale}\\!\\bigl(\\pi'(\\text{coarse\\_index}()), s\\bigr), full-resolution entity inherits assignment coarse cell.","code":""},{"path":"https://gillescolling.com/couplr/articles/pixel-morphing.html","id":"complexity","dir":"Articles","previous_headings":"Three Approximation Strategies > Strategy 3: Resolution Reduction","what":"Complexity","title":"Advanced Topics","text":"Original: O(n3)O(n^3) Downscaled: O((n/s2)3)=O(n3/s6)O\\bigl((n/s^2)^3\\bigr) = O(n^3 / s^6) Speedup: s6s^6 s=2s = 2 gives 64×64\\times reduction LAP work.","code":""},{"path":"https://gillescolling.com/couplr/articles/pixel-morphing.html","id":"quality-trade-offs-2","dir":"Articles","previous_headings":"Three Approximation Strategies > Strategy 3: Resolution Reduction","what":"Quality Trade-offs","title":"Advanced Topics","text":"Advantages simple implement Exact LAP coarse level Large speedups moderate ss Disadvantages Loss fine detail blocky artifacts Assignment longer true permutation pixel level (multiple fine pixels can map coarse target) Quality deteriorates quickly larger ss practice, resolution reduction useful crude initialization step large problems (n>100000n > 100\\,000).","code":""},{"path":"https://gillescolling.com/couplr/articles/pixel-morphing.html","id":"strategy-comparison","dir":"Articles","previous_headings":"Three Approximation Strategies","what":"Strategy Comparison","title":"Advanced Topics","text":"Practical rules thumb n<1000n < 1000: use exact LAP. 1000<n<50001000 < n < 5000: feature quantization shallow hierarchy. n>5000n > 5000: hierarchical decomposition 2-3 levels. n>50000n > 50\\,000: combine s=2s = 2 resolution reduction hierarchical method.","code":""},{"path":"https://gillescolling.com/couplr/articles/pixel-morphing.html","id":"implementation-details-of-exact-pixel-matching","dir":"Articles","previous_headings":"","what":"Implementation Details of Exact Pixel Matching","title":"Advanced Topics","text":"now spell exact LAP-based morph concretely. use cost cij=α‖RGBiA−RGBjB‖2+β‖(xi,yi)−(xj,yj)‖2. c_{ij} = \\alpha \\,\\lVert \\text{RGB}_i^- \\text{RGB}_j^B \\rVert_2 +          \\beta \\,\\lVert (x_i, y_i) - (x_j, y_j) \\rVert_2. algorithm: couplr implementation handles indexing, raster layout, shows saves resulting GIFs. Approximate performance: 100×100100 \\times 100 (10 000 pixels) typical hardware fine exact LAP.","code":"// Pseudocode for exact pixel matching  // Step 1: Compute full cost matrix (normalized) n_pixels <- height x width cost <- matrix(0, n_pixels, n_pixels)  FOR i = 1 TO n_pixels DO   FOR j = 1 TO n_pixels DO     // RGB color distance (normalized to [0, sqrt(3)])     color_dist <- sqrt((R_A[i] - R_B[j])^2 +                       (G_A[i] - G_B[j])^2 +                       (B_A[i] - B_B[j])^2) / (255 · sqrt(3))      // Spatial distance (normalized to [0, 1] by diagonal)     spatial_dist <- sqrt((x_A[i] - x_B[j])^2 +                         (y_A[i] - y_B[j])^2) / diagonal_length      // Combined cost     cost[i, j] <- α · color_dist + β · spatial_dist   END FOR END FOR  // Step 2: Solve with Jonker-Volgenant assignment <- lap_solve(cost, method = \"jv\")  // Step 3: Generate morph frames by linear interpolation FOR frame_idx = 1 TO n_frames DO   t <- frame_idx / n_frames  // Time parameter in [0, 1]    FOR pixel_i = 1 TO n_pixels DO     j <- assignment[pixel_i]  // Matched target pixel      // Interpolate position     x_new[pixel_i] <- (1 - t) · x_A[pixel_i] + t · x_B[j]     y_new[pixel_i] <- (1 - t) · y_A[pixel_i] + t · y_B[j]      // Keep source color (transport-only, no blending)     RGB_new[pixel_i] <- RGB_A[pixel_i]   END FOR    frames[frame_idx] <- render(x_new, y_new, RGB_new) END FOR"},{"path":"https://gillescolling.com/couplr/articles/pixel-morphing.html","id":"application-to-scientific-domains","dir":"Articles","previous_headings":"","what":"Application to Scientific Domains","title":"Advanced Topics","text":"now return pixel morphs scientific settings motivated .","code":""},{"path":"https://gillescolling.com/couplr/articles/pixel-morphing.html","id":"ecology-vegetation-plot-matching","dir":"Articles","previous_headings":"Application to Scientific Domains","what":"Ecology: Vegetation Plot Matching","title":"Advanced Topics","text":"Problem: match nn vegetation plots surveyed time tt nn plots time t+Δtt + \\Delta t track community dynamics. Feature distance: Bray-Curtis dissimilarity species abundance vectors dBC(,b)=∑s|−bs|∑s(+bs), d_{\\text{BC}}(, b) = \\frac{\\sum_s \\lvert a_s - b_s \\rvert}      {\\sum_s (a_s + b_s)}, ,bsa_s, b_s abundances species ss plots aa bb. Spatial distance: geographic distance (e.g. kilometers) plot centers. Exact solution small studies (n<100n < 100): large studies (n>1000n > 1000) hierarchical approach region practical: allows tracking individual plot trajectories across time, distinguishing stable communities, successional trends, invasion fronts.","code":"// Pseudocode for ecological plot matching FOR i = 1 TO n_plots_t DO   FOR j = 1 TO n_plots_tplus DO      // Bray-Curtis dissimilarity for species composition     numerator   <- sum over species s of |abundance_t[i, s] - abundance_tplus[j, s]|     denominator <- sum over species s of (abundance_t[i, s] + abundance_tplus[j, s])     bc_distance <- numerator / denominator      // Geographic distance (kilometers)     geo_distance <- sqrt((x_t[i] - x_tplus[j])^2 +                         (y_t[i] - y_tplus[j])^2)      // Combined cost (α = 0.7 emphasizes species composition)     cost[i, j] <- 0.7 · bc_distance + 0.3 · (geo_distance / max_distance)    END FOR END FOR  plot_correspondence <- lap_solve(cost) // Hierarchical decomposition by geographic region  // 1. Divide landscape into spatial grid (e.g. 10 km x 10 km cells) regions_t     <- spatial_partition(plots_t,     grid_size = 10 km) regions_tplus <- spatial_partition(plots_tplus, grid_size = 10 km)  // 2. Compute region representatives FOR each region r DO   mean_composition[r] <- average species vector across plots in r   centroid[r]         <- geographic center of r END FOR  // 3. Match regions (small LAP: ~100 regions) region_cost       <- compute_cost(mean_composition, centroids, α = 0.7, β = 0.3) region_assignment <- lap_solve(region_cost)  // 4. Within matched regions, solve plot-level LAP full_assignment <- [] FOR r = 1 TO n_regions DO   r_matched <- region_assignment[r]   plots_A   <- plots in regions_t[r]   plots_B   <- plots in regions_tplus[r_matched]    // Local LAP (smaller problem, e.g. 50 x 50)   cost_local       <- compute_plot_cost(plots_A, plots_B, α = 0.7, β = 0.3)   local_assignment <- lap_solve(cost_local)    full_assignment <- append(full_assignment, local_assignment) END FOR  RETURN full_assignment"},{"path":"https://gillescolling.com/couplr/articles/pixel-morphing.html","id":"physics-particle-tracking","dir":"Articles","previous_headings":"Application to Scientific Domains","what":"Physics: Particle Tracking","title":"Advanced Topics","text":"Problem: track nn particles frame tt t+Δtt + \\Delta t experimental video. Feature distance: differences intensity, size, shape. Spatial distance: displacement relative predicted motion: dspatial(,j)=∥𝐱+𝐯iΔt−𝐱j∥2, d_{\\text{spatial}}(, j) = \\bigl\\| \\mathbf{x}_i + \\mathbf{v}_i \\Delta t - \\mathbf{x}_j \\bigr\\|_2, 𝐯\\mathbf{v}_i estimated velocity previous frames. also impose maximum displacement dmaxd_{\\max} beyond matches physically implausible. Exact solution (moderate nn): dense tracking (n>5000n > 5000), can first cluster particles: yields efficient robust trajectories even dense particle fields.","code":"// Pseudocode for particle tracking with velocity prediction  // Initialize cost matrix as forbidden everywhere cost <- matrix(Inf, n_particles_t, n_particles_tplus)  FOR i = 1 TO n_particles_t DO   // Predict position using previous velocity   x_predicted <- x_t[i] + v_x_t[i] · Δt   y_predicted <- y_t[i] + v_y_t[i] · Δt    FOR j = 1 TO n_particles_tplus DO     // Distance from predicted position     dx <- x_predicted - x_tplus[j]     dy <- y_predicted - y_tplus[j]     spatial_distance <- sqrt(dx^2 + dy^2)      // Only consider physically plausible matches     IF spatial_distance <= max_displacement THEN       // Feature similarity (intensity, size, etc.)       feature_distance <- |intensity_t[i] - intensity_tplus[j]|        // Combined cost       cost[i, j] <- α · feature_distance + β · spatial_distance     END IF   END FOR END FOR  // Solve assignment (Inf entries are forbidden) particle_tracks <- lap_solve(cost)  // Update velocities from assignments FOR i = 1 TO n_particles_t DO   j <- particle_tracks[i]   velocity_new[i] <- (position_tplus[j] - position_t[i]) / Δt END FOR // Two-stage: clustering then local matching  // Stage 1: spatial clustering clusters_t     <- spatial_cluster(particles_t,     radius = 2 · pixel_size) clusters_tplus <- spatial_cluster(particles_tplus, radius = 2 · pixel_size)  // Compute cluster representatives FOR each cluster c DO   centroid[c]       <- mean position of particles in c   mean_intensity[c] <- mean intensity   mean_velocity[c]  <- mean velocity (if available) END FOR  // Match clusters cluster_cost   <- compute_cluster_similarity(clusters_t, clusters_tplus) cluster_tracks <- lap_solve(cluster_cost)  // Stage 2: within matched clusters, track individual particles full_tracks <- [] FOR c = 1 TO n_clusters DO   c_matched   <- cluster_tracks[c]   particles_A <- particles in clusters_t[c]   particles_B <- particles in clusters_tplus[c_matched]    cost_local <- compute_particle_distance(     particles_A, particles_B,     max_displacement = 5,     α = 0.3,     β = 0.7   )    local_tracks <- lap_solve(cost_local)   full_tracks  <- append(full_tracks, local_tracks) END FOR  RETURN full_tracks"},{"path":"https://gillescolling.com/couplr/articles/pixel-morphing.html","id":"chemistry-molecular-conformation-alignment","dir":"Articles","previous_headings":"Application to Scientific Domains","what":"Chemistry: Molecular Conformation Alignment","title":"Advanced Topics","text":"Problem: align two conformations molecule (e.g. protein) nn atoms compute RMSD analyze structural change. Feature distance: strict element matching delement(,j)={0,elementi=elementj,∞,otherwise. d_{\\text{element}}(, j) = \\begin{cases} 0, & \\text{} \\text{element}_i = \\text{element}_j, \\\\ \\infty, & \\text{otherwise.} \\end{cases} Spatial distance: 3D Euclidean distance atomic coordinates. Exact LAP small molecules: large biomolecules, use hierarchical strategy, time secondary structure elements (helices, sheets, loops, etc.), aligning segments first atoms within matched segments.","code":"// Pseudocode for molecular conformation alignment  n_atoms <- number of atoms in molecule cost    <- matrix(0, n_atoms, n_atoms)  FOR i = 1 TO n_atoms DO   FOR j = 1 TO n_atoms DO      // Enforce strict element type matching     IF element_type_A[i] ≠ element_type_B[j] THEN       cost[i, j] <- Inf     ELSE       dx <- x_A[i] - x_B[j]       dy <- y_A[i] - y_B[j]       dz <- z_A[i] - z_B[j]       cost[i, j] <- sqrt(dx^2 + dy^2 + dz^2)     END IF    END FOR END FOR  // Solve alignment alignment <- lap_solve(cost)  // Compute RMSD sum_sq_dist <- 0 FOR i = 1 TO n_atoms DO   j            <- alignment[i]   sum_sq_dist <- sum_sq_dist + cost[i, j]^2 END FOR  rmsd <- sqrt(sum_sq_dist / n_atoms)"},{"path":[]},{"path":"https://gillescolling.com/couplr/articles/pixel-morphing.html","id":"customizing-morph-duration","dir":"Articles","previous_headings":"Implementation Notes","what":"Customizing Morph Duration","title":"Advanced Topics","text":"morphing examples use default settings, can customize number frames speed: Total animation duration n_frames * frame_delay seconds.","code":"# From inst/scripts/generate_examples.R generate_morph <- function(assignment, pixels_A, pixels_B,                            n_frames    = 30,   # number of frames                            frame_delay = 0.1)  # delay between frames (seconds) {   frames <- lapply(seq(0, 1, length.out = n_frames), function(t) {     interpolate_frame(t, assignment, pixels_A, pixels_B)   })    save_gif(frames, delay = frame_delay) }"},{"path":"https://gillescolling.com/couplr/articles/pixel-morphing.html","id":"using-the-example-code","dir":"Articles","previous_headings":"Implementation Notes","what":"Using the Example Code","title":"Advanced Topics","text":"morphing implementation provided inst/scripts/generate_examples.R:","code":"# View the source example_script <- system.file(\"scripts\", \"generate_examples.R\", package = \"couplr\") file.show(example_script)  # Or source to use its helpers source(example_script)  # Apply to your own data my_cost       <- build_cost_matrix(my_data_A, my_data_B) my_assignment <- lap_solve(my_cost)"},{"path":"https://gillescolling.com/couplr/articles/pixel-morphing.html","id":"regenerating-examples","dir":"Articles","previous_headings":"Implementation Notes","what":"Regenerating Examples","title":"Advanced Topics","text":"regenerate demo GIFs PNGs: write assets inst/extdata.","code":"source(\"inst/scripts/generate_examples.R\")"},{"path":"https://gillescolling.com/couplr/articles/pixel-morphing.html","id":"mathematical-foundation-optimal-transport","dir":"Articles","previous_headings":"","what":"Mathematical Foundation: Optimal Transport","title":"Advanced Topics","text":"matching problems discussed discrete instances optimal transport.","code":""},{"path":"https://gillescolling.com/couplr/articles/pixel-morphing.html","id":"monge-problem","dir":"Articles","previous_headings":"Mathematical Foundation: Optimal Transport","what":"Monge Problem","title":"Advanced Topics","text":"original Monge formulation (1781) seeks transport map T:→BT: \\B minimizing ∫Ac(𝐱,T(𝐱))dμ(𝐱). \\int_A c(\\mathbf{x}, T(\\mathbf{x})) \\,\\mathrm{d}\\mu(\\mathbf{x}).","code":""},{"path":"https://gillescolling.com/couplr/articles/pixel-morphing.html","id":"kantorovich-relaxation","dir":"Articles","previous_headings":"Mathematical Foundation: Optimal Transport","what":"Kantorovich Relaxation","title":"Advanced Topics","text":"Kantorovich (1942) relaxed transport plan γ\\gamma ×BA \\times B: minγ∫×Bc(𝐱,𝐲)dγ(𝐱,𝐲) \\min_{\\gamma} \\int_{\\times B} c(\\mathbf{x}, \\mathbf{y}) \\,\\mathrm{d}\\gamma(\\mathbf{x}, \\mathbf{y}) subject marginal constraints γ\\gamma.","code":""},{"path":"https://gillescolling.com/couplr/articles/pixel-morphing.html","id":"discrete-linear-assignment","dir":"Articles","previous_headings":"Mathematical Foundation: Optimal Transport","what":"Discrete Linear Assignment","title":"Advanced Topics","text":"discrete uniform distributions nn points AA BB obtain exactly linear assignment problem: minπ∈Sn∑=1nci,π(), \\min_{\\pi \\S_n} \\sum_{=1}^n c_{,\\pi()}, couplr solves efficiently.","code":""},{"path":"https://gillescolling.com/couplr/articles/pixel-morphing.html","id":"wasserstein-distance","dir":"Articles","previous_headings":"Mathematical Foundation: Optimal Transport","what":"Wasserstein Distance","title":"Advanced Topics","text":"cij=d(𝐱,𝐱j)c_{ij} = d(\\mathbf{x}_i, \\mathbf{x}_j) (often Euclidean distance), optimal cost defines 11‑Wasserstein distance: W1(μ,ν)=minπ∈Sn∑=1nci,π(). W_1(\\mu, \\nu) = \\min_{\\pi \\S_n} \\sum_{=1}^n c_{,\\pi()}. appears Earth mover’s distance image retrieval Distributional similarity statistics Generative modeling (e.g. Wasserstein GANs)","code":""},{"path":[]},{"path":"https://gillescolling.com/couplr/articles/pixel-morphing.html","id":"optimal-transport-theory","dir":"Articles","previous_headings":"Further Reading","what":"Optimal Transport Theory","title":"Advanced Topics","text":"Peyré, G., & Cuturi, M. (2019). Computational Optimal Transport. Foundations Trends Machine Learning. Villani, C. (2008). Optimal Transport: Old New. Springer.","code":""},{"path":"https://gillescolling.com/couplr/articles/pixel-morphing.html","id":"scientific-applications","dir":"Articles","previous_headings":"Further Reading","what":"Scientific Applications","title":"Advanced Topics","text":"Ecology Anderson, M. J. et al. (2011). Navigating multiple meanings beta diversity. Ecology Letters. Legendre, P., & Legendre, L. (2012). Numerical Ecology. Elsevier. Physics Adrian, R. J., & Westerweel, J. (2011). Particle Image Velocimetry. Cambridge University Press. Crocker, J. C., & Grier, D. G. (1996). Methods digital video microscopy. Journal Colloid Interface Science. Chemistry Kabsch, W. (1976). solution best rotation relate two sets vectors. Acta Crystallographica. Coutsias, E. . et al. (2004). Using quaternions calculate RMSD. Journal Computational Chemistry.","code":""},{"path":"https://gillescolling.com/couplr/articles/pixel-morphing.html","id":"assignment-algorithms","dir":"Articles","previous_headings":"Further Reading","what":"Assignment Algorithms","title":"Advanced Topics","text":"Burkard, R., Dell’Amico, M., & Martello, S. (2009). Assignment Problems. SIAM. implementation details package see vignette(\"algorithms\").","code":""},{"path":"https://gillescolling.com/couplr/articles/pixel-morphing.html","id":"connection-to-couplr-workflows","dir":"Articles","previous_headings":"","what":"Connection to couplr Workflows","title":"Advanced Topics","text":"approximation strategies vignette become relevant working couplr’s practical matching functions.","code":""},{"path":[]},{"path":"https://gillescolling.com/couplr/articles/pixel-morphing.html","id":"practical-recommendations","dir":"Articles","previous_headings":"Connection to couplr Workflows","what":"Practical Recommendations","title":"Advanced Topics","text":"n < 3,000: Use match_couples() exact algorithms: 3,000 < n < 10,000: Use blocking create smaller subproblems: n > 10,000: Use greedy matching: n > 50,000: Combine strategies (blocking + greedy within blocks), implement custom approximations using techniques vignette.","code":"result <- match_couples(left, right, vars = c(\"x\", \"y\", \"z\"), auto_scale = TRUE) blocks <- matchmaker(left, right, block_type = \"cluster\", n_blocks = 10) result <- match_couples(blocks$left, blocks$right, vars = vars, block_id = \"block_id\") result <- greedy_couples(left, right, vars = vars, strategy = \"sorted\")"},{"path":"https://gillescolling.com/couplr/articles/pixel-morphing.html","id":"limitations-of-approximation-strategies","dir":"Articles","previous_headings":"Connection to couplr Workflows","what":"Limitations of Approximation Strategies","title":"Advanced Topics","text":"approximation trades accuracy speed. Know failure modes:","code":""},{"path":"https://gillescolling.com/couplr/articles/pixel-morphing.html","id":"summary","dir":"Articles","previous_headings":"","what":"Summary","title":"Advanced Topics","text":"vignette explored optimal matching lens pixel morphing scientific applications. Key Ideas: Assignment = matching: LAP finds optimal correspondences two sets Scalability matters: O(n3)O(n^3) becomes prohibitive n>3,000n > 3{,}000 Three approximations: Feature quantization, hierarchical decomposition, resolution reduction math, different domains: Pixels, particles, plots, atoms use algorithms algorithms morph images smoothly also track particles physics, align molecules chemistry, match vegetation plots ecology. Together, methods couplr let move exact optimal matchings principled approximations, depending problem size accuracy requirements.","code":""},{"path":"https://gillescolling.com/couplr/articles/pixel-morphing.html","id":"see-also","dir":"Articles","previous_headings":"","what":"See Also","title":"Advanced Topics","text":"vignette(\"getting-started\") - Basic LAP solving vignette(\"algorithms\") - Mathematical foundations vignette(\"matching-workflows\") - Production matching pipelines ?lap_solve, ?match_couples, ?greedy_couples","code":""},{"path":"https://gillescolling.com/couplr/articles/troubleshooting.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"Troubleshooting Guide","text":"vignette provides solutions common issues encountered using couplr. section describes problem, explains occurs, provides step--step solutions. Quick reference:","code":""},{"path":[]},{"path":"https://gillescolling.com/couplr/articles/troubleshooting.html","id":"symptom","dir":"Articles","previous_headings":"Infeasible Problems","what":"Symptom","title":"Troubleshooting Guide","text":"Error message: “feasible assignment found” total cost Inf.","code":"# This fails: all assignments have Inf cost cost <- matrix(c(1, Inf, Inf, Inf, Inf, Inf, Inf, 2, 3), nrow = 3, byrow = TRUE) result <- lap_solve(cost) #> Error in `lap_solve_bruteforce()`: #> ! Infeasible given forbidden edges"},{"path":"https://gillescolling.com/couplr/articles/troubleshooting.html","id":"cause","dir":"Articles","previous_headings":"Infeasible Problems","what":"Cause","title":"Troubleshooting Guide","text":"feasible assignment requires every row can assigned least one column finite cost. rows -Inf -NA entries, valid assignment exists.","code":""},{"path":"https://gillescolling.com/couplr/articles/troubleshooting.html","id":"diagnosis","dir":"Articles","previous_headings":"Infeasible Problems","what":"Diagnosis","title":"Troubleshooting Guide","text":"","code":"# Check for infeasible rows check_feasibility <- function(cost_matrix) {   finite_per_row <- rowSums(is.finite(cost_matrix))   infeasible_rows <- which(finite_per_row == 0)    if (length(infeasible_rows) > 0) {     cat(\"Infeasible rows (no finite costs):\", infeasible_rows, \"\\n\")     return(FALSE)   }    finite_per_col <- colSums(is.finite(cost_matrix))   infeasible_cols <- which(finite_per_col == 0)    if (length(infeasible_cols) > 0) {     cat(\"Infeasible columns (no finite costs):\", infeasible_cols, \"\\n\")     return(FALSE)   }    cat(\"Problem appears feasible\\n\")   return(TRUE) }  # Check the problematic matrix cost <- matrix(c(1, Inf, Inf, Inf, Inf, Inf, Inf, 2, 3), nrow = 3, byrow = TRUE) check_feasibility(cost) #> Infeasible rows (no finite costs): 2 #> [1] FALSE"},{"path":"https://gillescolling.com/couplr/articles/troubleshooting.html","id":"solutions","dir":"Articles","previous_headings":"Infeasible Problems","what":"Solutions","title":"Troubleshooting Guide","text":"1. Remove infeasible rows/columns: 2. Add fallback costs: 3. matching: check covariate overlap:","code":"# Remove rows with no valid assignments cost <- matrix(c(1, Inf, Inf, Inf, Inf, Inf, Inf, 2, 3), nrow = 3, byrow = TRUE) valid_rows <- rowSums(is.finite(cost)) > 0 cost_valid <- cost[valid_rows, , drop = FALSE]  if (nrow(cost_valid) > 0) {   result <- lap_solve(cost_valid)   cat(\"Matched\", nrow(result), \"of\", nrow(cost), \"rows\\n\") } #> Matched 2 of 3 rows # Replace Inf with high (but finite) penalty cost_with_fallback <- cost cost_with_fallback[!is.finite(cost_with_fallback)] <- 1e6  # Large penalty  result <- lap_solve(cost_with_fallback) print(result) #> Assignment Result #> ================= #>  #> # A tibble: 3 × 3 #>   source target    cost #>    <int>  <int>   <dbl> #> 1      1      1       1 #> 2      2      3 1000000 #> 3      3      2       2 #>  #> Total cost: 1000003  #> Method: bruteforce # Simulate poor overlap scenario set.seed(123) left <- tibble(id = 1:50, age = rnorm(50, mean = 25, sd = 3)) right <- tibble(id = 1:50, age = rnorm(50, mean = 55, sd = 3))  # Visualize overlap library(ggplot2) combined <- bind_rows(   left %>% mutate(group = \"Left\"),   right %>% mutate(group = \"Right\") )  ggplot(combined, aes(x = age, fill = group)) +   geom_density(alpha = 0.5) +   labs(title = \"Poor Covariate Overlap\",        subtitle = \"No overlap means no good matches possible\") +   theme_minimal() +   theme(plot.background = element_rect(fill = \"transparent\", color = NA),         panel.background = element_rect(fill = \"transparent\", color = NA))"},{"path":[]},{"path":"https://gillescolling.com/couplr/articles/troubleshooting.html","id":"symptom-1","dir":"Articles","previous_headings":"Poor Balance Despite Matching","what":"Symptom","title":"Troubleshooting Guide","text":"matching, balance_diagnostics() shows |std_diff| > 0.25 variables.","code":"# Example of poor balance set.seed(456) left <- tibble(   id = 1:100,   age = rnorm(100, 30, 5),   income = rnorm(100, 80000, 20000)  # Very different from right ) right <- tibble(   id = 1:100,   age = rnorm(100, 32, 5),   income = rnorm(100, 40000, 10000)  # Very different income )  result <- match_couples(left, right, vars = c(\"age\", \"income\"), auto_scale = TRUE) #> Auto-selected scaling method: standardize balance <- balance_diagnostics(result, left, right, vars = c(\"age\", \"income\")) print(balance) #>  #> Balance Diagnostics for Matched Pairs #> ====================================== #>  #> Matching Summary: #>   Method: lap #>   Matched pairs: 100 #>   Unmatched left: 0 (of 100) #>   Unmatched right: 0 (of 100) #>  #> Variable-level Balance: #> # A tibble: 2 × 7 #>   Variable `Mean Left` `Mean Right` `Mean Diff` `Std Diff` `Var Ratio` `KS Stat` #>   <chr>          <dbl>        <dbl>       <dbl>      <dbl>       <dbl>     <dbl> #> 1 age             30.6         32.5       -1.89     -0.386        1.05      0.22 #> 2 income       77666.       41353.     36313.        2.40         2.15      0.81 #>  #> Overall Balance: #>   Mean |Std Diff|: 1.391 (Poor) #>   Max |Std Diff|: 2.397 #>   Vars with |Std Diff| > 0.25: 100.0% #>  #> Balance Interpretation: #>   |Std Diff| < 0.10: Excellent balance #>   |Std Diff| 0.10-0.25: Good balance #>   |Std Diff| 0.25-0.50: Acceptable balance #>   |Std Diff| > 0.50: Poor balance"},{"path":"https://gillescolling.com/couplr/articles/troubleshooting.html","id":"causes","dir":"Articles","previous_headings":"Poor Balance Despite Matching","what":"Causes","title":"Troubleshooting Guide","text":"Weak overlap: Groups different key variables Missing confounders: Important variables included matching Caliper loose: Accepting poor matches Wrong scaling: Variables properly weighted","code":""},{"path":"https://gillescolling.com/couplr/articles/troubleshooting.html","id":"solutions-1","dir":"Articles","previous_headings":"Poor Balance Despite Matching","what":"Solutions","title":"Troubleshooting Guide","text":"1. Add matching variables: 2. Tighten caliper (fewer better matches): 3. Use blocking problematic variable: 4. Try different scaling:","code":"# Include additional relevant variables result <- match_couples(   left, right,   vars = c(\"age\", \"income\", \"education\", \"region\"),  # More variables   auto_scale = TRUE ) result_strict <- match_couples(   left, right,   vars = c(\"age\", \"income\"),   max_distance = 0.3,  # Stricter caliper   auto_scale = TRUE ) #> Auto-selected scaling method: standardize #> Error in `lap_solve_auction_scaled()`: #> ! Auction(scaled): iteration guard at eps=7885383213142811494408480082840444688844086424042268422604802684204020084804602286084062426808668246202024044680060000888826240426666820268808860060886662888880668826624624282408686624866884640486622460688806226620844868208208262004280626244240268286668462608648088464686088602226464888282882.000000, phase=19  cat(\"Original matches:\", result$info$n_matched, \"\\n\") #> Original matches: 100 cat(\"With caliper:\", result_strict$info$n_matched, \"\\n\") #> Error: #> ! object 'result_strict' not found  balance_strict <- balance_diagnostics(result_strict, left, right, vars = c(\"age\", \"income\")) #> Error: #> ! object 'result_strict' not found print(balance_strict) #> Error: #> ! object 'balance_strict' not found # Block on income tertiles to ensure exact balance left$income_cat <- cut(left$income, breaks = 3, labels = c(\"low\", \"mid\", \"high\")) right$income_cat <- cut(right$income, breaks = 3, labels = c(\"low\", \"mid\", \"high\"))  blocks <- matchmaker(left, right, block_type = \"group\", block_by = \"income_cat\") result_blocked <- match_couples(   blocks$left, blocks$right,   vars = c(\"age\"),  # Match on age within income blocks   block_id = \"block_id\" ) # Compare scaling methods for (scale_method in c(\"robust\", \"standardize\", \"range\")) {   res <- match_couples(left, right, vars = c(\"age\", \"income\"),                        auto_scale = TRUE, scale = scale_method)   bal <- balance_diagnostics(res, left, right, vars = c(\"age\", \"income\"))   cat(scale_method, \"- max |std_diff|:\",       round(bal$overall$max_abs_std_diff, 3), \"\\n\") } #> robust - max |std_diff|: 2.397  #> standardize - max |std_diff|: 2.397  #> range - max |std_diff|: 2.397"},{"path":[]},{"path":"https://gillescolling.com/couplr/articles/troubleshooting.html","id":"symptom-2","dir":"Articles","previous_headings":"Performance Issues","what":"Symptom","title":"Troubleshooting Guide","text":"match_couples() lap_solve() takes long doesn’t complete.","code":""},{"path":"https://gillescolling.com/couplr/articles/troubleshooting.html","id":"cause-1","dir":"Articles","previous_headings":"Performance Issues","what":"Cause","title":"Troubleshooting Guide","text":"Optimal matching O(n3)O(n^3) complexity. n = 5,000, means ~125 billion operations.","code":""},{"path":"https://gillescolling.com/couplr/articles/troubleshooting.html","id":"diagnosis-1","dir":"Articles","previous_headings":"Performance Issues","what":"Diagnosis","title":"Troubleshooting Guide","text":"","code":"# Estimate runtime estimate_runtime <- function(n, seconds_per_billion = 1) {   ops <- n^3   time_sec <- ops / 1e9 * seconds_per_billion    if (time_sec < 60) {     sprintf(\"%.1f seconds\", time_sec)   } else if (time_sec < 3600) {     sprintf(\"%.1f minutes\", time_sec / 60)   } else {     sprintf(\"%.1f hours\", time_sec / 3600)   } }  cat(\"Estimated runtime for optimal matching:\\n\") #> Estimated runtime for optimal matching: for (n in c(100, 500, 1000, 3000, 5000, 10000)) {   cat(sprintf(\"  n = %5d: %s\\n\", n, estimate_runtime(n))) } #>   n =   100: 0.0 seconds #>   n =   500: 0.1 seconds #>   n =  1000: 1.0 seconds #>   n =  3000: 27.0 seconds #>   n =  5000: 2.1 minutes #>   n = 10000: 16.7 minutes"},{"path":"https://gillescolling.com/couplr/articles/troubleshooting.html","id":"solutions-2","dir":"Articles","previous_headings":"Performance Issues","what":"Solutions","title":"Troubleshooting Guide","text":"1. Use greedy matching large problems: 2. Use blocking divide problem: 3. Choose faster algorithm: 4. Pre-compute cache distances:","code":"set.seed(789) n <- 500 large_left <- tibble(id = 1:n, x1 = rnorm(n), x2 = rnorm(n)) large_right <- tibble(id = 1:n, x1 = rnorm(n), x2 = rnorm(n))  # Greedy is much faster time_greedy <- system.time({   result_greedy <- greedy_couples(     large_left, large_right,     vars = c(\"x1\", \"x2\"),     strategy = \"row_best\"   ) })  cat(\"Greedy matching (n=500):\", round(time_greedy[\"elapsed\"], 2), \"seconds\\n\") #> Greedy matching (n=500): 0.25 seconds cat(\"Quality (mean distance):\", round(mean(result_greedy$pairs$distance), 4), \"\\n\") #> Quality (mean distance): 0.2886 # Create clusters to match within blocks <- matchmaker(   large_left, large_right,   block_type = \"cluster\",   block_vars = c(\"x1\", \"x2\"),   n_blocks = 10  # 10 blocks of ~200 each )  # Match within blocks (10 x O(200^3) << O(2000^3)) result_blocked <- match_couples(   blocks$left, blocks$right,   vars = c(\"x1\", \"x2\"),   block_id = \"block_id\" ) # For n > 1000, auction algorithm often faster result <- match_couples(   large_left, large_right,   vars = c(\"x1\", \"x2\"),   method = \"auction\" )  # For sparse problems (many forbidden pairs) result <- match_couples(   left, right,   vars = vars,   max_distance = 0.5,  # Creates sparsity   method = \"sap\"       # Sparse algorithm ) # Compute once, reuse multiple times dist_cache <- compute_distances(   large_left, large_right,   vars = c(\"x1\", \"x2\"),   scale = \"robust\" )  # Fast: reuse cached distances result1 <- match_couples(dist_cache, max_distance = 0.3) #> Error in `lap_solve_auction_scaled()`: #> ! Auction(scaled): iteration guard at eps=7885383213142811494408480082840444688844086424042268422604802684204020084804602286084062426808668246202024044680060000888826240426666820268808860060886662888880668826624624282408686624866884640486622460688806226620844868208208262004280626244240268286668462608648088464686088602226464888282882.000000, phase=19 result2 <- match_couples(dist_cache, max_distance = 0.5) #> Error in `lap_solve_auction_scaled()`: #> ! Auction(scaled): iteration guard at eps=7885383213142811494408480082840444688844086424042268422604802684204020084804602286084062426808668246202024044680060000888826240426666820268808860060886662888880668826624624282408686624866884640486622460688806226620844868208208262004280626244240268286668462608648088464686088602226464888282882.000000, phase=19 result3 <- match_couples(dist_cache, max_distance = 1.0) #> Error in `lap_solve_auction_scaled()`: #> ! Auction(scaled): iteration guard at eps=1126483316163258824588840464686822002040606866822442644006464204284244600860220408644206628884660088462204820084486686828448800068422244884462088864286246088448668606428686082644420022446608028628488602664280848840444608420828066682648826868226802866640024264200844882840648848844628646628040.000000, phase=20"},{"path":[]},{"path":"https://gillescolling.com/couplr/articles/troubleshooting.html","id":"symptom-3","dir":"Articles","previous_headings":"Memory Errors","what":"Symptom","title":"Troubleshooting Guide","text":"R crashes shows: “Error: allocate vector size X GB”","code":""},{"path":"https://gillescolling.com/couplr/articles/troubleshooting.html","id":"cause-2","dir":"Articles","previous_headings":"Memory Errors","what":"Cause","title":"Troubleshooting Guide","text":"full distance matrix nxn requires 8n² bytes:","code":"# Memory requirements memory_needed <- function(n) {   bytes <- 8 * n^2   if (bytes < 1e6) {     sprintf(\"%.1f KB\", bytes / 1e3)   } else if (bytes < 1e9) {     sprintf(\"%.1f MB\", bytes / 1e6)   } else {     sprintf(\"%.1f GB\", bytes / 1e9)   } }  cat(\"Memory for full distance matrix:\\n\") #> Memory for full distance matrix: for (n in c(1000, 5000, 10000, 20000, 50000)) {   cat(sprintf(\"  n = %5d: %s\\n\", n, memory_needed(n))) } #>   n =  1000: 8.0 MB #>   n =  5000: 200.0 MB #>   n = 10000: 800.0 MB #>   n = 20000: 3.2 GB #>   n = 50000: 20.0 GB"},{"path":"https://gillescolling.com/couplr/articles/troubleshooting.html","id":"solutions-3","dir":"Articles","previous_headings":"Memory Errors","what":"Solutions","title":"Troubleshooting Guide","text":"1. Use greedy matching (avoids full matrix): 2. Use blocking create smaller subproblems: 3. Use caliper create sparse matrix: 4. Increase R’s memory limit (Windows):","code":"# Greedy computes distances on-the-fly result <- greedy_couples(   left, right,   vars = covariates,   strategy = \"row_best\"  # Most memory-efficient ) # Each block is much smaller blocks <- matchmaker(left, right, block_type = \"cluster\", n_blocks = 20) result <- match_couples(blocks$left, blocks$right, vars = vars, block_id = \"block_id\") # Caliper excludes distant pairs (sparse representation) result <- match_couples(   left, right,   vars = covariates,   max_distance = 0.5,   method = \"sap\"  # Sparse-optimized algorithm ) # Increase to 16 GB (if available) memory.limit(size = 16000)"},{"path":[]},{"path":"https://gillescolling.com/couplr/articles/troubleshooting.html","id":"symptom-4","dir":"Articles","previous_headings":"Different Results with Different Methods","what":"Symptom","title":"Troubleshooting Guide","text":"Different algorithms return different assignments:","code":"cost <- matrix(c(1, 2, 2, 2, 1, 2, 2, 2, 1), nrow = 3, byrow = TRUE)  result_jv <- lap_solve(cost, method = \"jv\") result_hungarian <- lap_solve(cost, method = \"hungarian\")  cat(\"JV assignment:       \", result_jv$target, \"\\n\") #> JV assignment:        1 2 3 cat(\"Hungarian assignment:\", result_hungarian$target, \"\\n\") #> Hungarian assignment: 1 2 3 cat(\"JV total cost:       \", get_total_cost(result_jv), \"\\n\") #> JV total cost:        3 cat(\"Hungarian total cost:\", get_total_cost(result_hungarian), \"\\n\") #> Hungarian total cost: 3"},{"path":"https://gillescolling.com/couplr/articles/troubleshooting.html","id":"cause-3","dir":"Articles","previous_headings":"Different Results with Different Methods","what":"Cause","title":"Troubleshooting Guide","text":"multiple optimal solutions exist (tied costs), different algorithms may find different ones. total cost ; , report bug.","code":""},{"path":"https://gillescolling.com/couplr/articles/troubleshooting.html","id":"diagnosis-2","dir":"Articles","previous_headings":"Different Results with Different Methods","what":"Diagnosis","title":"Troubleshooting Guide","text":"","code":"# Check for ties check_ties <- function(cost_matrix) {   n <- nrow(cost_matrix)   # Check if diagonal dominates (trivial ties)   diag_costs <- diag(cost_matrix)   if (length(unique(diag_costs)) < n) {     cat(\"Tied costs on diagonal - multiple optima likely\\n\")   }    # Check cost uniqueness   unique_costs <- length(unique(as.vector(cost_matrix)))   total_entries <- length(cost_matrix)   if (unique_costs < total_entries * 0.5) {     cat(\"Many repeated costs - ties possible\\n\")   } }  check_ties(cost) #> Tied costs on diagonal - multiple optima likely #> Many repeated costs - ties possible"},{"path":"https://gillescolling.com/couplr/articles/troubleshooting.html","id":"solutions-4","dir":"Articles","previous_headings":"Different Results with Different Methods","what":"Solutions","title":"Troubleshooting Guide","text":"1. Verify total costs match: 2. Use Hungarian deterministic tie-breaking: 3. Add small noise break ties:","code":"# Total cost should be identical stopifnot(get_total_cost(result_jv) == get_total_cost(result_hungarian)) cat(\"Both methods found optimal solutions (same total cost)\\n\") #> Both methods found optimal solutions (same total cost) # Hungarian has consistent tie-breaking result <- lap_solve(cost, method = \"hungarian\") set.seed(42) cost_perturbed <- cost + matrix(rnorm(9, 0, 1e-10), 3, 3) result <- lap_solve(cost_perturbed)"},{"path":[]},{"path":"https://gillescolling.com/couplr/articles/troubleshooting.html","id":"symptom-5","dir":"Articles","previous_headings":"Missing Values in Data","what":"Symptom","title":"Troubleshooting Guide","text":"Matching fails produces unexpected results due NA values.","code":"left <- tibble(id = 1:5, age = c(25, 30, NA, 35, 40)) right <- tibble(id = 1:5, age = c(28, 32, 33, 36, 42))  # This may fail or give unexpected results result <- match_couples(left, right, vars = \"age\") #> Error: #> ! Missing values (NA) not allowed in matching variables"},{"path":"https://gillescolling.com/couplr/articles/troubleshooting.html","id":"cause-4","dir":"Articles","previous_headings":"Missing Values in Data","what":"Cause","title":"Troubleshooting Guide","text":"couplr requires complete cases distance computation. NA values matching variables cause issues.","code":""},{"path":"https://gillescolling.com/couplr/articles/troubleshooting.html","id":"solutions-5","dir":"Articles","previous_headings":"Missing Values in Data","what":"Solutions","title":"Troubleshooting Guide","text":"1. Remove rows NA (matching): 2. Impute missing values: 3. Use preprocessing diagnose:","code":"left_clean <- left %>% filter(!is.na(age)) right_clean <- right %>% filter(!is.na(age))  result <- match_couples(left_clean, right_clean, vars = \"age\") cat(\"Matched\", result$info$n_matched, \"pairs (excluded 1 left unit with NA)\\n\") #> Matched 4 pairs (excluded 1 left unit with NA) # Simple mean imputation left_imputed <- left %>%   mutate(age = if_else(is.na(age), mean(age, na.rm = TRUE), age))  result <- match_couples(left_imputed, right, vars = \"age\") cat(\"Matched\", result$info$n_matched, \"pairs (imputed 1 NA with mean)\\n\") #> Matched 5 pairs (imputed 1 NA with mean) health <- preprocess_matching_vars(   left, right,   vars = \"age\" ) print(health) #> Preprocessing Result #> ==================== #>  #> Variables: 1 #> Scaling method: none"},{"path":[]},{"path":[]},{"path":"https://gillescolling.com/couplr/articles/troubleshooting.html","id":"symptom-6","dir":"Articles","previous_headings":"Installation Issues > C++ Compilation Errors","what":"Symptom","title":"Troubleshooting Guide","text":"","code":"Error in .Call(\"_couplr_assignment_impl\"): object not found Error: package 'couplr' was built under R version X.X"},{"path":"https://gillescolling.com/couplr/articles/troubleshooting.html","id":"cause-5","dir":"Articles","previous_headings":"Installation Issues > C++ Compilation Errors","what":"Cause","title":"Troubleshooting Guide","text":"C++ code compiled properly, object files stale.","code":""},{"path":"https://gillescolling.com/couplr/articles/troubleshooting.html","id":"solutions-6","dir":"Articles","previous_headings":"Installation Issues > C++ Compilation Errors","what":"Solutions","title":"Troubleshooting Guide","text":"1. Clean reinstall: 2. Clean compiled files (development): rebuild: 3. Check Rtools/compiler (Windows): Make sure Rtools installed PATH configured correctly.","code":"# In R: remove.packages(\"couplr\") install.packages(\"couplr\")  # Or from GitHub: devtools::install_github(\"gcol33/couplr\", force = TRUE) # PowerShell Remove-Item src\\*.o, src\\*.dll -Force # Bash rm src/*.o src/*.so devtools::clean_dll() devtools::load_all() # Check if Rtools is properly configured Sys.which(\"make\") #>                               make  #> \"C:\\\\rtools45\\\\usr\\\\bin\\\\make.exe\" Sys.which(\"g++\") #>                                          g++  #> \"C:\\\\rtools45\\\\X86_64~1.POS\\\\bin\\\\G__~1.EXE\""},{"path":[]},{"path":"https://gillescolling.com/couplr/articles/troubleshooting.html","id":"method_used-attribute-is-null","dir":"Articles","previous_headings":"Common Error Messages","what":"“method_used attribute is NULL”","title":"Troubleshooting Guide","text":"Cause: Result object wasn’t created properly. Solution: Use lap_solve() instead assignment() tidy interface.","code":""},{"path":"https://gillescolling.com/couplr/articles/troubleshooting.html","id":"cost-matrix-contains-non-finite-values","dir":"Articles","previous_headings":"Common Error Messages","what":"“Cost matrix contains non-finite values”","title":"Troubleshooting Guide","text":"Cause: NA NaN values cost matrix (Inf). Solution: Replace NA Inf forbidden assignments, remove rows/cols.","code":"cost <- matrix(c(1, NA, 3, 4), 2, 2) cost[is.na(cost)] <- Inf  # Mark as forbidden result <- lap_solve(cost)"},{"path":"https://gillescolling.com/couplr/articles/troubleshooting.html","id":"all-rows-assigned-to-inf-columns","dir":"Articles","previous_headings":"Common Error Messages","what":"“All rows assigned to Inf columns”","title":"Troubleshooting Guide","text":"Cause: Caliper strict; potential matches exceed threshold. Solution: Increase max_distance check overlap issues.","code":""},{"path":"https://gillescolling.com/couplr/articles/troubleshooting.html","id":"subscript-out-of-bounds","dir":"Articles","previous_headings":"Common Error Messages","what":"“subscript out of bounds”","title":"Troubleshooting Guide","text":"Cause: Empty left right data frame, ID mismatch. Solution: Check data dimensions ID column consistency.","code":"# Always verify data before matching stopifnot(nrow(left) > 0, nrow(right) > 0)"},{"path":"https://gillescolling.com/couplr/articles/troubleshooting.html","id":"getting-help","dir":"Articles","previous_headings":"","what":"Getting Help","title":"Troubleshooting Guide","text":"encounter issue covered : Check function documentation: ?match_couples, ?lap_solve Search GitHub issues: github.com/gcol33/couplr/issues Create minimal reproducible example: Open issue example github.com/gcol33/couplr/issues/new","code":"# Minimal example template library(couplr)  # Minimal data that reproduces the issue set.seed(123) left <- tibble(id = 1:10, x = rnorm(10)) right <- tibble(id = 1:10, x = rnorm(10))  # Code that causes the error result <- match_couples(left, right, vars = \"x\")  # Expected vs actual behavior # Expected: ... # Actual: [error message]  # Session info sessionInfo()"},{"path":"https://gillescolling.com/couplr/articles/troubleshooting.html","id":"see-also","dir":"Articles","previous_headings":"","what":"See Also","title":"Troubleshooting Guide","text":"vignette(\"getting-started\") - Basic usage vignette(\"matching-workflows\") - Production matching pipelines vignette(\"algorithms\") - Algorithm selection guide vignette(\"comparison\") - Comparison packages","code":""},{"path":"https://gillescolling.com/couplr/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Gilles Colling. Author, maintainer, copyright holder.","code":""},{"path":"https://gillescolling.com/couplr/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Colling G (2026). couplr: Optimal Pairing Matching via Linear Assignment. R package version 1.0.6, https://github.com/gcol33/couplr.","code":"@Manual{,   title = {couplr: Optimal Pairing and Matching via Linear Assignment},   author = {Gilles Colling},   year = {2026},   note = {R package version 1.0.6},   url = {https://github.com/gcol33/couplr}, }"},{"path":"https://gillescolling.com/couplr/CHANGELOG.html","id":null,"dir":"","previous_headings":"","what":"Changelog","title":"Changelog","text":"notable changes project documented file. format based Keep Changelog, project adheres Semantic Versioning.","code":""},{"path":[]},{"path":[]},{"path":"https://gillescolling.com/couplr/CHANGELOG.html","id":"matching-enhancements---step-1-automatic-scaling-and-preprocessing","dir":"","previous_headings":"1.0.0 - 2025-11-19 > Added","what":"Matching Enhancements - Step 1: Automatic Scaling and Preprocessing","title":"Changelog","text":"Automatic preprocessing auto_scale parameter match_couples() greedy_couples() Detects constant columns (SD = 0) excludes warning Detects nearly-constant columns (SD < threshold) warns Detects -NA columns excludes warning Detects high missingness (>50%) warns Detects extreme skewness (|skewness| > 2) provides info messages Returns detailed diagnostics including per-variable statistics Analyzes variable distributions detects outliers using IQR method Checks different scales across variables Recommends “robust”, “standardize”, “range”, “none” Uses median MAD (median absolute deviation) Resistant outliers skewed distributions Formula: (x - median) / MAD Binary variables → 0/1 encoding Ordered factors → numeric codes Error unordered categorical (requires Gower distance) Runs variable health checks Automatically excludes problematic variables Suggests applies scaling method Returns preprocessing result metadata Exported direct user access print.variable_health() - Pretty printing health diagnostics print.preprocessing_result() - Summary preprocessing results 10 comprehensive tests preprocessing functionality Example file examples/auto_scale_demo.R 5 demonstrations","code":""},{"path":"https://gillescolling.com/couplr/CHANGELOG.html","id":"matching-enhancements---step-2-balance-diagnostics","dir":"","previous_headings":"1.0.0 - 2025-11-19 > Added","what":"Matching Enhancements - Step 2: Balance Diagnostics","title":"Changelog","text":"Computes standardized differences (mean diff / pooled SD) Calculates variance ratios (SD_left / SD_right) Performs Kolmogorov-Smirnov tests distribution comparison Overall balance metrics (mean, max, % large imbalance) Per-block statistics quality ratings blocking used Counts matched unmatched units Works match_couples() greedy_couples() results Clean tabular output suitable reports publications Configurable decimal precision Internal function robust edge case handling Supports pooled group-specific SD Handles NA values, empty vectors, constant data Per-variable balance statistics Mean, SD, mean difference groups Standardized difference, variance ratio, KS statistic Matching summary (method, matched/unmatched counts) Variable-level balance table Overall balance assessment quality ratings Block-level statistics (blocking used) Interpretation guide standardized differences Excellent: |Std Diff| < 0.10 Good: |Std Diff| 0.10-0.25 Fair: |Std Diff| 0.25-0.50 Poor: |Std Diff| > 0.50 Unknown: edge cases (empty blocks, NA) 11 comprehensive tests balance diagnostics Basic balance diagnostics Comparing optimal vs greedy matching Balance blocking Detecting poor balance Extracting specific metrics Using balance tables publication","code":""},{"path":"https://gillescolling.com/couplr/CHANGELOG.html","id":"matching-enhancements---step-3-joined-matched-dataset-output","dir":"","previous_headings":"1.0.0 - 2025-11-19 > Added","what":"Matching Enhancements - Step 3: Joined Matched Dataset Output","title":"Changelog","text":"Automatically joins matched pairs original left right data Eliminates manual data wrangling matching Selectable variables via left_vars right_vars parameters Customizable suffixes disambiguating overlapping column names (default: _left, _right) Optional metadata columns: pair_id, distance, block_id Custom ID column support via left_id right_id parameters Clean column ordering: pair_id → left_id → right_id → distance → block_id → variables Works matching methods (optimal greedy) Preserves block information blocking used S3 method following broom package conventions Thin wrapper around join_matched() sensible defaults Integration tidymodels workflows Supports join_matched() parameters via ... Checks matching_result object type Validates data frame inputs Verifies ID column existence Confirms variable availability Validates suffix format (must length 2) Handles empty matching results informative warning Basic joining functionality Custom suffixes Variable selection Blocking integration Include/exclude options (distance, pair_id, block_id) Custom ID columns Input validation Empty matches Greedy matching compatibility augment() method Column ordering Basic treatment effect analysis Custom variable selection Matched analysis blocking Minimal output compact datasets Using augment() (broom-style) Greedy matching integration Custom ID columns Complete workflow balance diagnostics","code":""},{"path":"https://gillescolling.com/couplr/CHANGELOG.html","id":"matching-enhancements---step-4-precomputed-and-reusable-distances","dir":"","previous_headings":"1.0.0 - 2025-11-19 > Added","what":"Matching Enhancements - Step 4: Precomputed and Reusable Distances","title":"Changelog","text":"Precomputes distance matrix left right datasets Stores complete metadata (vars, distance metric, scaling, timestamps) Preserves original datasets seamless integration join_matched() Enables reuse across multiple matching operations Performance: ~60% faster trying multiple matching parameters Contains: cost_matrix, left/right IDs, block information, metadata, original datasets Works match_couples() greedy_couples() Can passed first parameter instead datasets Example: dist_obj <- compute_distances(left, right, vars); result <- match_couples(dist_obj) Apply new max_distance calipers without recomputing distances Creates new distance_object updated cost matrix Follows R’s copy--modify semantics Modified match_couples() signature: match_couples(left, right = NULL, vars = NULL, ...) Modified greedy_couples() signature: greedy_couples(left, right = NULL, vars = NULL, ...) Automatically detects distance_object routes specialized handlers 100% backward compatible existing code is_distance_object() - Type checking print.distance_object() - Informative summary distance statistics summary.distance_object() - Detailed statistics quantiles sparsity analysis match_couples_from_distance() - Handles optimal matching cached distances greedy_couples_from_distance() - Handles greedy matching cached distances","code":""},{"path":"https://gillescolling.com/couplr/CHANGELOG.html","id":"matching-enhancements---step-5-parallel-processing","dir":"","previous_headings":"1.0.0 - 2025-11-19 > Added","what":"Matching Enhancements - Step 5: Parallel Processing","title":"Changelog","text":"Distributes blocked matching across multiple cores using future package Automatic worker setup parallel = TRUE (uses availableCores() - 1) Custom plan support: pass plan name string (e.g., parallel = \"multisession\") Works optimal greedy matching strategies Graceful fallback sequential processing future packages unavailable setup_parallel() - Configure parallel backend auto-detection restore_parallel() - Restore original future plan execution can_parallelize() - Check future packages available parallel_lapply() - Unified parallel/sequential lapply interface match_blocks_parallel() - Parallel optimal matching across blocks greedy_blocks_parallel() - Parallel greedy matching across blocks Scales number blocks block size Best 10+ blocks 50+ units per block Speedup depends available cores problem complexity Minimal overhead small problems (automatic detection) Windows: multisession plan (separate R processes) Unix/Mac: multicore multisession plans Cluster: Distributed computing via future’s cluster plan Respects user-configured future plans Works seamlessly blocking (via block_id parameter) Compatible distance caching Step 4 Supports existing matching parameters Automatic plan restoration prevents side effects Basic parallel vs sequential comparison Custom parallel plan configuration Greedy matching parallelization parallel processing helps Combining parallel + distance caching Platform-specific plans Performance tips best practices","code":""},{"path":"https://gillescolling.com/couplr/CHANGELOG.html","id":"matching-enhancements---step-6-fun-error-messages-and-cost-checking","dir":"","previous_headings":"1.0.0 - 2025-11-19 > Added","what":"Matching Enhancements - Step 6: Fun Error Messages and Cost Checking","title":"Changelog","text":"Enabled default match_couples() greedy_couples() Detects common problems matching begins Can disabled check_costs = FALSE production code Light, memorable messages inspired testthat Themed around coupling, matching, pairing Less intimidating new users, memorable Clear actionable suggestions fixing problems 💔 errors (broken heart) 💌 warnings (love letter) 💬 info messages (speech balloon) 💖 success (sparkling heart) ✨ suggestions (sparkles) 🔍 search/investigation Automatically disabled non-interactive sessions couplr_stop() - Fun error messages emoji couplr_warn() - Fun warning messages couplr_inform() - Info messages couplr_success() - Success messages couplr_emoji() - Get themed emoji Specific error helpers: err_missing_data(), err_missing_vars(), err_no_valid_pairs(), etc. Specific warning helpers: warn_constant_var(), warn_many_zeros(), warn_extreme_costs(), etc. Detects many zero distances (>10%) - suggests checking duplicates Detects extreme cost ratios (99th percentile > 10x 95th) - suggests scaling Detects many forbidden pairs (>50%) - suggests relaxing constraints Detects constant distances - suggests checking variable informativeness Returns detailed diagnostic information Full analysis distance matrix quality Variable-specific problem detection Per-variable issue tracking (constant, extreme scale differences) Actionable suggestions improvements Quality rating: “good”, “fair”, “poor” Integrated match_couples_single(), match_couples_from_distance() Integrated greedy matching functions Warnings issued LAP solving catch problems early Backward compatible - tests pass check_costs enabled Basic friendly error messages Duplicate detection warnings Skewed distribution detection Overly strict constraints Constant variable detection valid pairs scenarios Distance matrix diagnostics Disabling cost checks Emoji control Balance quality messages","code":""},{"path":"https://gillescolling.com/couplr/CHANGELOG.html","id":"changed","dir":"","previous_headings":"1.0.0 - 2025-11-19","what":"Changed","title":"Changelog","text":"Updated DESCRIPTION include new matching features preprocess_matching_vars() balance_diagnostics() balance_table() join_matched() augment.matching_result() augment() generic compute_distances() is_distance_object() update_constraints() S3 print summary methods new classes match_couples(left, right = NULL, vars = NULL, ..., parallel = FALSE, check_costs = TRUE) - left can distance_object, parallel blocked matching, automatic cost checking greedy_couples(left, right = NULL, vars = NULL, ..., parallel = FALSE, check_costs = TRUE) - left can distance_object, parallel blocked matching, automatic cost checking Added future future.apply Suggests parallel processing support Updated error messages throughout package use fun, couple-themed helpers Added diagnose_distance_matrix() NAMESPACE exports","code":""},{"path":"https://gillescolling.com/couplr/CHANGELOG.html","id":"fixed","dir":"","previous_headings":"1.0.0 - 2025-11-19","what":"Fixed","title":"Changelog","text":"Greedy matching functions now properly exported via Rcpp interface Block statistics preserved correctly greedy_couples() return_diagnostics = FALSE Variable health checks now include required fields edge cases Variance ratio calculation handles NA values Block quality determination handles NA/NaN empty blocks Overall metrics handle -NA standardized differences","code":""},{"path":"https://gillescolling.com/couplr/CHANGELOG.html","id":"documentation","dir":"","previous_headings":"1.0.0 - 2025-11-19","what":"Documentation","title":"Changelog","text":"Added IMPLEMENTATION_STEP1.md documenting preprocessing implementation Added IMPLEMENTATION_STEP2.md documenting balance diagnostics implementation Updated Roxygen documentation new functions Created comprehensive examples demonstrating new features functions complete parameter descriptions return value documentation","code":""},{"path":"https://gillescolling.com/couplr/CHANGELOG.html","id":"tests","dir":"","previous_headings":"1.0.0 - 2025-11-19","what":"Tests","title":"Changelog","text":"Total: 1382 tests passing (1365) Added 10 tests preprocessing (Step 1) Added 11 tests balance diagnostics (Step 2) Added 13 tests joined dataset output (Step 3) existing tests continue pass warnings errors Variable health detection (constant, -NA, high missingness, skewness) Scaling suggestion Preprocessing integration Standardized difference calculation Balance diagnostics simple blocked matching Balance table formatting Joined dataset creation Variable selection suffix handling Custom ID columns Broom-style augment method Print methods Input validation Edge case handling","code":""},{"path":"https://gillescolling.com/couplr/CHANGELOG.html","id":"backward-compatibility","dir":"","previous_headings":"1.0.0 - 2025-11-19","what":"Backward Compatibility","title":"Changelog","text":"100% backward compatible new parameters default FALSE previous behavior breaking changes existing APIs existing code continues work unchanged Return structures extended, replaced","code":""},{"path":"https://gillescolling.com/couplr/CHANGELOG.html","id":"id_010---previous-release","dir":"","previous_headings":"","what":"0.1.0 - Previous Release","title":"Changelog","text":"Initial release core LAP solving functionality, basic matching, pixel morphing.","code":""},{"path":"https://gillescolling.com/couplr/CLAUDE.html","id":null,"dir":"","previous_headings":"","what":"CLAUDE.md","title":"CLAUDE.md","text":"file provides guidance Claude Code (claude.ai/code) working code repository.","code":""},{"path":"https://gillescolling.com/couplr/CLAUDE.html","id":"project-overview","dir":"","previous_headings":"","what":"Project Overview","title":"CLAUDE.md","text":"couplr (formerly lapr) R package solving Linear Assignment Problems (LAP) production-ready matching workflows. package combines: 20 LAP algorithms - Hungarian, Jonker-Volgenant, Auction (3 variants), Network Simplex, Orlin-Ahuja, Push-Relabel, Greedy matching - Fast approximate algorithms large-scale problems Automatic preprocessing - Smart scaling, variable health checks, categorical encoding Balance diagnostics - Standardized differences, variance ratios, KS tests Distance caching - Reusable precomputed distances faster experimentation Parallel processing - Distributed block matching via future framework Joined datasets - Analysis-ready merged output broom-style interface Current version: 1.0.0 | Tests: 1382 passing | License: MIT","code":""},{"path":[]},{"path":"https://gillescolling.com/couplr/CLAUDE.html","id":"system-configuration-windows","dir":"","previous_headings":"Development Commands","what":"System Configuration (Windows)","title":"CLAUDE.md","text":"","code":"# R paths \"C:\\Program Files\\R\\R-4.5.2\\bin\\Rscript.exe\" script.R \"C:\\Program Files\\R\\R-4.5.2\\bin\\Rscript.exe\" -e \"command\""},{"path":"https://gillescolling.com/couplr/CLAUDE.html","id":"core-package-development","dir":"","previous_headings":"Development Commands","what":"Core Package Development","title":"CLAUDE.md","text":"","code":"devtools::load_all()           # Load package (recompiles C++ if needed) devtools::test()               # Run all 1382 tests devtools::test(filter = \"matching\")  # Run specific tests devtools::document()           # Build documentation devtools::check()              # Full package check"},{"path":"https://gillescolling.com/couplr/CLAUDE.html","id":"c-development-workflow","dir":"","previous_headings":"Development Commands","what":"C++ Development Workflow","title":"CLAUDE.md","text":"modifying C++ code adding [[Rcpp::export]] functions: Critical: C++17 required. Windows: Rtools g++ supporting C++17. Troubleshooting:","code":"Rcpp::compileAttributes()  # REQUIRED after C++ changes devtools::document() devtools::load_all() devtools::test() Remove-Item src\\*.o, src\\*.dll -Force  # Clean stale object files R CMD INSTALL --clean ."},{"path":"https://gillescolling.com/couplr/CLAUDE.html","id":"building-the-pkgdown-website","dir":"","previous_headings":"Development Commands","what":"Building the pkgdown Website","title":"CLAUDE.md","text":"build script runs pkgdown::build_site() post-processes SVGs dark mode support. Key files: build_site.R, pkgdown/extra.css, _pkgdown.yml Theme colors (Sandstone Bootstrap 5): - Light: bg=#F5F6F8, border=#DFD7CA, text=#3E3F3A - Dark: bg=#343739, border=#495057, text=#DFD7CA","code":"\"C:\\Program Files\\R\\R-4.5.2\\bin\\Rscript.exe\" build_site.R"},{"path":[]},{"path":"https://gillescolling.com/couplr/CLAUDE.html","id":"three-layer-api-design","dir":"","previous_headings":"Code Architecture","what":"Three-Layer API Design","title":"CLAUDE.md","text":"Layer 1 - Low-level LAP solvers (R/assignment.R): - assignment() - Core solver returning list(match, total_cost, status, method_used) - Method auto-selection via method = \"auto\" Layer 2 - Tidy LAP interface (R/lap_solve.R): - lap_solve() - Returns tibble tidy output - lap_solve_batch(), lap_solve_kbest() batch/k-best solving Layer 3 - Matching workflows: - match_couples() - Optimal one--one matching (R/matching_core.R) - greedy_couples() - Fast greedy matching (3 strategies) - matchmaker() - Blocking/stratification (R/matching_blocks.R) - balance_diagnostics() - Balance assessment (R/matching_diagnostics.R) - preprocess_matching_vars() - Variable health checks (R/matching_preprocessing.R) - compute_distances() - Distance caching (R/matching_distance_cache.R) - join_matched() - Merged datasets (R/matching_join.R)","code":""},{"path":"https://gillescolling.com/couplr/CLAUDE.html","id":"core-matching-workflow","dir":"","previous_headings":"Code Architecture","what":"Core Matching Workflow","title":"CLAUDE.md","text":"","code":"# 1. Optional: Create blocks blocks <- matchmaker(left, right, block_type = \"group\", block_by = \"site\")  # 2. Match with preprocessing result <- match_couples(   left, right,   vars = c(\"age\", \"income\", \"education\"),   auto_scale = TRUE, scale = \"robust\", max_distance = 0.5 )  # 3. Assess balance balance <- balance_diagnostics(result, left, right, vars) balance_table(balance)  # Publication-ready"},{"path":"https://gillescolling.com/couplr/CLAUDE.html","id":"r-file-structure-20-files","dir":"","previous_headings":"Code Architecture","what":"R File Structure (20 files)","title":"CLAUDE.md","text":"","code":"R/ ├── couplr-package.R, data.R, zzz.R, RcppExports.R, utils.R ├── LAP: lap_solve.R, lap_solve_batch.R, lap_solve_kbest.R ├── Matching: matching_core.R (625 lines), matching_distance.R, │   matching_distance_cache.R, matching_constraints.R, matching_blocks.R, │   matching_parallel.R, matching_utils.R, matching_messages.R ├── Analysis: matching_preprocessing.R (510), matching_diagnostics.R (461), │   matching_join.R (220) └── Morphing: morph_pixel.R, morph_tiling.R, morph_utils.R"},{"path":"https://gillescolling.com/couplr/CLAUDE.html","id":"key-matching-features","dir":"","previous_headings":"Code Architecture","what":"Key Matching Features","title":"CLAUDE.md","text":"Automatic Preprocessing - Detects constant vars (excludes), high missingness (warns), extreme skewness (info). Scaling: “robust” (MAD), “standardize” (SD), “range”. Categorical encoding binary/ordered factors. Greedy Algorithms - sorted (sort pairs, assign), row_best (row--row), pq (priority queue). 10-100x faster optimal. Balance Diagnostics - Standardized differences, variance ratios, KS tests. Thresholds: <0.1 excellent, 0.1-0.25 good, 0.25-0.5 acceptable, >0.5 poor. Blocking - Exact: block_type = \"group\" + block_by. K-means: block_type = \"cluster\" + n_clusters.","code":""},{"path":"https://gillescolling.com/couplr/CLAUDE.html","id":"c-code-organization","dir":"","previous_headings":"Code Architecture","what":"C++ Code Organization","title":"CLAUDE.md","text":"Naming Convention: - *.cpp - Pure C++ implementation (Rcpp dependencies) - *_rcpp.cpp - Rcpp wrapper (R bindings) - *.h - Pure C++ header - *_rcpp.h - Rcpp-dependent header (e.g., lap_utils_rcpp.h) Export Pattern (CRITICAL): Subdirectory files use [[Rcpp::export]] directly: Pure C++ implementation solve_foo.cpp solve_foo_impl() function Thin Rcpp wrapper solve_foo_rcpp.cpp calling impl Forward declaration [[Rcpp::export]] wrapper rcpp_interface.cpp : Rcpp scans root src/*.cpp files.","code":"src/ ├── core/: lap_utils.cpp/.h (pure C++), lap_utils_rcpp.cpp/.h (Rcpp), lap_internal.h ├── interface/: prepare_cost_matrix.cpp ├── solvers/ (20+ files): solve_jv.cpp (impl) + solve_jv_rcpp.cpp (wrapper), │   solve_hungarian.cpp/rcpp.cpp, solve_auction.cpp/rcpp.cpp, etc. ├── solvers/network_simplex/: solve_network_simplex.cpp/rcpp.cpp, ns_*.h ├── solvers/orlin_ahuja/: orlin_solve.cpp/rcpp.cpp, orlin_*.h ├── gabow_tarjan/: solve_gabow_tarjan.cpp, utils_gabow_tarjan.cpp/.h ├── morph/: morph_pixel_level.cpp ├── rcpp_interface.cpp  # ALL [[Rcpp::export]] declarations └── RcppExports.cpp     # Auto-generated, DO NOT EDIT"},{"path":"https://gillescolling.com/couplr/CLAUDE.html","id":"lap-algorithms","dir":"","previous_headings":"Code Architecture","what":"LAP Algorithms","title":"CLAUDE.md","text":"Optimal solvers (20 methods): - jv - Jonker-Volgenant (general, fast) - hungarian - Classic Hungarian - auction / auction_gs / auction_scaled - Auction variants - ssp / sap - Shortest augmenting path - csflow - Cost-scaling flow - csa - Goldberg-Kennedy cost-scaling (often fastest medium-large) - cycle_cancel - Cycle canceling Karp - gabow_tarjan - Complementary slackness - ssap_bucket - Dial’s algorithm (integer costs) - lapmod - Sparse JV variant (>50% forbidden entries) - network_simplex - Network simplex spanning tree - orlin - Orlin-Ahuja O(sqrt(n) * m * log(nC)) - push_relabel - Push-relabel max-flow based - ramshaw_tarjan - Optimized rectangular matrices - hk01 - Hopcroft-Karp (binary/uniform costs) - line_metric - 1D matching O(n log n) - bruteforce - Exhaustive (n ≤ 8) - auto - Automatic selection based problem characteristics Greedy approximations: - greedy_sorted / greedy_row_best / greedy_pq - 10-100x faster optimal Specialized functions: - assignment_duals() - Returns dual variables (u, v) sensitivity analysis - bottleneck_assignment() - Minimize maximum edge cost (minimax) - sinkhorn() - Entropy-regularized optimal transport (soft assignment)","code":""},{"path":"https://gillescolling.com/couplr/CLAUDE.html","id":"testing","dir":"","previous_headings":"","what":"Testing","title":"CLAUDE.md","text":"CRITICAL: Test files MUST tests/testthat/ ❌ Test files package root tests/ directly IGNORED devtools::test()","code":"tests/ ├── testthat.R           # Test runner └── testthat/            # ALL test files here     ├── test-matching.R  # 98 matching tests     ├── test-assignment-*.R  # 20+ solver test files     └── test-*.R devtools::test()                    # Run all devtools::test(filter = \"matching\") # Filter testthat::test_file(\"tests/testthat/test-matching.R\")  # Specific file"},{"path":[]},{"path":"https://gillescolling.com/couplr/CLAUDE.html","id":"indexing","dir":"","previous_headings":"Important Conventions","what":"Indexing","title":"CLAUDE.md","text":"R: 1-based | C++: 0-based (convert boundaries) Unmatched: -1 (C++) / 0 NA (R)","code":""},{"path":"https://gillescolling.com/couplr/CLAUDE.html","id":"matrix-orientation","dir":"","previous_headings":"Important Conventions","what":"Matrix Orientation","title":"CLAUDE.md","text":"Rows = left/treatment, Cols = right/control Auto-transpose rows > cols","code":""},{"path":"https://gillescolling.com/couplr/CLAUDE.html","id":"cost-matrix","dir":"","previous_headings":"Important Conventions","what":"Cost Matrix","title":"CLAUDE.md","text":"NA Inf = forbidden assignment maximize = TRUE negates internally, returns original scale","code":""},{"path":"https://gillescolling.com/couplr/CLAUDE.html","id":"return-values","dir":"","previous_headings":"Important Conventions","what":"Return Values","title":"CLAUDE.md","text":"LAP Solvers: Matching Functions: Balance Diagnostics:","code":"list(match = integer, total_cost = numeric, status = \"optimal\", method_used = \"name\") list(   pairs = tibble(left_id, right_id, distance, block_id),   info = list(method, strategy, n_matched, total_distance, n_blocks),   # If return_diagnostics = TRUE:   left_unmatched, right_unmatched, cost_matrix, distance_info ) list(var_stats = tibble(...), overall = list(...), n_matched, has_blocks, block_stats)"},{"path":[]},{"path":"https://gillescolling.com/couplr/CLAUDE.html","id":"new-lap-solver","dir":"","previous_headings":"Adding New Functionality","what":"New LAP Solver","title":"CLAUDE.md","text":"Create src/solvers/solve_foo.cpp - Pure C++ implementation solve_foo_impl() Create src/solvers/solve_foo.h - Header declaring impl function Create src/solvers/solve_foo_rcpp.cpp - Thin Rcpp wrapper calling impl Forward declare src/rcpp_interface.cpp Add [[Rcpp::export]] wrapper src/rcpp_interface.cpp Update src/Makevars src/Makevars.win new source files Run Rcpp::compileAttributes() Add case assignment() (R/assignment.R) Create tests/testthat/test-assignment-foo.R Run devtools::document()","code":""},{"path":"https://gillescolling.com/couplr/CLAUDE.html","id":"matching-features","dir":"","previous_headings":"Adding New Functionality","what":"Matching Features","title":"CLAUDE.md","text":"Preprocessing: Edit R/matching_preprocessing.R Diagnostics: Edit R/matching_diagnostics.R New algorithms: C++ src/solvers/, export via rcpp_interface.cpp, R wrapper R/matching_core.R","code":""},{"path":"https://gillescolling.com/couplr/CLAUDE.html","id":"common-pitfalls","dir":"","previous_headings":"","what":"Common Pitfalls","title":"CLAUDE.md","text":"Forgetting Rcpp::compileAttributes() - “find function” errors Exporting subdirectories - DON’T put [[Rcpp::export]] src/solvers/*.cpp Test files wrong location - Must tests/testthat/ 0-based vs 1-based indexing - Convert R/C++ boundary Rectangular matrices - Test nrow != ncol NA/Inf costs - Test forbidden edges Package name - OLD: lapr, NEW: couplr Stale object files - Clean Remove-Item src\\*.o, src\\*.dll -Force","code":""},{"path":[]},{"path":"https://gillescolling.com/couplr/CLAUDE.html","id":"pixel-morphing","dir":"","previous_headings":"Special Notes","what":"Pixel Morphing","title":"CLAUDE.md","text":"Modes: exact (< 4096 pixels), color_walk (quantization + LAPs), recursive (2×2 tiling) CRITICAL: Assignment uses images B. Renderer uses ’s colors. B influences pixels go, colors.","code":""},{"path":"https://gillescolling.com/couplr/CLAUDE.html","id":"cost-computation","dir":"","previous_headings":"Special Notes","what":"Cost Computation","title":"CLAUDE.md","text":"solvers MUST use compute_total_cost() src/core/lap_utils.cpp. Never compute transformed matrices.","code":""},{"path":"https://gillescolling.com/couplr/CLAUDE.html","id":"backward-compatibility","dir":"","previous_headings":"Special Notes","what":"Backward Compatibility","title":"CLAUDE.md","text":"v1.0.0 100% backward compatible. new parameters default previous behavior.","code":""},{"path":"https://gillescolling.com/couplr/CLAUDE.html","id":"package-dependencies","dir":"","previous_headings":"","what":"Package Dependencies","title":"CLAUDE.md","text":"Required: R ≥ 3.5.0, C++17, Rcpp, RcppEigen, tibble, dplyr, rlang, purrr, magrittr Optional: testthat, knitr, rmarkdown, bench, future, future.apply, magick, png","code":""},{"path":[]},{"path":"https://gillescolling.com/couplr/CLAUDE.html","id":"basic-matching","dir":"","previous_headings":"Quick Reference Workflows","what":"Basic Matching","title":"CLAUDE.md","text":"","code":"result <- match_couples(left, right, vars = c(\"age\", \"income\"), auto_scale = TRUE) balance <- balance_diagnostics(result, left, right, vars) data <- join_matched(result, left, right)"},{"path":"https://gillescolling.com/couplr/CLAUDE.html","id":"greedy-large-data","dir":"","previous_headings":"Quick Reference Workflows","what":"Greedy (Large Data)","title":"CLAUDE.md","text":"","code":"result <- greedy_couples(left, right, vars, strategy = \"row_best\", auto_scale = TRUE)"},{"path":"https://gillescolling.com/couplr/CLAUDE.html","id":"blocking","dir":"","previous_headings":"Quick Reference Workflows","what":"Blocking","title":"CLAUDE.md","text":"","code":"blocks <- matchmaker(left, right, block_type = \"group\", block_by = \"site\") result <- match_couples(left, right, vars, block_id = blocks$block_id, parallel = TRUE)"},{"path":"https://gillescolling.com/couplr/CLAUDE.html","id":"distance-caching","dir":"","previous_headings":"Quick Reference Workflows","what":"Distance Caching","title":"CLAUDE.md","text":"","code":"dist_obj <- compute_distances(left, right, vars, scale = \"robust\") result1 <- match_couples(dist_obj, max_distance = 0.3) result2 <- match_couples(dist_obj, max_distance = 0.5)"},{"path":"https://gillescolling.com/couplr/CLAUDE.html","id":"lap-solving","dir":"","previous_headings":"Quick Reference Workflows","what":"LAP Solving","title":"CLAUDE.md","text":"info: browseVignettes(\"couplr\") | ?match_couples | https://github.com/gcol33/couplr/issues","code":"cost <- matrix(c(1,2,3,4,5,6,7,8,9), nrow = 3) result <- lap_solve(cost, method = \"auto\")"},{"path":[]},{"path":"https://gillescolling.com/couplr/CODE_OF_CONDUCT.html","id":"our-pledge","dir":"","previous_headings":"","what":"Our Pledge","title":"Code of Conduct","text":"aim maintain open, friendly, professional environment within couplr project. Everyone taking part (contributors, maintainers, users) feel welcome respected, regardless background, identity, experience level.","code":""},{"path":"https://gillescolling.com/couplr/CODE_OF_CONDUCT.html","id":"our-standards","dir":"","previous_headings":"","what":"Our Standards","title":"Code of Conduct","text":"Examples behavior helps create good environment: Communicating clearly respectfully open different opinions approaches Offering constructive feedback Helping others learn contribute Staying focused collaboration shared goals Examples behavior acceptable: Personal attacks insulting language Disrespectful dismissive comments Sharing private information without consent form harassment hostility toward others","code":""},{"path":"https://gillescolling.com/couplr/CODE_OF_CONDUCT.html","id":"responsibilities","dir":"","previous_headings":"","what":"Responsibilities","title":"Code of Conduct","text":"Project maintainers responsible clarifying standards acceptable behavior taking fair action necessary. may edit, remove, reject contributions violate Code Conduct disrupt collaboration.","code":""},{"path":"https://gillescolling.com/couplr/CODE_OF_CONDUCT.html","id":"scope","dir":"","previous_headings":"","what":"Scope","title":"Code of Conduct","text":"Code Conduct applies project spaces, including discussions, issues, pull requests, community interactions related couplr.","code":""},{"path":"https://gillescolling.com/couplr/CODE_OF_CONDUCT.html","id":"enforcement","dir":"","previous_headings":"","what":"Enforcement","title":"Code of Conduct","text":"experience witness behavior violates Code Conduct, please contact maintainer privately. Reports handled discretion, maintainers take appropriate action needed.","code":""},{"path":"https://gillescolling.com/couplr/CODE_OF_CONDUCT.html","id":"attribution","dir":"","previous_headings":"","what":"Attribution","title":"Code of Conduct","text":"Code Conduct adapted Contributor Covenant, version 2.1, simplified better fit tone open scientific software project. Contact: gilles.colling051@gmail.com","code":""},{"path":"https://gillescolling.com/couplr/CONTRIBUTING.html","id":null,"dir":"","previous_headings":"","what":"Contribution Guidelines","title":"Contribution Guidelines","text":"First , thank much taking time contribute couplr project! document provides guidelines contributing couplr—codebase documentation. guidelines meant guide , restrict . doubt, use best judgment feel free propose improvements issue pull request.","code":""},{"path":"https://gillescolling.com/couplr/CONTRIBUTING.html","id":"table-of-contents","dir":"","previous_headings":"","what":"Table Of Contents","title":"Contribution Guidelines","text":"Code Conduct Obtaining source Setting R environment Installing source Testing Install dependencies Building documentation Design docs Project organization Contributing workflow Style guidelines Pull request checklist Reporting bugs","code":""},{"path":"https://gillescolling.com/couplr/CONTRIBUTING.html","id":"code-of-conduct","dir":"","previous_headings":"","what":"Code of Conduct","title":"Contribution Guidelines","text":"project everyone participating governed Code Conduct (CODE_OF_CONDUCT.md). participating, expected uphold code maintain respectful, inclusive environment.","code":""},{"path":"https://gillescolling.com/couplr/CONTRIBUTING.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Contribution Guidelines","text":"installation guide focused development. regular installation, please see README.","code":""},{"path":"https://gillescolling.com/couplr/CONTRIBUTING.html","id":"obtaining-the-source","dir":"","previous_headings":"Installation","what":"Obtaining the source","title":"Contribution Guidelines","text":"Clone couplr repository: work development branch:","code":"git clone https://github.com/gcol33/couplr.git cd couplr git checkout dev git pull origin dev"},{"path":"https://gillescolling.com/couplr/CONTRIBUTING.html","id":"setting-up-your-r-environment","dir":"","previous_headings":"Installation","what":"Setting up your R environment","title":"Contribution Guidelines","text":"couplr R package uses C++ code via Rcpp RcppEigen. Install required tools R (≥ 3.5.0) Rtools (Windows) Xcode Command Line Tools (macOS) Git editor IDE (RStudio, VS Code, etc.) Install development dependencies Load development build","code":"install.packages(c(\"devtools\", \"roxygen2\", \"testthat\", \"rmarkdown\", \"knitr\", \"pkgdown\", \"Rcpp\", \"RcppEigen\")) devtools::load_all()"},{"path":"https://gillescolling.com/couplr/CONTRIBUTING.html","id":"installing-from-source","dir":"","previous_headings":"Installation","what":"Installing from source","title":"Contribution Guidelines","text":"Build install package locally: modify C++ code, rebuild DLL reinstalling: Regenerate documentation : modifying C++ code adding [[Rcpp::export]] functions:","code":"devtools::install() devtools::clean_dll() devtools::install() devtools::document() Rcpp::compileAttributes() devtools::document() devtools::load_all()"},{"path":"https://gillescolling.com/couplr/CONTRIBUTING.html","id":"testing","dir":"","previous_headings":"","what":"Testing","title":"Contribution Guidelines","text":"couplr uses testthat testing. tests located tests/testthat/. Run full test suite: Run complete package check: Run subset tests development: Guidelines: - Keep tests fast reproducible. - Use set.seed() random data. - Include edge cases expected failures. - Prefer small examples large datasets.","code":"devtools::test() devtools::check() testthat::test_dir(\"tests/testthat\") testthat::test_file(\"tests/testthat/test-matching.R\")"},{"path":[]},{"path":"https://gillescolling.com/couplr/CONTRIBUTING.html","id":"install-dependencies","dir":"","previous_headings":"Documentation","what":"Install dependencies","title":"Contribution Guidelines","text":"","code":"install.packages(c(\"rmarkdown\", \"knitr\", \"pkgdown\"))"},{"path":"https://gillescolling.com/couplr/CONTRIBUTING.html","id":"building-the-documentation","dir":"","previous_headings":"Documentation","what":"Building the documentation","title":"Contribution Guidelines","text":"Build vignettes: Build pkgdown site locally: generated site saved docs/ directory. Open docs/index.html browser view .","code":"devtools::build_vignettes() pkgdown::build_site()"},{"path":"https://gillescolling.com/couplr/CONTRIBUTING.html","id":"design-of-the-docs","dir":"","previous_headings":"Documentation","what":"Design of the docs","title":"Contribution Guidelines","text":"Function documentation: man/ (generated roxygen2) Tutorials examples: vignettes/ Website configuration: _pkgdown.yml Package overview: README.md Changelog: NEWS.md","code":""},{"path":"https://gillescolling.com/couplr/CONTRIBUTING.html","id":"project-organization","dir":"","previous_headings":"","what":"Project organization","title":"Contribution Guidelines","text":"","code":"couplr/ ├── .github/                <- Continuous integration workflows ├── .gitignore ├── .Rbuildignore ├── couplr.Rproj ├── DESCRIPTION             <- Package metadata ├── NAMESPACE               <- Function exports and imports ├── LICENSE ├── LICENSE.md ├── NEWS.md ├── README.md ├── _pkgdown.yml ├── R/                      <- R source files ├── src/                    <- C++ source files (Rcpp/RcppEigen) │   ├── core/               <- Core utilities │   ├── solvers/            <- LAP algorithm implementations │   └── rcpp_interface.cpp  <- All [[Rcpp::export]] declarations ├── man/                    <- Generated documentation ├── inst/                   <- Installed files (e.g., CITATION, extdata) ├── vignettes/              <- Long-form documentation and usage examples ├── tests/ │   └── testthat/           <- Unit tests ├── docs/                   <- pkgdown website (generated) ├── doc/                    <- Built vignettes for local preview (ignored in Git) ├── Meta/                   <- Metadata created during package build (ignored) └── couplr.Rcheck/          <- Artifacts from local package checks (ignored)"},{"path":"https://gillescolling.com/couplr/CONTRIBUTING.html","id":"contributing-workflow","dir":"","previous_headings":"","what":"Contributing workflow","title":"Contribution Guidelines","text":"Create feature branch Make focused commits clear messages. Run tests checks committing: Update documentation roxygen2 NEWS.md. Update vignettes/examples user-facing behavior changes. Open pull request short description change. Respond review feedback constructively.","code":"git checkout -b feature/my-feature devtools::test() devtools::check()"},{"path":[]},{"path":"https://gillescolling.com/couplr/CONTRIBUTING.html","id":"r-code","dir":"","previous_headings":"Style guidelines","what":"R code","title":"Contribution Guidelines","text":"Use descriptive names consistent indentation. Prefer vectorized operations loops. Validate inputs early clear error messages. Document exported functions roxygen2.","code":""},{"path":"https://gillescolling.com/couplr/CONTRIBUTING.html","id":"c-code","dir":"","previous_headings":"Style guidelines","what":"C++ code","title":"Contribution Guidelines","text":"C++17 required. Keep headers minimal separate interface implementation. Use RAII possible. Comment algorithmic details numerical behavior. Avoid unnecessary memory allocations. Export pattern: put [[Rcpp::export]] subdirectory files. Instead, create _impl functions subdirectories add exported wrappers src/rcpp_interface.cpp.","code":""},{"path":"https://gillescolling.com/couplr/CONTRIBUTING.html","id":"tests","dir":"","previous_headings":"Style guidelines","what":"Tests","title":"Contribution Guidelines","text":"Add update tests functionality changes. Keep tests minimal reproducible. Avoid external dependencies unless essential.","code":""},{"path":"https://gillescolling.com/couplr/CONTRIBUTING.html","id":"pull-request-checklist","dir":"","previous_headings":"","what":"Pull request checklist","title":"Contribution Guidelines","text":"Tests pass (devtools::test() devtools::check()) Documentation updated (roxygen + NEWS.md) Vignettes/examples updated needed unrelated formatting changes PR description clearly explains change","code":""},{"path":"https://gillescolling.com/couplr/CONTRIBUTING.html","id":"reporting-bugs","dir":"","previous_headings":"","what":"Reporting bugs","title":"Contribution Guidelines","text":"reporting issue, please include: - minimal reproducible example (reprex) - Output sessionInfo() - Expected vs. actual results - Method/algorithm used relevant - R operating system version - Toolchain info relevant (e.g., Rtools Windows) contributing couplr, agree code released license package.","code":""},{"path":"https://gillescolling.com/couplr/copilot-instructions.html","id":null,"dir":"","previous_headings":"","what":"Quick Orientation","title":"Quick Orientation","text":"repository R package (couplr, formerly lapr) provides linear-assignment solvers, optimal matching workflows, image “pixel morphing” helpers. project mixes R (high-level API, data handling, vignettes/tests) C++ (many solver implementations, Rcpp exports, image routines). Key design points AI agents know: - R user-facing API: see R/assignment.R (method selection) R/lap_solve.R (tidy wrappers). - C++ implements algorithms: look src/ (many solve_*.cpp) unified interface src/rcpp_interface.cpp. - Exported C++ functions use lap_ prefix (e.g. lap_solve_jv, lap_solve_hungarian) called R via generated RcppExports.R. - Image/pixel utilities implemented C++ called R (see R/pixel_morph.R exports rcpp_interface.cpp).","code":""},{"path":"https://gillescolling.com/couplr/copilot-instructions.html","id":"files-to-reference-when-making-changes","dir":"","previous_headings":"","what":"Files to reference when making changes","title":"Quick Orientation","text":"R/assignment.R — central auto-selection logic assignment() wrapper. Add new solver names . R/lap_solve.R — tidy user-facing functions, grouped-data handling printing conventions. src/rcpp_interface.cpp — declare/export C++ entry points. New C++ solver impls must exposed . src/solve_*.cpp — algorithm implementations (one file per solver). R/RcppExports.R — autogenerated wrappers (.Call). edit manually; regenerate via Rcpp::compileAttributes() adding exports. DESCRIPTION — package metadata, imports (Rcpp, RcppEigen) SystemRequirements: C++17.","code":""},{"path":"https://gillescolling.com/couplr/copilot-instructions.html","id":"build--test--debug-workflows-windows-notes","dir":"","previous_headings":"","what":"Build / test / debug workflows (Windows notes)","title":"Quick Orientation","text":"Prerequisites: R (see DESCRIPTION), dev packages (Rcpp, RcppEigen, devtools/remotes) C++ toolchain (Rtools Windows) supporting C++17. normal shell / Powershell: R CMD INSTALL --build . R: devtools::install(build = TRUE) (requires devtools). R CMD build . R CMD check <tarball> R: devtools::check() devtools::test() (uses testthat, parallel configured DESCRIPTION). encounter strange binary mismatches, remove committed build artefacts reinstalling: Remove-Item src\\*.o, src\\*.dll -Force (Powershell) simply run R CMD INSTALL --clean ..","code":""},{"path":"https://gillescolling.com/couplr/copilot-instructions.html","id":"conventions--patterns-to-follow","dir":"","previous_headings":"","what":"Conventions & patterns to follow","title":"Quick Orientation","text":"Naming: R-facing solver wrappers use lap_solve_<name> C++ method strings R map via assignment() (see switch() R/assignment.R). 0/1-based indexing: R uses 1-based assignment vectors; many C++ internals use 0-based. Conversions happen RcppExports.R / rcpp_interface.cpp — preserve conversions. Forbidden edges: NA Inf cost matrix marks forbidden assignments. assignment() converts inputs relies prepare_cost_matrix C++ masking. Add src/solve_<name>.cpp implementing algorithm. Declare impl function prototype src/rcpp_interface.cpp implement exported wrapper // [[Rcpp::export]] named lap_solve_<name>. Run Rcpp::compileAttributes() (regenerates R/RcppExports.R src/RcppExports.cpp). Wire method string R/assignment.R’s switch() add documentation.","code":""},{"path":"https://gillescolling.com/couplr/copilot-instructions.html","id":"pixel-morph-specifics","dir":"","previous_headings":"","what":"Pixel morph specifics","title":"Quick Orientation","text":"R/pixel_morph.R orchestrates pixel-level operations calls several C++ helpers (e.g. compute_pixel_cost_cpp, morph_pixel_level_cpp). C++ image exports expect vectors length H * W * 3 perform strict validation; keep argument shapes type checks modifying paths. Assignment semantics: rendering C++ expects 0-based assignment indices; R returns 1-based vectors callers. Check conversions around assign_0based + 1L R/pixel_morph.R.","code":""},{"path":"https://gillescolling.com/couplr/copilot-instructions.html","id":"dependencies--environment","dir":"","previous_headings":"","what":"Dependencies & environment","title":"Quick Orientation","text":"Declared DESCRIPTION: Rcpp, RcppEigen, tibble, dplyr, rlang, purrr, magrittr, many Suggests (testthat, knitr, magick…). Ensure required system libs Rtools (Windows) available compilation.","code":""},{"path":"https://gillescolling.com/couplr/copilot-instructions.html","id":"common-pitfalls-to-avoid","dir":"","previous_headings":"","what":"Common pitfalls to avoid","title":"Quick Orientation","text":"manually edit auto-generated files: R/RcppExports.R src/RcppExports.cpp created Rcpp::compileAttributes(). src/ directory contains committed object files (*.o, *.dll); can stale. Clean building behavior unexpected. Keep method strings R/assignment.R exported lap_ C++ names sync.","code":""},{"path":"https://gillescolling.com/couplr/copilot-instructions.html","id":"example-quick-tasks-for-an-ai-code-agent","dir":"","previous_headings":"","what":"Example quick tasks for an AI code agent","title":"Quick Orientation","text":"Add new solver: follow “Adding new C++ solver” steps add documentation man/ via roxygen comments. Improve auto-selection heuristics: modify R/assignment.R::method == 'auto' heuristics add tests tests/ demonstrating expected selection small/sparse/dense inputs.","code":""},{"path":[]},{"path":"https://gillescolling.com/couplr/copilot-instructions.html","id":"critical-no-fabricated-data","dir":"","previous_headings":"","what":"CRITICAL: No Fabricated Data","title":"Quick Orientation","text":"Never include made-numbers, benchmarks, outputs documentation examples. ❌ fabricate benchmark results ❌ invent example outputs ❌ guess performance numbers ✅ Run actual code get real results ✅ Ask maintainers need benchmark data ✅ Mark placeholders: # TODO: Run actual benchmark : Fabricated data misleads users performance erodes trust.","code":""},{"path":"https://gillescolling.com/couplr/copilot-instructions.html","id":"contact--issues","dir":"","previous_headings":"","what":"Contact / Issues","title":"Quick Orientation","text":"Bug reports URL DESCRIPTION: https://github.com/gcol33/couplr/issues — open issue ambiguous design decisions.","code":""},{"path":"https://gillescolling.com/couplr/copilot-instructions.html","id":"additional-resources","dir":"","previous_headings":"","what":"Additional Resources","title":"Quick Orientation","text":"See CLAUDE.md repository root comprehensive development documentation file provides quick orientation; CLAUDE.md detailed architecture, testing strategies, development workflows","code":""},{"path":"https://gillescolling.com/couplr/index.html","id":"couplr","dir":"","previous_headings":"","what":"couplr: Optimal Pairing and Matching via Linear Assignment","title":"couplr: Optimal Pairing and Matching via Linear Assignment","text":"Optimal Pairing Matching via Linear Assignment couplr package provides high-level functions optimal one--one matching two groups. Whether need pair treatment control units, assign workers tasks, align images pixel--pixel, couplr offers fast, deterministic solutions automatic preprocessing balance diagnostics.","code":""},{"path":"https://gillescolling.com/couplr/index.html","id":"quick-start","dir":"","previous_headings":"","what":"Quick Start","title":"couplr: Optimal Pairing and Matching via Linear Assignment","text":"","code":"library(couplr)  # Match treatment and control groups on covariates result <- match_couples(   treated, control,   vars = c(\"age\", \"income\", \"education\"),   auto_scale = TRUE )  # Check covariate balance balance_diagnostics(result, treated, control, vars = c(\"age\", \"income\", \"education\"))  # Get analysis-ready dataset matched_data <- join_matched(result, treated, control)"},{"path":"https://gillescolling.com/couplr/index.html","id":"statement-of-need","dir":"","previous_headings":"","what":"Statement of Need","title":"couplr: Optimal Pairing and Matching via Linear Assignment","text":"Optimal matching central experimental design, causal inference, resource allocation. Existing R packages (MatchIt, optmatch) focus propensity score workflows, requiring users estimate scores matching. adds complexity can obscure direct relationship covariates match quality. package addresses direct covariate matching: selecting optimal pairs based observed variables without intermediate modeling. provides: 18 LAP algorithms different problem sizes structures, automatic preprocessing variable health checks, balance diagnostics assessing match quality, analysis-ready joined output. features make package useful domains like: causal inference (matching treated/control units), experimental design (pairing samples within-pair comparisons), resource allocation (assigning workers tasks), image processing (pixel-level morphing alignment).","code":""},{"path":[]},{"path":"https://gillescolling.com/couplr/index.html","id":"high-level-matching-functions","dir":"","previous_headings":"Features","what":"High-Level Matching Functions","title":"couplr: Optimal Pairing and Matching via Linear Assignment","text":"Automatic preprocessing variable health checks Multiple scaling methods: robust (MAD), standardize (SD), range Distance constraints via max_distance calipers Blocking support stratified matching Three strategies: sorted, row_best, pq (priority queue) 10-100x faster optimal large datasets preprocessing constraint options","code":""},{"path":"https://gillescolling.com/couplr/index.html","id":"balance-diagnostics","dir":"","previous_headings":"Features","what":"Balance Diagnostics","title":"couplr: Optimal Pairing and Matching via Linear Assignment","text":"Standardized differences, variance ratios, KS tests Quality thresholds: <0.1 excellent, 0.1-0.25 good, 0.25-0.5 acceptable Per-block statistics blocking used Publication-ready tables via balance_table()","code":""},{"path":"https://gillescolling.com/couplr/index.html","id":"low-level-lap-solving","dir":"","previous_headings":"Features","what":"Low-Level LAP Solving","title":"couplr: Optimal Pairing and Matching via Linear Assignment","text":"18 solvers: Hungarian, Jonker-Volgenant, Auction, Network Simplex, etc. Automatic method selection via method = \"auto\" Supports rectangular matrices forbidden assignments lap_solve_batch(): Batch solving multiple matrices lap_solve_kbest(): K-best solutions via Murty’s algorithm","code":""},{"path":"https://gillescolling.com/couplr/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"couplr: Optimal Pairing and Matching via Linear Assignment","text":"","code":"# Install from CRAN install.packages(\"couplr\")  # Or install development version from GitHub # install.packages(\"pak\") pak::pak(\"gcol33/couplr\")"},{"path":[]},{"path":"https://gillescolling.com/couplr/index.html","id":"optimal-matching-match_couples","dir":"","previous_headings":"Usage Examples","what":"Optimal Matching (match_couples)","title":"couplr: Optimal Pairing and Matching via Linear Assignment","text":"","code":"library(couplr)  # Basic matching with automatic scaling result <- match_couples(   treated, control,   vars = c(\"age\", \"income\"),   auto_scale = TRUE )  # With distance constraint result <- match_couples(   treated, control,   vars = c(\"age\", \"income\"),   auto_scale = TRUE,   max_distance = 0.5 )  # With blocking (exact matching on site) result <- match_couples(   treated, control,   vars = c(\"age\", \"income\"),   block_by = \"site\",   auto_scale = TRUE )  # Check what was matched result$pairs"},{"path":"https://gillescolling.com/couplr/index.html","id":"greedy-matching-greedy_couples","dir":"","previous_headings":"Usage Examples","what":"Greedy Matching (greedy_couples)","title":"couplr: Optimal Pairing and Matching via Linear Assignment","text":"","code":"# Fast matching for large datasets result <- greedy_couples(   treated, control,   vars = c(\"age\", \"income\"),   strategy = \"row_best\",   auto_scale = TRUE )  # Priority queue strategy (often best quality) result <- greedy_couples(   treated, control,   vars = c(\"age\", \"income\"),   strategy = \"pq\" )"},{"path":"https://gillescolling.com/couplr/index.html","id":"low-level-lap-solving-1","dir":"","previous_headings":"Usage Examples","what":"Low-Level LAP Solving","title":"couplr: Optimal Pairing and Matching via Linear Assignment","text":"","code":"# Solve a cost matrix cost <- matrix(c(4, 2, 8, 4, 3, 7, 3, 1, 6), nrow = 3, byrow = TRUE) result <- lap_solve(cost) result$assignment result$total_cost  # Choose a specific algorithm result <- lap_solve(cost, method = \"hungarian\")  # K-best solutions results <- lap_solve_kbest(cost, k = 3)"},{"path":"https://gillescolling.com/couplr/index.html","id":"choosing-between-match_couples-and-greedy_couples","dir":"","previous_headings":"","what":"Choosing Between match_couples and greedy_couples","title":"couplr: Optimal Pairing and Matching via Linear Assignment","text":"Tip: Start match_couples(). Switch greedy_couples() runtime long.","code":""},{"path":[]},{"path":"https://gillescolling.com/couplr/index.html","id":"distance-caching","dir":"","previous_headings":"Advanced Features","what":"Distance Caching","title":"couplr: Optimal Pairing and Matching via Linear Assignment","text":"Precompute distances rapid experimentation:","code":"# Compute once dist_obj <- compute_distances(treated, control, vars = c(\"age\", \"income\"))  # Reuse with different constraints result1 <- match_couples(dist_obj, max_distance = 0.3) result2 <- match_couples(dist_obj, max_distance = 0.5)"},{"path":"https://gillescolling.com/couplr/index.html","id":"parallel-processing","dir":"","previous_headings":"Advanced Features","what":"Parallel Processing","title":"couplr: Optimal Pairing and Matching via Linear Assignment","text":"Speed blocked matching multi-core processing:","code":"result <- match_couples(   treated, control,   vars = c(\"age\", \"income\"),   block_by = \"site\",   parallel = TRUE )"},{"path":"https://gillescolling.com/couplr/index.html","id":"pixel-morphing","dir":"","previous_headings":"Advanced Features","what":"Pixel Morphing","title":"couplr: Optimal Pairing and Matching via Linear Assignment","text":"Align images pixel--pixel using optimal assignment:","code":"morph <- pixel_morph(image_a, image_b) pixel_morph_animate(morph, \"output.gif\")"},{"path":"https://gillescolling.com/couplr/index.html","id":"documentation","dir":"","previous_headings":"","what":"Documentation","title":"couplr: Optimal Pairing and Matching via Linear Assignment","text":"Getting Started Algorithm Details Matching Workflows Pixel Morphing","code":""},{"path":"https://gillescolling.com/couplr/index.html","id":"support","dir":"","previous_headings":"","what":"Support","title":"couplr: Optimal Pairing and Matching via Linear Assignment","text":"“Software like sex: ’s better ’s free.” — Linus Torvalds ’m PhD student builds R packages free time believe good tools free open. started projects work figured others might find useful . package saved time, buying coffee nice way say thanks. helps coffee addiction.","code":""},{"path":"https://gillescolling.com/couplr/index.html","id":"license","dir":"","previous_headings":"","what":"License","title":"couplr: Optimal Pairing and Matching via Linear Assignment","text":"MIT (see LICENSE file)","code":""},{"path":"https://gillescolling.com/couplr/index.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"couplr: Optimal Pairing and Matching via Linear Assignment","text":"","code":"@software{couplr,   author = {Colling, Gilles},   title = {couplr: Optimal Matching via Linear Assignment},   year = {2026},   url = {https://github.com/gcol33/couplr} }"},{"path":"https://gillescolling.com/couplr/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2026 Gilles Colling Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":[]},{"path":"https://gillescolling.com/couplr/NETWORK_SIMPLEX_PLAN.html","id":"algorithm-overview","dir":"","previous_headings":"","what":"Algorithm Overview","title":"Network Simplex Implementation Plan","text":"Network Simplex algorithm solves minimum-cost flow problem, specialized assignment: - Model n×m assignment bipartite network flow - Basis = spanning tree (matrix) - Dual variables = node potentials - 200-300x faster general simplex networks Complexity: O(VE log V log(VC)) polynomial; O(n³) typical practice","code":""},{"path":"https://gillescolling.com/couplr/NETWORK_SIMPLEX_PLAN.html","id":"network-structure-for-assignment","dir":"","previous_headings":"","what":"Network Structure for Assignment","title":"Network Simplex Implementation Plan","text":"Arcs: - source → row_i: cost=0, cap=1, lower=1 (n arcs) - row_i → col_j: cost=C[,j], cap=1, lower=0 (n×m arcs) - col_j → sink: cost=0, cap=1, lower=0 (m arcs) Total: 2n + m + n×m arcs, n + m + 2 nodes","code":"source (node 0, supply = n)             |     +-------+-------+     |       |       |    row₀   row₁ ... row_{n-1}   (nodes 1..n, transshipment)     |\\      |\\      |     | \\     | \\     |    col₀  col₁ ... col_{m-1}    (nodes n+1..n+m, transshipment)     |       |       |     +-------+-------+             |          sink (node n+m+1, demand = n)"},{"path":"https://gillescolling.com/couplr/NETWORK_SIMPLEX_PLAN.html","id":"file-structure","dir":"","previous_headings":"","what":"File Structure","title":"Network Simplex Implementation Plan","text":"","code":"src/solvers/network_simplex/ ├── ns_types.h                    # Data structures, constants ├── ns_graph.h                    # Build assignment network ├── ns_init.h                     # Big-M initialization ├── ns_pivot.h                    # Pivot operations (all-in-one) └── solve_network_simplex.cpp     # Main algorithm loop"},{"path":[]},{"path":"https://gillescolling.com/couplr/NETWORK_SIMPLEX_PLAN.html","id":"part-1-ns_typesh","dir":"","previous_headings":"Implementation Parts","what":"Part 1: ns_types.h","title":"Network Simplex Implementation Plan","text":"State structure: Constants:","code":"struct NSState {     // Problem size     int n_rows, n_cols;     int num_nodes;           // n + m + 2     int num_arcs;            // 2n + m + n*m      // Arc data (indexed 0..num_arcs-1)     std::vector<int> arc_source;    // Source node of arc     std::vector<int> arc_target;    // Target node of arc     std::vector<double> arc_cost;   // Cost of arc     std::vector<int> arc_flow;      // Current flow (0 or 1)      // Arc state: 0=LOWER, 1=TREE, 2=UPPER     std::vector<int> arc_state;      // Spanning tree (threaded representation)     std::vector<int> parent;        // Parent node (-1 for root)     std::vector<int> parent_arc;    // Arc connecting to parent     std::vector<int> thread;        // Next node in DFS preorder     std::vector<int> rev_thread;    // Previous in DFS preorder     std::vector<int> depth;         // Depth in tree     std::vector<int> subtree_size;  // Size of subtree      // Dual variables     std::vector<double> potential;  // Node potentials π[i]      // Assignment result     std::vector<int> row_to_col;    // row i matched to col j }; const int STATE_LOWER = 0; const int STATE_TREE = 1; const int STATE_UPPER = 2;  const int ROOT_NODE = -1; const double BIG_M = 1e12;"},{"path":"https://gillescolling.com/couplr/NETWORK_SIMPLEX_PLAN.html","id":"part-2-ns_graphh","dir":"","previous_headings":"Implementation Parts","what":"Part 2: ns_graph.h","title":"Network Simplex Implementation Plan","text":"Functions:","code":"// Node indexing: //   0 = source //   1..n = rows //   n+1..n+m = columns //   n+m+1 = sink  inline int row_node(int i) { return i + 1; } inline int col_node(int j, int n) { return n + 1 + j; } inline int source_node() { return 0; } inline int sink_node(int n, int m) { return n + m + 1; }  // Arc indexing: //   0..n-1 = source->row arcs //   n..n+n*m-1 = row->col arcs (arc n + i*m + j for row i, col j) //   n+n*m..n+n*m+m-1 = col->sink arcs  void build_assignment_network(NSState& state,                                const double* cost_matrix,                                int n_rows, int n_cols);"},{"path":"https://gillescolling.com/couplr/NETWORK_SIMPLEX_PLAN.html","id":"part-3-ns_inith","dir":"","previous_headings":"Implementation Parts","what":"Part 3: ns_init.h","title":"Network Simplex Implementation Plan","text":"Big-M Method: - Add artificial arc node super-root cost BIG_M - Initial tree = star super-root - simpler: use source root, artificial arcs unconnected nodes Potential computation: - Set π[root] = 0 - tree arc (u,v): π[v] = π[u] + cost[u,v] arc points u→v tree - Traverse thread order","code":"void initialize_spanning_tree(NSState& state); void compute_initial_potentials(NSState& state);"},{"path":"https://gillescolling.com/couplr/NETWORK_SIMPLEX_PLAN.html","id":"part-4-ns_pivoth","dir":"","previous_headings":"Implementation Parts","what":"Part 4: ns_pivot.h","title":"Network Simplex Implementation Plan","text":"Key operations: Pivot steps: 1. Find join (LCA) entering arc endpoints 2. Trace cycle endpoints join 3. Find leaving arc (min residual cycle) 4. Augment flow around cycle 5. Update tree: remove leaving arc, add entering arc 6. Update thread order moved subtree 7. Update potentials moved subtree","code":"// Reduced cost of arc e inline double reduced_cost(const NSState& state, int arc) {     int u = state.arc_source[arc];     int v = state.arc_target[arc];     return state.arc_cost[arc] - state.potential[u] + state.potential[v]; }  // Find entering arc (block search) int find_entering_arc(const NSState& state);  // Find cycle and leaving arc when adding entering arc struct PivotInfo {     int entering_arc;     int leaving_arc;     int join_node;      // LCA of arc endpoints     int delta;          // Flow augmentation (0 or 1 for assignment)     bool change_root;   // Whether tree structure changes };  PivotInfo find_leaving_arc(const NSState& state, int entering_arc);  // Execute pivot void do_pivot(NSState& state, const PivotInfo& info);"},{"path":"https://gillescolling.com/couplr/NETWORK_SIMPLEX_PLAN.html","id":"part-5-solve_network_simplexcpp","dir":"","previous_headings":"Implementation Parts","what":"Part 5: solve_network_simplex.cpp","title":"Network Simplex Implementation Plan","text":"","code":"NSResult solve_network_simplex_impl(const Rcpp::NumericMatrix& cost_matrix) {     NSState state;     int n = cost_matrix.nrow();     int m = cost_matrix.ncol();      // Build network     build_assignment_network(state, &cost_matrix[0], n, m);      // Initialize spanning tree and potentials     initialize_spanning_tree(state);     compute_initial_potentials(state);      // Main loop     int max_iter = state.num_arcs * state.num_nodes;     for (int iter = 0; iter < max_iter; ++iter) {         int entering = find_entering_arc(state);         if (entering < 0) break;  // Optimal!          PivotInfo info = find_leaving_arc(state, entering);         do_pivot(state, info);     }      // Extract solution     return extract_assignment(state); }"},{"path":[]},{"path":"https://gillescolling.com/couplr/NETWORK_SIMPLEX_PLAN.html","id":"id_1-thread-representation","dir":"","previous_headings":"Critical Implementation Details","what":"1. Thread Representation","title":"Network Simplex Implementation Plan","text":"spanning tree stored implicitly via DFS preorder threading: - thread[u] = next node DFS preorder - rev_thread[u] = previous node DFS preorder - subtree_size[u] = nodes subtree rooted u enables O(subtree_size) traversal subtree without explicit child pointers.","code":""},{"path":"https://gillescolling.com/couplr/NETWORK_SIMPLEX_PLAN.html","id":"id_2-anti-cycling-strongly-feasible-basis","dir":"","previous_headings":"Critical Implementation Details","what":"2. Anti-Cycling (Strongly Feasible Basis)","title":"Network Simplex Implementation Plan","text":"Use Cunningham’s leaving arc rule: - Among arcs minimum residual, choose one closest join - Guarantees O(n) consecutive degenerate pivots","code":""},{"path":"https://gillescolling.com/couplr/NETWORK_SIMPLEX_PLAN.html","id":"id_3-block-search-pricing","dir":"","previous_headings":"Critical Implementation Details","what":"3. Block Search Pricing","title":"Network Simplex Implementation Plan","text":"Divide arcs blocks size B = ceil(sqrt(num_arcs)) block, find arc negative reduced cost found, use ; otherwise move next block Balances work per iteration vs number iterations","code":""},{"path":"https://gillescolling.com/couplr/NETWORK_SIMPLEX_PLAN.html","id":"id_4-assignment-simplifications","dir":"","previous_headings":"Critical Implementation Details","what":"4. Assignment Simplifications","title":"Network Simplex Implementation Plan","text":"Since capacities = 1 demands = 1: - Flow always 0 1 - Residual capacity 1-flow (forward) flow (backward) - Delta (augmentation amount) always 0 1 - Degenerate pivots (delta=0) common","code":""},{"path":"https://gillescolling.com/couplr/NETWORK_SIMPLEX_PLAN.html","id":"id_5-potential-updates","dir":"","previous_headings":"Critical Implementation Details","what":"5. Potential Updates","title":"Network Simplex Implementation Plan","text":"pivot, potentials moved subtree change:","code":"// sigma = new_potential - old_potential for entering arc endpoint double sigma = state.potential[u_in] + state.arc_cost[entering]              - state.potential[v_in];  // Update all nodes in moved subtree for (int v = moved_root; v != end_of_subtree; v = state.thread[v]) {     state.potential[v] += sigma; }"},{"path":"https://gillescolling.com/couplr/NETWORK_SIMPLEX_PLAN.html","id":"testing-strategy","dir":"","previous_headings":"","what":"Testing Strategy","title":"Network Simplex Implementation Plan","text":"Compare JV solver random matrices Test edge cases: 1×1, rectangular, ties costs Check reduced costs ≥ 0 lower-bound arcs Check reduced costs ≤ 0 upper-bound arcs Verify complementary slackness Benchmark JV, auction, Orlin-Ahuja Measure pivot count vs problem size","code":""},{"path":"https://gillescolling.com/couplr/NETWORK_SIMPLEX_PLAN.html","id":"references","dir":"","previous_headings":"","what":"References","title":"Network Simplex Implementation Plan","text":"Király & Kovács (2012): “Efficient implementation minimum-cost flow algorithms” LEMON library: network_simplex.h NetworkX: networksimplex.py Ahuja, Magnanti, Orlin: “Network Flows: Theory, Algorithms, Applications”","code":""},{"path":"https://gillescolling.com/couplr/reference/apply_all_constraints.html","id":null,"dir":"Reference","previous_headings":"","what":"Apply all constraints to cost matrix — apply_all_constraints","title":"Apply all constraints to cost matrix — apply_all_constraints","text":"Main entry point applying constraints.","code":""},{"path":"https://gillescolling.com/couplr/reference/apply_all_constraints.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Apply all constraints to cost matrix — apply_all_constraints","text":"","code":"apply_all_constraints(   cost_matrix,   left,   right,   vars,   max_distance = Inf,   calipers = NULL,   forbidden = NULL )"},{"path":"https://gillescolling.com/couplr/reference/apply_all_constraints.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Apply all constraints to cost matrix — apply_all_constraints","text":"Modified cost matrix constraints applied.","code":""},{"path":"https://gillescolling.com/couplr/reference/apply_calipers.html","id":null,"dir":"Reference","previous_headings":"","what":"Apply caliper constraints — apply_calipers","title":"Apply caliper constraints — apply_calipers","text":"Calipers impose per-variable maximum absolute differences.","code":""},{"path":"https://gillescolling.com/couplr/reference/apply_calipers.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Apply caliper constraints — apply_calipers","text":"","code":"apply_calipers(cost_matrix, left, right, calipers, vars)"},{"path":"https://gillescolling.com/couplr/reference/apply_calipers.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Apply caliper constraints — apply_calipers","text":"Modified cost matrix forbidden pairs marked.","code":""},{"path":"https://gillescolling.com/couplr/reference/apply_max_distance.html","id":null,"dir":"Reference","previous_headings":"","what":"Apply maximum distance constraint — apply_max_distance","title":"Apply maximum distance constraint — apply_max_distance","text":"Apply maximum distance constraint","code":""},{"path":"https://gillescolling.com/couplr/reference/apply_max_distance.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Apply maximum distance constraint — apply_max_distance","text":"","code":"apply_max_distance(cost_matrix, max_distance = Inf)"},{"path":"https://gillescolling.com/couplr/reference/apply_max_distance.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Apply maximum distance constraint — apply_max_distance","text":"Modified cost matrix forbidden pairs marked.","code":""},{"path":"https://gillescolling.com/couplr/reference/apply_scaling.html","id":null,"dir":"Reference","previous_headings":"","what":"Apply scaling to matching variables — apply_scaling","title":"Apply scaling to matching variables — apply_scaling","text":"Apply scaling matching variables","code":""},{"path":"https://gillescolling.com/couplr/reference/apply_scaling.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Apply scaling to matching variables — apply_scaling","text":"","code":"apply_scaling(left_mat, right_mat, method = \"standardize\")"},{"path":"https://gillescolling.com/couplr/reference/apply_scaling.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Apply scaling to matching variables — apply_scaling","text":"List scaled left/right matrices scaling parameters.","code":""},{"path":"https://gillescolling.com/couplr/reference/apply_weights.html","id":null,"dir":"Reference","previous_headings":"","what":"Apply weights to matching variables — apply_weights","title":"Apply weights to matching variables — apply_weights","text":"Apply weights matching variables","code":""},{"path":"https://gillescolling.com/couplr/reference/apply_weights.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Apply weights to matching variables — apply_weights","text":"","code":"apply_weights(mat, weights)"},{"path":"https://gillescolling.com/couplr/reference/apply_weights.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Apply weights to matching variables — apply_weights","text":"Numeric matrix columns weighted.","code":""},{"path":"https://gillescolling.com/couplr/reference/assignment.html","id":null,"dir":"Reference","previous_headings":"","what":"Linear assignment solver — assignment","title":"Linear assignment solver — assignment","text":"Solve linear assignment problem (minimum- maximum-cost matching) using several algorithms. Forbidden edges can marked NA Inf.","code":""},{"path":"https://gillescolling.com/couplr/reference/assignment.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Linear assignment solver — assignment","text":"","code":"assignment(   cost,   maximize = FALSE,   method = c(\"auto\", \"jv\", \"hungarian\", \"auction\", \"auction_gs\", \"auction_scaled\", \"sap\",     \"ssp\", \"csflow\", \"hk01\", \"bruteforce\", \"ssap_bucket\", \"cycle_cancel\", \"gabow_tarjan\",     \"lapmod\", \"csa\", \"ramshaw_tarjan\", \"push_relabel\", \"orlin\", \"network_simplex\"),   auction_eps = NULL,   eps = NULL )"},{"path":"https://gillescolling.com/couplr/reference/assignment.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Linear assignment solver — assignment","text":"cost Numeric matrix; rows = tasks, columns = agents. NA Inf entries treated forbidden assignments. maximize Logical; TRUE, maximizes total cost instead minimizing. method Character string indicating algorithm use. Options: General-purpose solvers: \"auto\" — Automatic selection based problem characteristics (default) \"jv\" — 'Jonker-Volgenant', fast general-purpose O(n³) \"hungarian\" — Classic 'Hungarian' algorithm O(n³) Auction-based solvers: \"auction\" — 'Bertsekas' auction adaptive epsilon \"auction_gs\" — 'Gauss-Seidel' variant, good spatial structure \"auction_scaled\" — 'Epsilon-scaling', fastest large dense problems Specialized solvers: \"sap\" / \"ssp\" — Shortest augmenting path, handles sparsity well \"lapmod\" — Sparse JV variant, faster >50\\ \"hk01\" — 'Hopcroft-Karp' binary (0/1) costs \"ssap_bucket\" — 'Dial' algorithm integer costs \"line_metric\" — O(n log n) 1D assignment problems \"bruteforce\" — Exact enumeration tiny problems (n <= 8) Advanced solvers: \"csa\" — 'Goldberg-Kennedy' cost-scaling, often fastest medium-large \"gabow_tarjan\" — 'Gabow-Tarjan' bit-scaling complementary slackness O(n³ log C) \"cycle_cancel\" — Cycle-canceling 'Karp' algorithm \"csflow\" — Cost-scaling network flow \"network_simplex\" — 'Network simplex' spanning tree representation \"orlin\" — 'Orlin-Ahuja' scaling O(sqrt(n) * m * log(nC)) \"push_relabel\" — 'Push-relabel' max-flow based solver \"ramshaw_tarjan\" — 'Ramshaw-Tarjan', optimized rectangular matrices (n != m) auction_eps Optional numeric epsilon 'Auction'/'Auction-GS' methods. NULL, internal default (e.g., 1e-9) used. eps Deprecated. Use auction_eps. provided auction_eps NULL, value used auction_eps.","code":""},{"path":"https://gillescolling.com/couplr/reference/assignment.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Linear assignment solver — assignment","text":"object class lap_solve_result, list elements: match — integer vector length min(nrow(cost), ncol(cost)) giving assigned column row (0 unassigned). total_cost — numeric scalar, objective value. status — character scalar, e.g. \"optimal\". method_used — character scalar, algorithm actually used.","code":""},{"path":"https://gillescolling.com/couplr/reference/assignment.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Linear assignment solver — assignment","text":"method = \"auto\" selects algorithm based problem size/shape data characteristics: small (n <= 8): \"bruteforce\" — exact enumeration Binary/constant costs: \"hk01\" — specialized 0/1 costs Large sparse (n>100, >50\\ Sparse rectangular: \"sap\" — handles sparsity well Small-medium (8 < n <= 50): \"hungarian\" — provides exact dual solutions Medium (50 < n <= 75): \"jv\" — fast general-purpose solver Large (n>75): \"auction_scaled\" — fastest large dense problems Benchmarks show 'Auction-scaled' 'JV' 100-1500x faster 'Hungarian' n=500.","code":""},{"path":[]},{"path":"https://gillescolling.com/couplr/reference/assignment.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Linear assignment solver — assignment","text":"","code":"cost <- matrix(c(4,2,5, 3,3,6, 7,5,4), nrow = 3, byrow = TRUE) res  <- assignment(cost) res$match; res$total_cost"},{"path":"https://gillescolling.com/couplr/reference/assignment_duals.html","id":null,"dir":"Reference","previous_headings":"","what":"Solve assignment problem and return dual variables — assignment_duals","title":"Solve assignment problem and return dual variables — assignment_duals","text":"Solves linear assignment problem returns dual potentials (u, v) addition optimal matching. dual variables provide optimality certificate enable sensitivity analysis.","code":""},{"path":"https://gillescolling.com/couplr/reference/assignment_duals.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Solve assignment problem and return dual variables — assignment_duals","text":"","code":"assignment_duals(cost, maximize = FALSE)"},{"path":"https://gillescolling.com/couplr/reference/assignment_duals.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Solve assignment problem and return dual variables — assignment_duals","text":"cost Numeric matrix; rows = tasks, columns = agents. NA Inf entries treated forbidden assignments. maximize Logical; TRUE, maximizes total cost instead minimizing.","code":""},{"path":"https://gillescolling.com/couplr/reference/assignment_duals.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Solve assignment problem and return dual variables — assignment_duals","text":"list class \"assignment_duals_result\" containing: match - integer vector column assignments (1-based) total_cost - optimal objective value u - numeric vector row dual variables (length n) v - numeric vector column dual variables (length m) status - character, e.g. \"optimal\"","code":""},{"path":"https://gillescolling.com/couplr/reference/assignment_duals.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Solve assignment problem and return dual variables — assignment_duals","text":"dual variables satisfy complementary slackness conditions: minimization: u[] + v[j] <= cost[,j] (,j) assigned pair (,j): u[] + v[j] = cost[,j] implies sum(u) + sum(v) = total_cost (strong duality). Applications dual variables: Optimality verification: Check duals satisfy constraints Sensitivity analysis: Reduced cost c[,j] - u[] - v[j] shows much edge cost must decrease enters solution Pricing column generation: Use duals price new columns Warm starting: Reuse duals costs change slightly","code":""},{"path":[]},{"path":"https://gillescolling.com/couplr/reference/assignment_duals.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Solve assignment problem and return dual variables — assignment_duals","text":"","code":"cost <- matrix(c(4, 2, 5, 3, 3, 6, 7, 5, 4), nrow = 3, byrow = TRUE) result <- assignment_duals(cost)  # Check optimality: u + v should equal cost for assigned pairs for (i in 1:3) {   j <- result$match[i]   cat(sprintf(\"Row %d -> Col %d: u + v = %.2f, cost = %.2f\\n\",               i, j, result$u[i] + result$v[j], cost[i, j])) }  # Verify strong duality cat(\"sum(u) + sum(v) =\", sum(result$u) + sum(result$v), \"\\n\") cat(\"total_cost =\", result$total_cost, \"\\n\")  # Reduced costs (how much must cost decrease to enter solution) reduced <- outer(result$u, result$v, \"+\") reduced_cost <- cost - reduced print(round(reduced_cost, 2))"},{"path":"https://gillescolling.com/couplr/reference/assign_blocks_cluster.html","id":null,"dir":"Reference","previous_headings":"","what":"Assign blocks using clustering — assign_blocks_cluster","title":"Assign blocks using clustering — assign_blocks_cluster","text":"Assign blocks using clustering","code":""},{"path":"https://gillescolling.com/couplr/reference/assign_blocks_cluster.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Assign blocks using clustering — assign_blocks_cluster","text":"","code":"assign_blocks_cluster(left, right, block_vars, method, n_blocks, ...)"},{"path":"https://gillescolling.com/couplr/reference/assign_blocks_cluster.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Assign blocks using clustering — assign_blocks_cluster","text":"List modified left/right data frames (block_id) n_blocks_initial.","code":""},{"path":"https://gillescolling.com/couplr/reference/assign_blocks_group.html","id":null,"dir":"Reference","previous_headings":"","what":"Assign blocks based on grouping variable(s) — assign_blocks_group","title":"Assign blocks based on grouping variable(s) — assign_blocks_group","text":"Assign blocks based grouping variable(s)","code":""},{"path":"https://gillescolling.com/couplr/reference/assign_blocks_group.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Assign blocks based on grouping variable(s) — assign_blocks_group","text":"","code":"assign_blocks_group(left, right, block_by)"},{"path":"https://gillescolling.com/couplr/reference/assign_blocks_group.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Assign blocks based on grouping variable(s) — assign_blocks_group","text":"List modified left/right data frames (block_id) n_blocks_initial.","code":""},{"path":"https://gillescolling.com/couplr/reference/as_assignment_matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert assignment result to a binary matrix — as_assignment_matrix","title":"Convert assignment result to a binary matrix — as_assignment_matrix","text":"Turns tidy assignment result back 0/1 assignment matrix.","code":""},{"path":"https://gillescolling.com/couplr/reference/as_assignment_matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert assignment result to a binary matrix — as_assignment_matrix","text":"","code":"as_assignment_matrix(x, n_sources = NULL, n_targets = NULL)"},{"path":"https://gillescolling.com/couplr/reference/as_assignment_matrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert assignment result to a binary matrix — as_assignment_matrix","text":"x assignment result object class lap_solve_result n_sources Number source nodes, optional n_targets Number target nodes, optional","code":""},{"path":"https://gillescolling.com/couplr/reference/as_assignment_matrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert assignment result to a binary matrix — as_assignment_matrix","text":"Integer matrix 0 1 entries","code":""},{"path":"https://gillescolling.com/couplr/reference/augment.html","id":null,"dir":"Reference","previous_headings":"","what":"Generic Augment Function — augment","title":"Generic Augment Function — augment","text":"S3 generic augmenting model results original data.","code":""},{"path":"https://gillescolling.com/couplr/reference/augment.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generic Augment Function — augment","text":"","code":"augment(x, ...)"},{"path":"https://gillescolling.com/couplr/reference/augment.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generic Augment Function — augment","text":"x object augment ... Additional arguments passed methods","code":""},{"path":"https://gillescolling.com/couplr/reference/augment.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generic Augment Function — augment","text":"Augmented data (depends method)","code":""},{"path":"https://gillescolling.com/couplr/reference/augment.matching_result.html","id":null,"dir":"Reference","previous_headings":"","what":"Augment Matching Results with Original Data (broom-style) — augment.matching_result","title":"Augment Matching Results with Original Data (broom-style) — augment.matching_result","text":"S3 method augmenting matching results following broom package conventions. thin wrapper around join_matched() sensible defaults quick exploration.","code":""},{"path":"https://gillescolling.com/couplr/reference/augment.matching_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Augment Matching Results with Original Data (broom-style) — augment.matching_result","text":"","code":"# S3 method for class 'matching_result' augment(x, left, right, ...)"},{"path":"https://gillescolling.com/couplr/reference/augment.matching_result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Augment Matching Results with Original Data (broom-style) — augment.matching_result","text":"x matching_result object left original left dataset right original right dataset ... Additional arguments passed join_matched()","code":""},{"path":"https://gillescolling.com/couplr/reference/augment.matching_result.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Augment Matching Results with Original Data (broom-style) — augment.matching_result","text":"tibble matched pairs original data (see join_matched())","code":""},{"path":"https://gillescolling.com/couplr/reference/augment.matching_result.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Augment Matching Results with Original Data (broom-style) — augment.matching_result","text":"method follows augment() convention broom package, making easy integrate couplr tidymodels workflows. equivalent calling join_matched() default parameters. broom package loaded, can use couplr::augment() access function.","code":""},{"path":"https://gillescolling.com/couplr/reference/augment.matching_result.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Augment Matching Results with Original Data (broom-style) — augment.matching_result","text":"","code":"left <- data.frame(   id = 1:5,   treatment = 1,   age = c(25, 30, 35, 40, 45) )  right <- data.frame(   id = 6:10,   treatment = 0,   age = c(24, 29, 36, 41, 44) )  result <- match_couples(left, right, vars = \"age\") couplr::augment(result, left, right)"},{"path":"https://gillescolling.com/couplr/reference/auto_encode_categorical.html","id":null,"dir":"Reference","previous_headings":"","what":"Automatically encode categorical variables — auto_encode_categorical","title":"Automatically encode categorical variables — auto_encode_categorical","text":"Converts categorical variables numeric representations suitable matching. Currently supports binary variables (0/1) ordered factors.","code":""},{"path":"https://gillescolling.com/couplr/reference/auto_encode_categorical.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Automatically encode categorical variables — auto_encode_categorical","text":"","code":"auto_encode_categorical(left, right, var)"},{"path":"https://gillescolling.com/couplr/reference/auto_encode_categorical.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Automatically encode categorical variables — auto_encode_categorical","text":"left Data frame left units right Data frame right units var Variable name encode","code":""},{"path":"https://gillescolling.com/couplr/reference/auto_encode_categorical.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Automatically encode categorical variables — auto_encode_categorical","text":"List encoded left right columns, plus encoding metadata","code":""},{"path":"https://gillescolling.com/couplr/reference/balance_diagnostics.html","id":null,"dir":"Reference","previous_headings":"","what":"Balance Diagnostics for Matched Pairs — balance_diagnostics","title":"Balance Diagnostics for Matched Pairs — balance_diagnostics","text":"Computes comprehensive balance statistics comparing distribution matching variables left right units matched sample.","code":""},{"path":"https://gillescolling.com/couplr/reference/balance_diagnostics.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Balance Diagnostics for Matched Pairs — balance_diagnostics","text":"","code":"balance_diagnostics(   result,   left,   right,   vars = NULL,   left_id = \"id\",   right_id = \"id\" )"},{"path":"https://gillescolling.com/couplr/reference/balance_diagnostics.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Balance Diagnostics for Matched Pairs — balance_diagnostics","text":"result matching result object match_couples() greedy_couples() left Data frame left units right Data frame right units vars Character vector variable names check balance . Defaults variables used matching (available result). left_id Character, name ID column left data (default: \"id\") right_id Character, name ID column right data (default: \"id\")","code":""},{"path":"https://gillescolling.com/couplr/reference/balance_diagnostics.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Balance Diagnostics for Matched Pairs — balance_diagnostics","text":"S3 object class balance_diagnostics containing: var_stats Tibble per-variable balance statistics overall List overall balance metrics pairs Tibble matched pairs variables n_matched Number matched pairs n_unmatched_left Number unmatched left units n_unmatched_right Number unmatched right units method Matching method used has_blocks Whether blocking used block_stats Per-block statistics (blocking used)","code":""},{"path":"https://gillescolling.com/couplr/reference/balance_diagnostics.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Balance Diagnostics for Matched Pairs — balance_diagnostics","text":"function computes several balance metrics: Standardized Difference: difference means divided pooled standard deviation. Values less 0.1 indicate excellent balance, 0.1-0.25 good balance. Variance Ratio: ratio standard deviations (left/right). Values close 1 ideal. KS Statistic: Kolmogorov-Smirnov test statistic comparing distributions. Lower values indicate similar distributions. Overall Metrics include mean absolute standardized difference across variables, proportion variables large imbalance (|std diff| > 0.25), maximum standardized difference.","code":""},{"path":"https://gillescolling.com/couplr/reference/balance_diagnostics.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Balance Diagnostics for Matched Pairs — balance_diagnostics","text":"","code":"# Create sample data set.seed(123) left <- data.frame(   id = 1:10,   age = rnorm(10, 45, 10),   income = rnorm(10, 50000, 15000) ) right <- data.frame(   id = 11:30,   age = rnorm(20, 47, 10),   income = rnorm(20, 52000, 15000) )  # Match result <- match_couples(left, right, vars = c(\"age\", \"income\"))  # Get balance diagnostics balance <- balance_diagnostics(result, left, right, vars = c(\"age\", \"income\")) print(balance)  # Get balance table balance_table(balance)"},{"path":"https://gillescolling.com/couplr/reference/balance_table.html","id":null,"dir":"Reference","previous_headings":"","what":"Create Balance Table — balance_table","title":"Create Balance Table — balance_table","text":"Formats balance diagnostics clean table display export.","code":""},{"path":"https://gillescolling.com/couplr/reference/balance_table.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create Balance Table — balance_table","text":"","code":"balance_table(balance, digits = 3)"},{"path":"https://gillescolling.com/couplr/reference/balance_table.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create Balance Table — balance_table","text":"balance balance_diagnostics object balance_diagnostics() digits Number decimal places rounding (default: 3)","code":""},{"path":"https://gillescolling.com/couplr/reference/balance_table.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create Balance Table — balance_table","text":"tibble formatted balance statistics","code":""},{"path":"https://gillescolling.com/couplr/reference/BIG_COST.html","id":null,"dir":"Reference","previous_headings":"","what":"Large value for forbidden pairs — BIG_COST","title":"Large value for forbidden pairs — BIG_COST","text":"numeric constant used mark forbidden pairs cost matrices.","code":""},{"path":"https://gillescolling.com/couplr/reference/BIG_COST.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Large value for forbidden pairs — BIG_COST","text":"","code":"BIG_COST"},{"path":"https://gillescolling.com/couplr/reference/BIG_COST.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Large value for forbidden pairs — BIG_COST","text":"Numeric value (half .Machine$double.xmax).","code":""},{"path":"https://gillescolling.com/couplr/reference/bottleneck_assignment.html","id":null,"dir":"Reference","previous_headings":"","what":"Solve the Bottleneck Assignment Problem — bottleneck_assignment","title":"Solve the Bottleneck Assignment Problem — bottleneck_assignment","text":"Finds assignment minimizes (maximizes) maximum edge cost perfect matching. Unlike standard LAP minimizes sum costs, BAP minimizes maximum (bottleneck) cost.","code":""},{"path":"https://gillescolling.com/couplr/reference/bottleneck_assignment.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Solve the Bottleneck Assignment Problem — bottleneck_assignment","text":"","code":"bottleneck_assignment(cost, maximize = FALSE)"},{"path":"https://gillescolling.com/couplr/reference/bottleneck_assignment.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Solve the Bottleneck Assignment Problem — bottleneck_assignment","text":"cost Numeric matrix; rows = tasks, columns = agents. NA Inf entries treated forbidden assignments. maximize Logical; TRUE, maximizes minimum edge cost instead minimizing maximum (maximin objective). Default FALSE (minimax).","code":""},{"path":"https://gillescolling.com/couplr/reference/bottleneck_assignment.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Solve the Bottleneck Assignment Problem — bottleneck_assignment","text":"list class \"bottleneck_result\" containing: match - integer vector length nrow(cost) giving assigned column row (1-based indexing) bottleneck - numeric scalar, bottleneck (max/min edge) value status - character scalar, e.g. \"optimal\"","code":""},{"path":"https://gillescolling.com/couplr/reference/bottleneck_assignment.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Solve the Bottleneck Assignment Problem — bottleneck_assignment","text":"Bottleneck Assignment Problem (BAP) variant Linear Assignment Problem instead minimizing sum assignment costs, minimize maximum cost among assignments (minimax objective). Algorithm: Uses binary search sorted unique costs combined 'Hopcroft-Karp' bipartite matching find minimum threshold allows perfect matching. Complexity: O(E * sqrt(V) * log(unique costs)) E = edges, V = vertices. Applications: Task scheduling deadline constraints (minimize latest completion) Resource allocation (minimize maximum load/distance) Network routing (minimize maximum link utilization) Fair division problems (minimize maximum disparity)","code":""},{"path":[]},{"path":"https://gillescolling.com/couplr/reference/bottleneck_assignment.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Solve the Bottleneck Assignment Problem — bottleneck_assignment","text":"","code":"# Simple example: minimize max cost cost <- matrix(c(1, 5, 3,                  2, 4, 6,                  7, 1, 2), nrow = 3, byrow = TRUE) result <- bottleneck_assignment(cost) result$bottleneck  # Maximum edge cost in optimal assignment  # Maximize minimum (fair allocation) profits <- matrix(c(10, 5, 8,                     6, 12, 4,                     3, 7, 11), nrow = 3, byrow = TRUE) result <- bottleneck_assignment(profits, maximize = TRUE) result$bottleneck  # Minimum profit among all assignments  # With forbidden assignments cost <- matrix(c(1, NA, 3,                  2, 4, Inf,                  5, 1, 2), nrow = 3, byrow = TRUE) result <- bottleneck_assignment(cost)"},{"path":"https://gillescolling.com/couplr/reference/build_cost_matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Build cost matrix for matching — build_cost_matrix","title":"Build cost matrix for matching — build_cost_matrix","text":"main entry point distance computation.","code":""},{"path":"https://gillescolling.com/couplr/reference/build_cost_matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Build cost matrix for matching — build_cost_matrix","text":"","code":"build_cost_matrix(   left,   right,   vars,   distance = \"euclidean\",   weights = NULL,   scale = FALSE )"},{"path":"https://gillescolling.com/couplr/reference/build_cost_matrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Build cost matrix for matching — build_cost_matrix","text":"Numeric matrix distances optional scaling/weights applied.","code":""},{"path":"https://gillescolling.com/couplr/reference/calculate_var_balance.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Variable-Level Balance Statistics — calculate_var_balance","title":"Calculate Variable-Level Balance Statistics — calculate_var_balance","text":"Calculate Variable-Level Balance Statistics","code":""},{"path":"https://gillescolling.com/couplr/reference/calculate_var_balance.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Variable-Level Balance Statistics — calculate_var_balance","text":"","code":"calculate_var_balance(left_vals, right_vals, var_name)"},{"path":"https://gillescolling.com/couplr/reference/calculate_var_balance.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Variable-Level Balance Statistics — calculate_var_balance","text":"left_vals Numeric vector values left group right_vals Numeric vector values right group var_name Character, name variable","code":""},{"path":"https://gillescolling.com/couplr/reference/calculate_var_balance.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Variable-Level Balance Statistics — calculate_var_balance","text":"List balance statistics variable","code":""},{"path":"https://gillescolling.com/couplr/reference/can_parallelize.html","id":null,"dir":"Reference","previous_headings":"","what":"Check if parallel processing is available — can_parallelize","title":"Check if parallel processing is available — can_parallelize","text":"Check parallel processing available","code":""},{"path":"https://gillescolling.com/couplr/reference/can_parallelize.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check if parallel processing is available — can_parallelize","text":"","code":"can_parallelize()"},{"path":"https://gillescolling.com/couplr/reference/can_parallelize.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check if parallel processing is available — can_parallelize","text":"Logical indicating future package available","code":""},{"path":"https://gillescolling.com/couplr/reference/check_cost_distribution.html","id":null,"dir":"Reference","previous_headings":"","what":"Check cost distribution for problems — check_cost_distribution","title":"Check cost distribution for problems — check_cost_distribution","text":"Examines distance matrix common issues provides helpful warnings.","code":""},{"path":"https://gillescolling.com/couplr/reference/check_cost_distribution.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check cost distribution for problems — check_cost_distribution","text":"","code":"check_cost_distribution(cost_matrix, threshold_zero = 1e-10, warn = TRUE)"},{"path":"https://gillescolling.com/couplr/reference/check_cost_distribution.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check cost distribution for problems — check_cost_distribution","text":"cost_matrix Numeric matrix distances threshold_zero Threshold considering distance \"zero\" (default: 1e-10) warn TRUE, issue warnings problems found","code":""},{"path":"https://gillescolling.com/couplr/reference/check_cost_distribution.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check cost distribution for problems — check_cost_distribution","text":"List diagnostic information","code":""},{"path":"https://gillescolling.com/couplr/reference/check_full_matching.html","id":null,"dir":"Reference","previous_headings":"","what":"Check if full matching was achieved — check_full_matching","title":"Check if full matching was achieved — check_full_matching","text":"Check full matching achieved","code":""},{"path":"https://gillescolling.com/couplr/reference/check_full_matching.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check if full matching was achieved — check_full_matching","text":"","code":"check_full_matching(result)"},{"path":"https://gillescolling.com/couplr/reference/check_full_matching.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check if full matching was achieved — check_full_matching","text":"return value; throws error unmatched units exist.","code":""},{"path":"https://gillescolling.com/couplr/reference/check_variable_health.html","id":null,"dir":"Reference","previous_headings":"","what":"Check variable health for matching — check_variable_health","title":"Check variable health for matching — check_variable_health","text":"Analyzes variables common problems can affect matching quality: constant columns, high missingness, extreme skewness, outliers.","code":""},{"path":"https://gillescolling.com/couplr/reference/check_variable_health.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check variable health for matching — check_variable_health","text":"","code":"check_variable_health(   left,   right,   vars,   high_missingness_threshold = 0.5,   low_variance_threshold = 1e-06 )"},{"path":"https://gillescolling.com/couplr/reference/check_variable_health.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check variable health for matching — check_variable_health","text":"left Data frame left units right Data frame right units vars Character vector variable names check high_missingness_threshold Threshold high missingness warning (default: 0.5) low_variance_threshold Threshold nearly-constant variables (default: 1e-6)","code":""},{"path":"https://gillescolling.com/couplr/reference/check_variable_health.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check variable health for matching — check_variable_health","text":"list class \"variable_health\" containing: summary: Tibble per-variable diagnostics issues: List detected issues severity levels exclude_vars: Variables excluded warnings: Human-readable warnings","code":""},{"path":"https://gillescolling.com/couplr/reference/compute_distances.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute and Cache Distance Matrix for Reuse — compute_distances","title":"Compute and Cache Distance Matrix for Reuse — compute_distances","text":"Precomputes distance matrix left right datasets, allowing reused across multiple matching operations different constraints. particularly useful exploring different matching parameters (max_distance, calipers, methods) without recomputing distances.","code":""},{"path":"https://gillescolling.com/couplr/reference/compute_distances.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute and Cache Distance Matrix for Reuse — compute_distances","text":"","code":"compute_distances(   left,   right,   vars,   distance = \"euclidean\",   weights = NULL,   scale = FALSE,   auto_scale = FALSE,   left_id = \"id\",   right_id = \"id\",   block_id = NULL )"},{"path":"https://gillescolling.com/couplr/reference/compute_distances.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute and Cache Distance Matrix for Reuse — compute_distances","text":"left Left dataset (data frame) right Right dataset (data frame) vars Character vector variable names use distance computation distance Distance metric (default: \"euclidean\") weights Optional numeric vector variable weights scale Scaling method: FALSE, \"standardize\", \"range\", \"robust\" auto_scale Apply automatic preprocessing (default: FALSE) left_id Name ID column left (default: \"id\") right_id Name ID column right (default: \"id\") block_id Optional block ID column name blocked matching","code":""},{"path":"https://gillescolling.com/couplr/reference/compute_distances.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute and Cache Distance Matrix for Reuse — compute_distances","text":"S3 object class \"distance_object\" containing: cost_matrix: Numeric matrix distances left_ids: Character vector left IDs right_ids: Character vector right IDs block_id: Block ID column name (specified) metadata: List computation details (vars, distance, scale, etc.) original_left: Original left dataset (later joining) original_right: Original right dataset (later joining)","code":""},{"path":"https://gillescolling.com/couplr/reference/compute_distances.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute and Cache Distance Matrix for Reuse — compute_distances","text":"function computes distances stores reusable object. resulting distance_object can passed match_couples() greedy_couples() instead providing datasets variables. Benefits: Performance: Avoid recomputing distances trying different constraints Exploration: Quickly test max_distance, calipers, methods Consistency: Ensures distances used across comparisons Memory efficient: Can use sparse matrices many pairs forbidden distance_object stores original datasets, allowing downstream functions like join_matched() work seamlessly.","code":""},{"path":"https://gillescolling.com/couplr/reference/compute_distances.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute and Cache Distance Matrix for Reuse — compute_distances","text":"","code":"# Compute distances once left <- data.frame(id = 1:5, age = c(25, 30, 35, 40, 45), income = c(45, 52, 48, 61, 55) * 1000) right <- data.frame(id = 6:10, age = c(24, 29, 36, 41, 44), income = c(46, 51, 47, 60, 54) * 1000)  dist_obj <- compute_distances(   left, right,   vars = c(\"age\", \"income\"),   scale = \"standardize\" )  # Reuse for different matching strategies result1 <- match_couples(dist_obj, max_distance = 0.5) result2 <- match_couples(dist_obj, max_distance = 1.0) result3 <- greedy_couples(dist_obj, strategy = \"sorted\")  # All use the same precomputed distances"},{"path":"https://gillescolling.com/couplr/reference/compute_distance_matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute pairwise distance matrix — compute_distance_matrix","title":"Compute pairwise distance matrix — compute_distance_matrix","text":"Compute pairwise distance matrix","code":""},{"path":"https://gillescolling.com/couplr/reference/compute_distance_matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute pairwise distance matrix — compute_distance_matrix","text":"","code":"compute_distance_matrix(left_mat, right_mat, distance = \"euclidean\")"},{"path":"https://gillescolling.com/couplr/reference/compute_distance_matrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute pairwise distance matrix — compute_distance_matrix","text":"Numeric matrix pairwise distances (n_left x n_right).","code":""},{"path":"https://gillescolling.com/couplr/reference/count_valid_pairs.html","id":null,"dir":"Reference","previous_headings":"","what":"Count valid pairs in cost matrix — count_valid_pairs","title":"Count valid pairs in cost matrix — count_valid_pairs","text":"Count valid pairs cost matrix","code":""},{"path":"https://gillescolling.com/couplr/reference/count_valid_pairs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Count valid pairs in cost matrix — count_valid_pairs","text":"","code":"count_valid_pairs(cost_matrix)"},{"path":"https://gillescolling.com/couplr/reference/count_valid_pairs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Count valid pairs in cost matrix — count_valid_pairs","text":"Integer count valid (non-forbidden) pairs.","code":""},{"path":"https://gillescolling.com/couplr/reference/couplr-package.html","id":null,"dir":"Reference","previous_headings":"","what":"couplr: Optimal Pairing and Matching via Linear Assignment — couplr-package","title":"couplr: Optimal Pairing and Matching via Linear Assignment — couplr-package","text":"Solves optimal pairing matching problems using linear assignment algorithms. Provides implementations Hungarian method (Kuhn 1955) doi:10.1002/nav.3800020109 , Jonker-Volgenant shortest path algorithm (Jonker Volgenant 1987) doi:10.1007/BF02278710 , Auction algorithm (Bertsekas 1988) doi:10.1007/BF02186476 , cost-scaling (Goldberg Kennedy 1995) doi:10.1007/BF01585996 , scaling algorithms (Gabow Tarjan 1989) doi:10.1137/0218069 , push-relabel (Goldberg Tarjan 1988) doi:10.1145/48014.61051 , Sinkhorn entropy-regularized transport (Cuturi 2013) doi:10.48550/arxiv.1306.0895 . Designed matching plots, sites, samples, pairwise optimization problem. Supports rectangular matrices, forbidden assignments, data frame inputs, batch solving, k-best solutions, pixel-level image morphing visualization. Includes automatic preprocessing variable health checks, multiple scaling methods (standardized, range, robust), greedy matching algorithms, comprehensive balance diagnostics assessing match quality using standardized differences distribution comparisons. Solves optimal pairing matching problems using linear assignment algorithms. Designed matching plots, sites, samples, pairwise optimization problem. Provides modern, tidy implementations 'Hungarian', 'Jonker-Volgenant', 'Auction', LAP solvers.","code":""},{"path":"https://gillescolling.com/couplr/reference/couplr-package.html","id":"main-functions","dir":"Reference","previous_headings":"","what":"Main functions","title":"couplr: Optimal Pairing and Matching via Linear Assignment — couplr-package","text":"lap_solve: Solve single assignment problems lap_solve_batch: Solve multiple problems efficiently lap_solve_kbest: Find k-best optimal solutions","code":""},{"path":[]},{"path":"https://gillescolling.com/couplr/reference/couplr-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"couplr: Optimal Pairing and Matching via Linear Assignment — couplr-package","text":"Maintainer: Gilles Colling gilles.colling051@gmail.com [copyright holder]","code":""},{"path":"https://gillescolling.com/couplr/reference/couplr_emoji.html","id":null,"dir":"Reference","previous_headings":"","what":"Get a themed emoji — couplr_emoji","title":"Get a themed emoji — couplr_emoji","text":"Get themed emoji","code":""},{"path":"https://gillescolling.com/couplr/reference/couplr_emoji.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get a themed emoji — couplr_emoji","text":"","code":"couplr_emoji(   type = c(\"error\", \"warning\", \"info\", \"success\", \"heart\", \"broken\", \"sparkles\",     \"search\", \"chart\", \"warning_sign\", \"stop\", \"check\") )"},{"path":"https://gillescolling.com/couplr/reference/couplr_emoji.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get a themed emoji — couplr_emoji","text":"Character string emoji (empty string emoji disabled).","code":""},{"path":"https://gillescolling.com/couplr/reference/couplr_inform.html","id":null,"dir":"Reference","previous_headings":"","what":"Info message with emoji — couplr_inform","title":"Info message with emoji — couplr_inform","text":"Info message emoji","code":""},{"path":"https://gillescolling.com/couplr/reference/couplr_inform.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Info message with emoji — couplr_inform","text":"","code":"couplr_inform(...)"},{"path":"https://gillescolling.com/couplr/reference/couplr_inform.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Info message with emoji — couplr_inform","text":"return value, called side effects (issues message).","code":""},{"path":"https://gillescolling.com/couplr/reference/couplr_messages.html","id":null,"dir":"Reference","previous_headings":"","what":"Couplr message helpers with emoji and humor — couplr_messages","title":"Couplr message helpers with emoji and humor — couplr_messages","text":"Light, fun error/warning messages inspired testthat, themed around coupling matching. Makes errors less intimidating memorable.","code":""},{"path":"https://gillescolling.com/couplr/reference/couplr_stop.html","id":null,"dir":"Reference","previous_headings":"","what":"Stop with a fun, themed error message — couplr_stop","title":"Stop with a fun, themed error message — couplr_stop","text":"Stop fun, themed error message","code":""},{"path":"https://gillescolling.com/couplr/reference/couplr_stop.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Stop with a fun, themed error message — couplr_stop","text":"","code":"couplr_stop(..., call. = FALSE)"},{"path":"https://gillescolling.com/couplr/reference/couplr_stop.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Stop with a fun, themed error message — couplr_stop","text":"return value, throws error.","code":""},{"path":"https://gillescolling.com/couplr/reference/couplr_success.html","id":null,"dir":"Reference","previous_headings":"","what":"Success message with emoji — couplr_success","title":"Success message with emoji — couplr_success","text":"Success message emoji","code":""},{"path":"https://gillescolling.com/couplr/reference/couplr_success.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Success message with emoji — couplr_success","text":"","code":"couplr_success(...)"},{"path":"https://gillescolling.com/couplr/reference/couplr_success.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Success message with emoji — couplr_success","text":"return value, called side effects (issues message).","code":""},{"path":"https://gillescolling.com/couplr/reference/couplr_warn.html","id":null,"dir":"Reference","previous_headings":"","what":"Warn with a fun, themed warning message — couplr_warn","title":"Warn with a fun, themed warning message — couplr_warn","text":"Warn fun, themed warning message","code":""},{"path":"https://gillescolling.com/couplr/reference/couplr_warn.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Warn with a fun, themed warning message — couplr_warn","text":"","code":"couplr_warn(..., call. = FALSE)"},{"path":"https://gillescolling.com/couplr/reference/couplr_warn.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Warn with a fun, themed warning message — couplr_warn","text":"return value, called side effects (issues warning).","code":""},{"path":"https://gillescolling.com/couplr/reference/detect_blocking.html","id":null,"dir":"Reference","previous_headings":"","what":"Detect and validate blocking — detect_blocking","title":"Detect and validate blocking — detect_blocking","text":"Detect validate blocking","code":""},{"path":"https://gillescolling.com/couplr/reference/detect_blocking.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Detect and validate blocking — detect_blocking","text":"","code":"detect_blocking(left, right, block_id, ignore_blocks)"},{"path":"https://gillescolling.com/couplr/reference/detect_blocking.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Detect and validate blocking — detect_blocking","text":"List use_blocking (logical) block_col (character NULL).","code":""},{"path":"https://gillescolling.com/couplr/reference/diagnose_distance_matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Diagnose distance matrix and suggest fixes — diagnose_distance_matrix","title":"Diagnose distance matrix and suggest fixes — diagnose_distance_matrix","text":"Comprehensive diagnostics distance matrix actionable suggestions.","code":""},{"path":"https://gillescolling.com/couplr/reference/diagnose_distance_matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Diagnose distance matrix and suggest fixes — diagnose_distance_matrix","text":"","code":"diagnose_distance_matrix(   cost_matrix,   left = NULL,   right = NULL,   vars = NULL,   warn = TRUE )"},{"path":"https://gillescolling.com/couplr/reference/diagnose_distance_matrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Diagnose distance matrix and suggest fixes — diagnose_distance_matrix","text":"cost_matrix Numeric matrix distances left Left dataset (variable checking) right Right dataset (variable checking) vars Variables used matching warn TRUE, issue warnings","code":""},{"path":"https://gillescolling.com/couplr/reference/diagnose_distance_matrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Diagnose distance matrix and suggest fixes — diagnose_distance_matrix","text":"List diagnostic results suggestions","code":""},{"path":"https://gillescolling.com/couplr/reference/err_invalid_param.html","id":null,"dir":"Reference","previous_headings":"","what":"Invalid parameter error — err_invalid_param","title":"Invalid parameter error — err_invalid_param","text":"Invalid parameter error","code":""},{"path":"https://gillescolling.com/couplr/reference/err_invalid_param.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Invalid parameter error — err_invalid_param","text":"","code":"err_invalid_param(param, value, expected)"},{"path":"https://gillescolling.com/couplr/reference/err_invalid_param.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Invalid parameter error — err_invalid_param","text":"return value, throws error.","code":""},{"path":"https://gillescolling.com/couplr/reference/err_missing_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Missing data error — err_missing_data","title":"Missing data error — err_missing_data","text":"Missing data error","code":""},{"path":"https://gillescolling.com/couplr/reference/err_missing_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Missing data error — err_missing_data","text":"","code":"err_missing_data(dataset = \"left\")"},{"path":"https://gillescolling.com/couplr/reference/err_missing_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Missing data error — err_missing_data","text":"return value, throws error.","code":""},{"path":"https://gillescolling.com/couplr/reference/err_missing_vars.html","id":null,"dir":"Reference","previous_headings":"","what":"Missing variables error — err_missing_vars","title":"Missing variables error — err_missing_vars","text":"Missing variables error","code":""},{"path":"https://gillescolling.com/couplr/reference/err_missing_vars.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Missing variables error — err_missing_vars","text":"","code":"err_missing_vars(vars, dataset = \"left\")"},{"path":"https://gillescolling.com/couplr/reference/err_missing_vars.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Missing variables error — err_missing_vars","text":"return value, throws error.","code":""},{"path":"https://gillescolling.com/couplr/reference/err_no_valid_pairs.html","id":null,"dir":"Reference","previous_headings":"","what":"All pairs forbidden error — err_no_valid_pairs","title":"All pairs forbidden error — err_no_valid_pairs","text":"pairs forbidden error","code":""},{"path":"https://gillescolling.com/couplr/reference/err_no_valid_pairs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"All pairs forbidden error — err_no_valid_pairs","text":"","code":"err_no_valid_pairs(reason = NULL)"},{"path":"https://gillescolling.com/couplr/reference/err_no_valid_pairs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"All pairs forbidden error — err_no_valid_pairs","text":"return value, throws error.","code":""},{"path":"https://gillescolling.com/couplr/reference/example_costs.html","id":null,"dir":"Reference","previous_headings":"","what":"Example cost matrices for assignment problems — example_costs","title":"Example cost matrices for assignment problems — example_costs","text":"Small example datasets demonstrating couplr functionality across different assignment problem types: square, rectangular, sparse, binary.","code":""},{"path":"https://gillescolling.com/couplr/reference/example_costs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Example cost matrices for assignment problems — example_costs","text":"","code":"example_costs"},{"path":"https://gillescolling.com/couplr/reference/example_costs.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Example cost matrices for assignment problems — example_costs","text":"list containing four example cost matrices: simple_3x3 3x3 cost matrix costs ranging 2-7. Optimal assignment: row 1 -> col 2 (cost 2), row 2 -> col 1 (cost 3), row 3 -> col 3 (cost 4). Total optimal cost: 9. rectangular_3x5 3x5 rectangular cost matrix demonstrating assignment rows < columns. 3 rows assigned one 5 columns; 2 columns remain unassigned. Costs range 1-6. sparse_with_na 3x3 matrix NA values indicating forbidden assignments. Use test algorithms' handling constraints. Position (1,3), (2,2), (3,1) forbidden. binary_costs 3x3 matrix binary (0/1) costs, suitable testing HK01 algorithm. Diagonal entries 0 (preferred), -diagonal entries 1 (penalty).","code":""},{"path":"https://gillescolling.com/couplr/reference/example_costs.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Example cost matrices for assignment problems — example_costs","text":"matrices designed test different aspects LAP solvers: simple_3x3: Basic functionality test. correct solver find total cost = 9. rectangular_3x5: Tests handling non-square problems. optimal solution assigns 3 rows minimum total cost. sparse_with_na: Tests constraint handling. Algorithms must avoid NA positions finding optimal assignment among valid entries. binary_costs: Tests specialized binary cost algorithms. optimal assignment uses diagonal entries (total cost = 0).","code":""},{"path":[]},{"path":"https://gillescolling.com/couplr/reference/example_costs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Example cost matrices for assignment problems — example_costs","text":"","code":"# Simple 3x3 assignment result <- lap_solve(example_costs$simple_3x3) print(result) # Optimal: sources 1,2,3 -> targets 2,1,3 with cost 9  # Rectangular problem (3 sources, 5 targets) result <- lap_solve(example_costs$rectangular_3x5) print(result) # All 3 sources assigned; 2 targets unassigned  # Sparse problem with forbidden assignments result <- lap_solve(example_costs$sparse_with_na) print(result) # Avoids NA positions  # Binary costs - test HK01 algorithm result <- lap_solve(example_costs$binary_costs, method = \"hk01\") print(result) # Finds diagonal assignment (cost = 0)"},{"path":"https://gillescolling.com/couplr/reference/example_df.html","id":null,"dir":"Reference","previous_headings":"","what":"Example assignment problem data frame — example_df","title":"Example assignment problem data frame — example_df","text":"tidy data frame representation assignment problems, suitable use grouped workflows batch solving. Contains two independent 3x3 assignment problems long format.","code":""},{"path":"https://gillescolling.com/couplr/reference/example_df.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Example assignment problem data frame — example_df","text":"","code":"example_df"},{"path":"https://gillescolling.com/couplr/reference/example_df.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Example assignment problem data frame — example_df","text":"tibble 18 rows 4 columns: sim Simulation/problem identifier. Integer values 1 2, distinguishing two independent assignment problems. Use group_by(sim) grouped solving. source Source node index. Integer 1-3 representing row (source) 3x3 cost matrix. target Target node index. Integer 1-3 representing column (target) 3x3 cost matrix. cost Cost assigning source target. Numeric values ranging 1-7. source-target pair exactly one cost entry.","code":""},{"path":"https://gillescolling.com/couplr/reference/example_df.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Example assignment problem data frame — example_df","text":"dataset demonstrates couplr's data frame interface LAP solving. long format (one row per source-target pair) converted internally cost matrix solving. Simulation 1: Costs example_costs$simple_3x3 Optimal assignment: (1->2, 2->1, 3->3) Total cost: 9 Simulation 2: Different cost structure Optimal assignment: (1->1, 2->3, 3->3) equivalent Total cost: 4","code":""},{"path":[]},{"path":"https://gillescolling.com/couplr/reference/example_df.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Example assignment problem data frame — example_df","text":"","code":"library(dplyr)  # Solve both problems with grouped workflow example_df |>   group_by(sim) |>   lap_solve(source, target, cost)  # Batch solving for efficiency example_df |>   group_by(sim) |>   lap_solve_batch(source, target, cost)  # Inspect the data structure example_df |>   group_by(sim) |>   summarise(     n_pairs = n(),     min_cost = min(cost),     max_cost = max(cost)   )"},{"path":"https://gillescolling.com/couplr/reference/extract_ids.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract and standardize IDs from data frames — extract_ids","title":"Extract and standardize IDs from data frames — extract_ids","text":"Extract standardize IDs data frames","code":""},{"path":"https://gillescolling.com/couplr/reference/extract_ids.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract and standardize IDs from data frames — extract_ids","text":"","code":"extract_ids(df, prefix = \"id\")"},{"path":"https://gillescolling.com/couplr/reference/extract_ids.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract and standardize IDs from data frames — extract_ids","text":"Character vector IDs.","code":""},{"path":"https://gillescolling.com/couplr/reference/extract_matching_vars.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract matching variables from data frame — extract_matching_vars","title":"Extract matching variables from data frame — extract_matching_vars","text":"Extract matching variables data frame","code":""},{"path":"https://gillescolling.com/couplr/reference/extract_matching_vars.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract matching variables from data frame — extract_matching_vars","text":"","code":"extract_matching_vars(df, vars)"},{"path":"https://gillescolling.com/couplr/reference/extract_matching_vars.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract matching variables from data frame — extract_matching_vars","text":"Numeric matrix matching variables.","code":""},{"path":"https://gillescolling.com/couplr/reference/filter_blocks.html","id":null,"dir":"Reference","previous_headings":"","what":"Filter blocks based on size and balance criteria — filter_blocks","title":"Filter blocks based on size and balance criteria — filter_blocks","text":"Filter blocks based size balance criteria","code":""},{"path":"https://gillescolling.com/couplr/reference/filter_blocks.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Filter blocks based on size and balance criteria — filter_blocks","text":"","code":"filter_blocks(   left,   right,   min_left,   min_right,   drop_imbalanced,   imbalance_threshold )"},{"path":"https://gillescolling.com/couplr/reference/filter_blocks.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Filter blocks based on size and balance criteria — filter_blocks","text":"List filtered left/right data frames dropped block info.","code":""},{"path":"https://gillescolling.com/couplr/reference/get_block_id_column.html","id":null,"dir":"Reference","previous_headings":"","what":"Standardize block ID column name — get_block_id_column","title":"Standardize block ID column name — get_block_id_column","text":"Standardize block ID column name","code":""},{"path":"https://gillescolling.com/couplr/reference/get_block_id_column.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Standardize block ID column name — get_block_id_column","text":"","code":"get_block_id_column(df)"},{"path":"https://gillescolling.com/couplr/reference/get_block_id_column.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Standardize block ID column name — get_block_id_column","text":"Character string column name, NULL found.","code":""},{"path":"https://gillescolling.com/couplr/reference/get_method_used.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract method used from assignment result — get_method_used","title":"Extract method used from assignment result — get_method_used","text":"Extract method used assignment result","code":""},{"path":"https://gillescolling.com/couplr/reference/get_method_used.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract method used from assignment result — get_method_used","text":"","code":"get_method_used(x)"},{"path":"https://gillescolling.com/couplr/reference/get_method_used.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract method used from assignment result — get_method_used","text":"x assignment result object","code":""},{"path":"https://gillescolling.com/couplr/reference/get_method_used.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract method used from assignment result — get_method_used","text":"Character string indicating method used","code":""},{"path":"https://gillescolling.com/couplr/reference/get_total_cost.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract total cost from assignment result — get_total_cost","title":"Extract total cost from assignment result — get_total_cost","text":"Extract total cost assignment result","code":""},{"path":"https://gillescolling.com/couplr/reference/get_total_cost.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract total cost from assignment result — get_total_cost","text":"","code":"get_total_cost(x)"},{"path":"https://gillescolling.com/couplr/reference/get_total_cost.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract total cost from assignment result — get_total_cost","text":"x assignment result object","code":""},{"path":"https://gillescolling.com/couplr/reference/get_total_cost.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract total cost from assignment result — get_total_cost","text":"Numeric total cost","code":""},{"path":"https://gillescolling.com/couplr/reference/greedy_blocks_parallel.html","id":null,"dir":"Reference","previous_headings":"","what":"Greedy match blocks in parallel — greedy_blocks_parallel","title":"Greedy match blocks in parallel — greedy_blocks_parallel","text":"Greedy match blocks parallel","code":""},{"path":"https://gillescolling.com/couplr/reference/greedy_blocks_parallel.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Greedy match blocks in parallel — greedy_blocks_parallel","text":"","code":"greedy_blocks_parallel(   blocks,   left,   right,   left_ids,   right_ids,   block_col,   vars,   distance,   weights,   scale,   max_distance,   calipers,   strategy,   parallel = FALSE )"},{"path":"https://gillescolling.com/couplr/reference/greedy_blocks_parallel.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Greedy match blocks in parallel — greedy_blocks_parallel","text":"blocks Vector block IDs left Left dataset block_col right Right dataset block_col left_ids IDs left right_ids IDs right block_col Name blocking column vars Variables matching distance Distance metric weights Variable weights scale Scaling method max_distance Maximum distance calipers Caliper constraints strategy Greedy strategy parallel Whether use parallel processing","code":""},{"path":"https://gillescolling.com/couplr/reference/greedy_blocks_parallel.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Greedy match blocks in parallel — greedy_blocks_parallel","text":"List combined results blocks","code":""},{"path":"https://gillescolling.com/couplr/reference/greedy_couples.html","id":null,"dir":"Reference","previous_headings":"","what":"Fast approximate matching using greedy algorithm — greedy_couples","title":"Fast approximate matching using greedy algorithm — greedy_couples","text":"Performs fast one--one matching using greedy strategies. guarantee optimal total distance much faster match_couples() large datasets. Supports blocking, distance constraints, various distance metrics.","code":""},{"path":"https://gillescolling.com/couplr/reference/greedy_couples.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fast approximate matching using greedy algorithm — greedy_couples","text":"","code":"greedy_couples(   left,   right = NULL,   vars = NULL,   distance = \"euclidean\",   weights = NULL,   scale = FALSE,   auto_scale = FALSE,   max_distance = Inf,   calipers = NULL,   block_id = NULL,   ignore_blocks = FALSE,   require_full_matching = FALSE,   strategy = c(\"row_best\", \"sorted\", \"pq\"),   return_unmatched = TRUE,   return_diagnostics = FALSE,   parallel = FALSE,   check_costs = TRUE )"},{"path":"https://gillescolling.com/couplr/reference/greedy_couples.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fast approximate matching using greedy algorithm — greedy_couples","text":"left Data frame \"left\" units (e.g., treated, cases) right Data frame \"right\" units (e.g., control, controls) vars Variable names use distance computation distance Distance metric: \"euclidean\", \"manhattan\", \"mahalanobis\", custom function weights Optional named vector variable weights scale Scaling method: FALSE (none), \"standardize\", \"range\", \"robust\" auto_scale TRUE, automatically check variable health select scaling method (default: FALSE) max_distance Maximum allowed distance (pairs exceeding forbidden) calipers Named list per-variable maximum absolute differences block_id Column name containing block IDs (stratified matching) ignore_blocks TRUE, ignore block_id even present require_full_matching TRUE, error units remain unmatched strategy Greedy strategy: \"row_best\": row, find best available column (default) \"sorted\": Sort pairs distance, greedily assign \"pq\": Use priority queue (good large problems) return_unmatched Include unmatched units output return_diagnostics Include detailed diagnostics output parallel Enable parallel processing blocked matching. Requires 'future' 'future.apply' packages. Can : FALSE: Sequential processing (default) TRUE: Auto-configure parallel backend Character: Specify future plan (e.g., \"multisession\", \"multicore\") check_costs TRUE, check distance distribution potential problems provide helpful warnings matching (default: TRUE)","code":""},{"path":"https://gillescolling.com/couplr/reference/greedy_couples.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fast approximate matching using greedy algorithm — greedy_couples","text":"list class \"matching_result\" (structure match_couples)","code":""},{"path":"https://gillescolling.com/couplr/reference/greedy_couples.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Fast approximate matching using greedy algorithm — greedy_couples","text":"Greedy strategies guarantee optimal total distance much faster: \"row_best\": O(n*m) time, simple often produces good results \"sorted\": O(nmlog(n*m)) time, better quality slower \"pq\": O(nmlog(n*m)) time, memory-efficient large problems Use greedy_couples : Dataset large (> 10,000 x 10,000) Approximate solution acceptable Speed important optimality","code":""},{"path":"https://gillescolling.com/couplr/reference/greedy_couples.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fast approximate matching using greedy algorithm — greedy_couples","text":"","code":"# Basic greedy matching left <- data.frame(id = 1:100, x = rnorm(100)) right <- data.frame(id = 101:200, x = rnorm(100)) result <- greedy_couples(left, right, vars = \"x\")  # Compare to optimal result_opt <- match_couples(left, right, vars = \"x\") result_greedy <- greedy_couples(left, right, vars = \"x\") result_greedy$info$total_distance / result_opt$info$total_distance  # Quality ratio"},{"path":"https://gillescolling.com/couplr/reference/greedy_couples_blocked.html","id":null,"dir":"Reference","previous_headings":"","what":"Greedy matching with blocking — greedy_couples_blocked","title":"Greedy matching with blocking — greedy_couples_blocked","text":"Greedy matching blocking","code":""},{"path":"https://gillescolling.com/couplr/reference/greedy_couples_blocked.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Greedy matching with blocking — greedy_couples_blocked","text":"","code":"greedy_couples_blocked(   left,   right,   left_ids,   right_ids,   block_col,   vars,   distance,   weights,   scale,   max_distance,   calipers,   strategy,   parallel = FALSE )"},{"path":"https://gillescolling.com/couplr/reference/greedy_couples_blocked.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Greedy matching with blocking — greedy_couples_blocked","text":"List pairs tibble matching info.","code":""},{"path":"https://gillescolling.com/couplr/reference/greedy_couples_from_distance.html","id":null,"dir":"Reference","previous_headings":"","what":"Greedy Matching from Precomputed Distance Object — greedy_couples_from_distance","title":"Greedy Matching from Precomputed Distance Object — greedy_couples_from_distance","text":"Internal function handle greedy matching distance_object provided","code":""},{"path":"https://gillescolling.com/couplr/reference/greedy_couples_from_distance.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Greedy Matching from Precomputed Distance Object — greedy_couples_from_distance","text":"","code":"greedy_couples_from_distance(   dist_obj,   max_distance = Inf,   calipers = NULL,   ignore_blocks = FALSE,   require_full_matching = FALSE,   strategy = \"row_best\",   return_unmatched = TRUE,   return_diagnostics = FALSE )"},{"path":"https://gillescolling.com/couplr/reference/greedy_couples_from_distance.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Greedy Matching from Precomputed Distance Object — greedy_couples_from_distance","text":"matching_result object pairs, info, optional diagnostics.","code":""},{"path":"https://gillescolling.com/couplr/reference/greedy_couples_single.html","id":null,"dir":"Reference","previous_headings":"","what":"Greedy matching without blocking — greedy_couples_single","title":"Greedy matching without blocking — greedy_couples_single","text":"Greedy matching without blocking","code":""},{"path":"https://gillescolling.com/couplr/reference/greedy_couples_single.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Greedy matching without blocking — greedy_couples_single","text":"","code":"greedy_couples_single(   left,   right,   left_ids,   right_ids,   vars,   distance,   weights,   scale,   max_distance,   calipers,   strategy )"},{"path":"https://gillescolling.com/couplr/reference/greedy_couples_single.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Greedy matching without blocking — greedy_couples_single","text":"List pairs tibble matching info.","code":""},{"path":"https://gillescolling.com/couplr/reference/group_by.html","id":null,"dir":"Reference","previous_headings":"","what":"Re-export of dplyr::group_by — group_by","title":"Re-export of dplyr::group_by — group_by","text":"Re-export dplyr::group_by","code":""},{"path":"https://gillescolling.com/couplr/reference/group_by.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Re-export of dplyr::group_by — group_by","text":"See group_by.","code":""},{"path":"https://gillescolling.com/couplr/reference/has_blocks.html","id":null,"dir":"Reference","previous_headings":"","what":"Check if data frame has blocking information — has_blocks","title":"Check if data frame has blocking information — has_blocks","text":"Check data frame blocking information","code":""},{"path":"https://gillescolling.com/couplr/reference/has_blocks.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check if data frame has blocking information — has_blocks","text":"","code":"has_blocks(df)"},{"path":"https://gillescolling.com/couplr/reference/has_blocks.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check if data frame has blocking information — has_blocks","text":"Logical indicating whether data frame block ID column.","code":""},{"path":"https://gillescolling.com/couplr/reference/has_valid_pairs.html","id":null,"dir":"Reference","previous_headings":"","what":"Check if any valid pairs exist — has_valid_pairs","title":"Check if any valid pairs exist — has_valid_pairs","text":"Check valid pairs exist","code":""},{"path":"https://gillescolling.com/couplr/reference/has_valid_pairs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check if any valid pairs exist — has_valid_pairs","text":"","code":"has_valid_pairs(cost_matrix)"},{"path":"https://gillescolling.com/couplr/reference/has_valid_pairs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check if any valid pairs exist — has_valid_pairs","text":"Logical indicating whether valid pairs exist.","code":""},{"path":"https://gillescolling.com/couplr/reference/hospital_staff.html","id":null,"dir":"Reference","previous_headings":"","what":"Hospital staff scheduling example dataset — hospital_staff","title":"Hospital staff scheduling example dataset — hospital_staff","text":"comprehensive example dataset demonstrating couplr functionality across vignettes. Contains hospital staff scheduling data nurses, shifts, costs, preference scores suitable assignment problems, well nurse characteristics matching workflows.","code":""},{"path":"https://gillescolling.com/couplr/reference/hospital_staff.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Hospital staff scheduling example dataset — hospital_staff","text":"","code":"hospital_staff"},{"path":"https://gillescolling.com/couplr/reference/hospital_staff.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Hospital staff scheduling example dataset — hospital_staff","text":"list containing eight related datasets: basic_costs 10x10 numeric cost matrix assigning 10 nurses 10 shifts. Values range approximately 1-15, lower values indicate better fit (less overtime, matches skills, respects preferences). Use lap_solve() basic assignment. preferences 10x10 numeric preference matrix 0-10 scale, higher values indicate stronger nurse preference shift. Use lap_solve(..., maximize = TRUE) optimize preferences rather minimize costs. schedule_df tibble 100 rows (10 nurses x 10 shifts) long format data frame workflows: nurse_id Integer 1-10. Unique identifier nurse. shift_id Integer 1-10. Unique identifier shift. cost Numeric. Assignment cost (values basic_costs). preference Numeric 0-10. Nurse preference score. skill_match Integer 0/1. Binary indicator: 1 nurse skills match shift requirements, 0 otherwise. nurses tibble 10 rows describing nurse characteristics: nurse_id Integer 1-10. Links schedule_df basic_costs rows. experience_years Numeric 1-20. Years nursing experience. department Character. Primary department: \"ICU\", \"ER\", \"General\", \"Pediatrics\". shift_preference Character. Preferred shift type: \"day\", \"evening\", \"night\". certification_level Integer 1-3. Certification level 3 highest (e.g., 1=RN, 2=BSN, 3=MSN). shifts tibble 10 rows describing shift requirements: shift_id Integer 1-10. Links schedule_df basic_costs cols. department Character. Department needing coverage. shift_type Character. Shift type: \"day\", \"evening\", \"night\". min_experience Numeric. Minimum years experience required. min_certification Integer 1-3. Minimum certification level. weekly_df tibble batch solving 500 rows (5 days x 10 nurses x 10 shifts): day Character. Day week: \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\". nurse_id Integer 1-10. Nurse identifier. shift_id Integer 1-10. Shift identifier. cost Numeric. Daily assignment cost (varies day). preference Numeric 0-10. Daily preference score. Use group_by(day) solving day's schedule. nurses_extended tibble 200 nurses matching examples, representing treatment group (e.g., full-time nurses): nurse_id Integer 1-200. Unique identifier. age Numeric 22-65. Nurse age years. experience_years Numeric 0-40. Years nursing experience. hourly_rate Numeric 25-75. Hourly wage dollars. department Character. Primary department assignment. certification_level Integer 1-3. Certification level. is_fulltime Logical. TRUE full-time status. controls_extended tibble 300 potential control nurses (e.g., part-time registry nurses) matching. structure nurses_extended. Designed systematic differences nurses_extended (older, less experience average) demonstrate matching's ability create comparable groups.","code":""},{"path":"https://gillescolling.com/couplr/reference/hospital_staff.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Hospital staff scheduling example dataset — hospital_staff","text":"dataset used throughout couplr documentation provide consistent, realistic example evolves complexity. supports three use cases: (1) basic LAP solving cost matrices, (2) batch solving across multiple days, (3) matching workflows comparing nurse groups. dataset designed demonstrate progressively complex scenarios: Basic LAP (vignette(\"getting-started\")): basic_costs: Simple 10x10 assignment preferences: Maximization problem schedule_df: Data frame input, grouped workflows weekly_df: Batch solving across days Algorithm comparison (vignette(\"algorithms\")): Use basic_costs compare algorithm behavior Modify NA values sparse scenarios Matching workflows (vignette(\"matching-workflows\")): nurses_extended: Treatment group (full-time nurses) controls_extended: Control pool (part-time/registry nurses) Match age, experience, department causal analysis","code":""},{"path":[]},{"path":"https://gillescolling.com/couplr/reference/hospital_staff.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Hospital staff scheduling example dataset — hospital_staff","text":"","code":"# Basic assignment: assign nurses to shifts minimizing cost lap_solve(hospital_staff$basic_costs)  # Maximize preferences instead lap_solve(hospital_staff$preferences, maximize = TRUE)  # Data frame workflow library(dplyr) hospital_staff$schedule_df |>   lap_solve(nurse_id, shift_id, cost)  # Batch solve weekly schedule hospital_staff$weekly_df |>   group_by(day) |>   lap_solve(nurse_id, shift_id, cost)  # Matching workflow: match full-time to part-time nurses match_couples(   left = hospital_staff$nurses_extended,   right = hospital_staff$controls_extended,   vars = c(\"age\", \"experience_years\", \"certification_level\"),   auto_scale = TRUE )"},{"path":"https://gillescolling.com/couplr/reference/info_low_match_rate.html","id":null,"dir":"Reference","previous_headings":"","what":"Low match rate info — info_low_match_rate","title":"Low match rate info — info_low_match_rate","text":"Low match rate info","code":""},{"path":"https://gillescolling.com/couplr/reference/info_low_match_rate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Low match rate info — info_low_match_rate","text":"","code":"info_low_match_rate(n_matched, n_left, pct)"},{"path":"https://gillescolling.com/couplr/reference/info_low_match_rate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Low match rate info — info_low_match_rate","text":"return value, called side effects (issues message warning).","code":""},{"path":"https://gillescolling.com/couplr/reference/is_distance_object.html","id":null,"dir":"Reference","previous_headings":"","what":"Check if Object is a Distance Object — is_distance_object","title":"Check if Object is a Distance Object — is_distance_object","text":"Check Object Distance Object","code":""},{"path":"https://gillescolling.com/couplr/reference/is_distance_object.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check if Object is a Distance Object — is_distance_object","text":"","code":"is_distance_object(x)"},{"path":"https://gillescolling.com/couplr/reference/is_distance_object.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check if Object is a Distance Object — is_distance_object","text":"x Object check","code":""},{"path":"https://gillescolling.com/couplr/reference/is_distance_object.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check if Object is a Distance Object — is_distance_object","text":"Logical: TRUE x distance_object","code":""},{"path":"https://gillescolling.com/couplr/reference/is_distance_object.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check if Object is a Distance Object — is_distance_object","text":"","code":"left <- data.frame(id = 1:3, x = c(1, 2, 3)) right <- data.frame(id = 4:6, x = c(1.1, 2.1, 3.1)) dist_obj <- compute_distances(left, right, vars = \"x\") is_distance_object(dist_obj)  # TRUE is_distance_object(list())    # FALSE"},{"path":"https://gillescolling.com/couplr/reference/is_lap_solve_batch_result.html","id":null,"dir":"Reference","previous_headings":"","what":"Check if object is a batch assignment result — is_lap_solve_batch_result","title":"Check if object is a batch assignment result — is_lap_solve_batch_result","text":"Check object batch assignment result","code":""},{"path":"https://gillescolling.com/couplr/reference/is_lap_solve_batch_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check if object is a batch assignment result — is_lap_solve_batch_result","text":"","code":"is_lap_solve_batch_result(x)"},{"path":"https://gillescolling.com/couplr/reference/is_lap_solve_batch_result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check if object is a batch assignment result — is_lap_solve_batch_result","text":"x Object test","code":""},{"path":"https://gillescolling.com/couplr/reference/is_lap_solve_batch_result.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check if object is a batch assignment result — is_lap_solve_batch_result","text":"Logical indicating x batch assignment result","code":""},{"path":"https://gillescolling.com/couplr/reference/is_lap_solve_kbest_result.html","id":null,"dir":"Reference","previous_headings":"","what":"Check if object is a k-best assignment result — is_lap_solve_kbest_result","title":"Check if object is a k-best assignment result — is_lap_solve_kbest_result","text":"Check object k-best assignment result","code":""},{"path":"https://gillescolling.com/couplr/reference/is_lap_solve_kbest_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check if object is a k-best assignment result — is_lap_solve_kbest_result","text":"","code":"is_lap_solve_kbest_result(x)"},{"path":"https://gillescolling.com/couplr/reference/is_lap_solve_kbest_result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check if object is a k-best assignment result — is_lap_solve_kbest_result","text":"x Object test","code":""},{"path":"https://gillescolling.com/couplr/reference/is_lap_solve_kbest_result.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check if object is a k-best assignment result — is_lap_solve_kbest_result","text":"Logical indicating x k-best assignment result","code":""},{"path":"https://gillescolling.com/couplr/reference/is_lap_solve_result.html","id":null,"dir":"Reference","previous_headings":"","what":"Check if object is an assignment result — is_lap_solve_result","title":"Check if object is an assignment result — is_lap_solve_result","text":"Check object assignment result","code":""},{"path":"https://gillescolling.com/couplr/reference/is_lap_solve_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check if object is an assignment result — is_lap_solve_result","text":"","code":"is_lap_solve_result(x)"},{"path":"https://gillescolling.com/couplr/reference/is_lap_solve_result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check if object is an assignment result — is_lap_solve_result","text":"x Object test","code":""},{"path":"https://gillescolling.com/couplr/reference/is_lap_solve_result.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check if object is an assignment result — is_lap_solve_result","text":"Logical indicating x assignment result","code":""},{"path":"https://gillescolling.com/couplr/reference/join_matched.html","id":null,"dir":"Reference","previous_headings":"","what":"Join Matched Pairs with Original Data — join_matched","title":"Join Matched Pairs with Original Data — join_matched","text":"Creates analysis-ready dataset joining matched pairs variables original left right datasets. eliminates need manual joins provides convenient format downstream analysis.","code":""},{"path":"https://gillescolling.com/couplr/reference/join_matched.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Join Matched Pairs with Original Data — join_matched","text":"","code":"join_matched(   result,   left,   right,   left_vars = NULL,   right_vars = NULL,   left_id = \"id\",   right_id = \"id\",   suffix = c(\"_left\", \"_right\"),   include_distance = TRUE,   include_pair_id = TRUE,   include_block_id = TRUE )"},{"path":"https://gillescolling.com/couplr/reference/join_matched.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Join Matched Pairs with Original Data — join_matched","text":"result matching_result object match_couples() greedy_couples() left original left dataset right original right dataset left_vars Character vector variable names include left. NULL (default), includes variables except ID column. right_vars Character vector variable names include right. NULL (default), includes variables except ID column. left_id Name ID column left dataset (default: \"id\") right_id Name ID column right dataset (default: \"id\") suffix Character vector length 2 specifying suffixes left right variables (default: c(\"_left\", \"_right\")) include_distance Include matching distance output (default: TRUE) include_pair_id Include pair_id column (default: TRUE) include_block_id Include block_id blocking used (default: TRUE)","code":""},{"path":"https://gillescolling.com/couplr/reference/join_matched.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Join Matched Pairs with Original Data — join_matched","text":"tibble one row per matched pair, containing: pair_id: Sequential pair identifier (include_pair_id = TRUE) left_id: ID left dataset right_id: ID right dataset distance: Matching distance (include_distance = TRUE) block_id: Block identifier (blocking used include_block_id = TRUE) Variables left dataset (left suffix) Variables right dataset (right suffix)","code":""},{"path":"https://gillescolling.com/couplr/reference/join_matched.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Join Matched Pairs with Original Data — join_matched","text":"function simplifies common workflow joining matched pairs original data. Instead manually merging result$pairs left right datasets, join_matched() handles joins automatically applies consistent naming conventions. variables appear left right datasets, suffixes appended distinguish (e.g., \"age_left\" \"age_right\"). makes easy compute differences use values models.","code":""},{"path":"https://gillescolling.com/couplr/reference/join_matched.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Join Matched Pairs with Original Data — join_matched","text":"","code":"# Basic usage left <- data.frame(   id = 1:5,   treatment = 1,   age = c(25, 30, 35, 40, 45),   income = c(45000, 52000, 48000, 61000, 55000) )  right <- data.frame(   id = 6:10,   treatment = 0,   age = c(24, 29, 36, 41, 44),   income = c(46000, 51500, 47500, 60000, 54000) )  result <- match_couples(left, right, vars = c(\"age\", \"income\")) matched_data <- join_matched(result, left, right) head(matched_data)  # Specify which variables to include matched_data <- join_matched(   result, left, right,   left_vars = c(\"treatment\", \"age\", \"income\"),   right_vars = c(\"age\", \"income\"),   suffix = c(\"_treated\", \"_control\") )  # Without distance or pair_id matched_data <- join_matched(   result, left, right,   include_distance = FALSE,   include_pair_id = FALSE )"},{"path":"https://gillescolling.com/couplr/reference/lap_solve.html","id":null,"dir":"Reference","previous_headings":"","what":"Solve linear assignment problems — lap_solve","title":"Solve linear assignment problems — lap_solve","text":"Provides tidy interface solving linear assignment problem using 'Hungarian' 'Jonker-Volgenant' algorithms. Supports rectangular matrices, NA/Inf masking, data frame inputs.","code":""},{"path":"https://gillescolling.com/couplr/reference/lap_solve.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Solve linear assignment problems — lap_solve","text":"","code":"lap_solve(   x,   source = NULL,   target = NULL,   cost = NULL,   maximize = FALSE,   method = \"auto\",   forbidden = NA )"},{"path":"https://gillescolling.com/couplr/reference/lap_solve.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Solve linear assignment problems — lap_solve","text":"x Cost matrix, data frame, tibble. data frame/tibble, must include columns specified source, target, cost. source Column name source/row indices (x data frame) target Column name target/column indices (x data frame) cost Column name costs (x data frame) maximize Logical; TRUE, maximizes total cost instead minimizing (default: FALSE) method Algorithm use. One : \"auto\" (default): automatically selects best algorithm \"jv\": 'Jonker-Volgenant' algorithm (general purpose, fast) \"hungarian\": Classic 'Hungarian' algorithm \"auction\": 'Bertsekas' auction algorithm (good large dense problems) \"sap\": Sparse assignment (good sparse/rectangular problems) \"hk01\": 'Hopcroft-Karp' binary/uniform costs forbidden Value mark forbidden assignments (default: NA). Can also use Inf.","code":""},{"path":"https://gillescolling.com/couplr/reference/lap_solve.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Solve linear assignment problems — lap_solve","text":"tibble columns: source: row/source indices target: column/target indices cost: cost assignment total_cost: total cost (attribute)","code":""},{"path":"https://gillescolling.com/couplr/reference/lap_solve.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Solve linear assignment problems — lap_solve","text":"","code":"# Matrix input cost <- matrix(c(4, 2, 5, 3, 3, 6, 7, 5, 4), nrow = 3) lap_solve(cost)  # Data frame input library(dplyr) df <- tibble(   source = rep(1:3, each = 3),   target = rep(1:3, times = 3),   cost = c(4, 2, 5, 3, 3, 6, 7, 5, 4) ) lap_solve(df, source, target, cost)  # With NA masking (forbidden assignments) cost[1, 3] <- NA lap_solve(cost)  # Grouped data frames df <- tibble(   sim = rep(1:2, each = 9),   source = rep(1:3, times = 6),   target = rep(1:3, each = 3, times = 2),   cost = runif(18, 1, 10) ) df |> group_by(sim) |> lap_solve(source, target, cost)"},{"path":"https://gillescolling.com/couplr/reference/lap_solve_batch.html","id":null,"dir":"Reference","previous_headings":"","what":"Solve multiple assignment problems efficiently — lap_solve_batch","title":"Solve multiple assignment problems efficiently — lap_solve_batch","text":"Solve many independent assignment problems . Supports lists matrices, 3D arrays, grouped data frames. Optional parallel execution via n_threads.","code":""},{"path":"https://gillescolling.com/couplr/reference/lap_solve_batch.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Solve multiple assignment problems efficiently — lap_solve_batch","text":"","code":"lap_solve_batch(   x,   source = NULL,   target = NULL,   cost = NULL,   maximize = FALSE,   method = \"auto\",   n_threads = 1,   forbidden = NA )"},{"path":"https://gillescolling.com/couplr/reference/lap_solve_batch.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Solve multiple assignment problems efficiently — lap_solve_batch","text":"x One : List cost matrices, 3D array, grouped data frame source Column name source indices (x grouped data frame) target Column name target indices (x grouped data frame) cost Column name costs (x grouped data frame) maximize Logical; TRUE, maximizes total cost (default: FALSE) method Algorithm use (default: \"auto\"). See lap_solve options. n_threads Number threads parallel execution (default: 1). Set NULL use available cores. forbidden Value mark forbidden assignments (default: NA)","code":""},{"path":"https://gillescolling.com/couplr/reference/lap_solve_batch.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Solve multiple assignment problems efficiently — lap_solve_batch","text":"tibble columns: problem_id: identifier problem source: source indices assignments target: target indices assignments cost: cost assignment total_cost: total cost problem method_used: algorithm used problem","code":""},{"path":"https://gillescolling.com/couplr/reference/lap_solve_batch.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Solve multiple assignment problems efficiently — lap_solve_batch","text":"","code":"# List of matrices costs <- list(   matrix(c(1, 2, 3, 4), 2, 2),   matrix(c(5, 6, 7, 8), 2, 2) ) lap_solve_batch(costs)  # 3D array arr <- array(runif(2 * 2 * 10), dim = c(2, 2, 10)) lap_solve_batch(arr)  # Grouped data frame library(dplyr) df <- tibble(   sim = rep(1:5, each = 9),   source = rep(1:3, times = 15),   target = rep(1:3, each = 3, times = 5),   cost = runif(45, 1, 10) ) df |> group_by(sim) |> lap_solve_batch(source, target, cost)  # Parallel execution (requires n_threads > 1) lap_solve_batch(costs, n_threads = 2)"},{"path":"https://gillescolling.com/couplr/reference/lap_solve_kbest.html","id":null,"dir":"Reference","previous_headings":"","what":"Find k-best optimal assignments — lap_solve_kbest","title":"Find k-best optimal assignments — lap_solve_kbest","text":"Returns top k optimal (near-optimal) assignments using 'Murty' algorithm. Useful exploring alternative optimal solutions finding robust assignments.","code":""},{"path":"https://gillescolling.com/couplr/reference/lap_solve_kbest.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find k-best optimal assignments — lap_solve_kbest","text":"","code":"lap_solve_kbest(   x,   k = 3,   source = NULL,   target = NULL,   cost = NULL,   maximize = FALSE,   method = \"murty\",   single_method = \"jv\",   forbidden = NA )"},{"path":"https://gillescolling.com/couplr/reference/lap_solve_kbest.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find k-best optimal assignments — lap_solve_kbest","text":"x Cost matrix, data frame, tibble. data frame/tibble, must include columns specified source, target, cost. k Number best solutions return (default: 3) source Column name source/row indices (x data frame) target Column name target/column indices (x data frame) cost Column name costs (x data frame) maximize Logical; TRUE, finds k-best maximizing assignments (default: FALSE) method Algorithm sub-problem (default: \"murty\"). Future versions may support additional methods. single_method Algorithm used solving node search tree (default: \"jv\") forbidden Value mark forbidden assignments (default: NA)","code":""},{"path":"https://gillescolling.com/couplr/reference/lap_solve_kbest.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find k-best optimal assignments — lap_solve_kbest","text":"tibble columns: rank: ranking solutions (1 = best, 2 = second best, etc.) solution_id: unique identifier solution source: source indices target: target indices cost: cost edge assignment total_cost: total cost complete solution","code":""},{"path":"https://gillescolling.com/couplr/reference/lap_solve_kbest.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Find k-best optimal assignments — lap_solve_kbest","text":"","code":"# Matrix input - find 5 best solutions cost <- matrix(c(4, 2, 5, 3, 3, 6, 7, 5, 4), nrow = 3) lap_solve_kbest(cost, k = 5)  # Data frame input library(dplyr) df <- tibble(   source = rep(1:3, each = 3),   target = rep(1:3, times = 3),   cost = c(4, 2, 5, 3, 3, 6, 7, 5, 4) ) lap_solve_kbest(df, k = 3, source, target, cost)  # With maximization lap_solve_kbest(cost, k = 3, maximize = TRUE)"},{"path":"https://gillescolling.com/couplr/reference/lap_solve_line_metric.html","id":null,"dir":"Reference","previous_headings":"","what":"Solve 1-D Line Assignment Problem — lap_solve_line_metric","title":"Solve 1-D Line Assignment Problem — lap_solve_line_metric","text":"Solves linear assignment problem sources targets ordered points line. Uses efficient O(n*m) dynamic programming rectangular problems O(n) sorting square problems.","code":""},{"path":"https://gillescolling.com/couplr/reference/lap_solve_line_metric.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Solve 1-D Line Assignment Problem — lap_solve_line_metric","text":"","code":"lap_solve_line_metric(x, y, cost = \"L1\", maximize = FALSE)"},{"path":"https://gillescolling.com/couplr/reference/lap_solve_line_metric.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Solve 1-D Line Assignment Problem — lap_solve_line_metric","text":"x Numeric vector source positions (sorted internally) y Numeric vector target positions (sorted internally) cost Cost function distance. Either: \"L1\" (default): absolute distance ('Manhattan' distance) \"L2\": squared distance (squared 'Euclidean' distance) Can also use aliases: \"abs\", \"manhattan\" L1; \"sq\", \"squared\", \"quadratic\" L2 maximize Logical; TRUE, maximizes total cost instead minimizing (default: FALSE)","code":""},{"path":"https://gillescolling.com/couplr/reference/lap_solve_line_metric.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Solve 1-D Line Assignment Problem — lap_solve_line_metric","text":"list components: match: Integer vector length n 1-based column indices total_cost: Total cost assignment","code":""},{"path":"https://gillescolling.com/couplr/reference/lap_solve_line_metric.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Solve 1-D Line Assignment Problem — lap_solve_line_metric","text":"specialized solver exploits structure 1-dimensional assignment problems costs depend distance points line. much faster general LAP solvers special case. algorithm works follows: Square case (n == m): vectors sorted matched order: x[1] -> y[1], x[2] -> y[2], etc. optimal metric cost function line. Rectangular case (n < m): Uses dynamic programming find optimal assignment matches n sources subset m targets, minimizing total distance. DP recurrence : dp[][j] = min(dp[][j-1], dp[-1][j-1] + cost(x[], y[j])) finds minimum cost match first sources first j targets. Complexity: Time: O(n*m) rectangular, O(n log n) square Space: O(n*m) DP table","code":""},{"path":"https://gillescolling.com/couplr/reference/lap_solve_line_metric.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Solve 1-D Line Assignment Problem — lap_solve_line_metric","text":"","code":"# Square case: equal number of sources and targets x <- c(1.5, 3.2, 5.1) y <- c(2.0, 3.0, 5.5) result <- lap_solve_line_metric(x, y, cost = \"L1\") print(result)  # Rectangular case: more targets than sources x <- c(1.0, 3.0, 5.0) y <- c(0.5, 2.0, 3.5, 4.5, 6.0) result <- lap_solve_line_metric(x, y, cost = \"L2\") print(result)  # With unsorted inputs (will be sorted internally) x <- c(5.0, 1.0, 3.0) y <- c(4.5, 0.5, 6.0, 2.0, 3.5) result <- lap_solve_line_metric(x, y, cost = \"L1\") print(result)"},{"path":"https://gillescolling.com/couplr/reference/mark_forbidden_pairs.html","id":null,"dir":"Reference","previous_headings":"","what":"Mark forbidden pairs — mark_forbidden_pairs","title":"Mark forbidden pairs — mark_forbidden_pairs","text":"Generic function mark specific pairs forbidden.","code":""},{"path":"https://gillescolling.com/couplr/reference/mark_forbidden_pairs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Mark forbidden pairs — mark_forbidden_pairs","text":"","code":"mark_forbidden_pairs(cost_matrix, forbidden_indices)"},{"path":"https://gillescolling.com/couplr/reference/mark_forbidden_pairs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Mark forbidden pairs — mark_forbidden_pairs","text":"Modified cost matrix forbidden pairs marked.","code":""},{"path":"https://gillescolling.com/couplr/reference/matchmaker.html","id":null,"dir":"Reference","previous_headings":"","what":"Create blocks for stratified matching — matchmaker","title":"Create blocks for stratified matching — matchmaker","text":"Constructs blocks (strata) matching, using either grouping variables clustering algorithms. Returns input data frames block IDs assigned, along block summary statistics.","code":""},{"path":"https://gillescolling.com/couplr/reference/matchmaker.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create blocks for stratified matching — matchmaker","text":"","code":"matchmaker(   left,   right,   block_type = c(\"none\", \"group\", \"cluster\"),   block_by = NULL,   block_vars = NULL,   block_method = \"kmeans\",   n_blocks = NULL,   min_left = 1,   min_right = 1,   drop_imbalanced = FALSE,   imbalance_threshold = Inf,   return_dropped = TRUE,   ... )"},{"path":"https://gillescolling.com/couplr/reference/matchmaker.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create blocks for stratified matching — matchmaker","text":"left Data frame \"left\" units (e.g., treated, cases) right Data frame \"right\" units (e.g., control, controls) block_type Type blocking use: \"none\": blocking (default) \"group\": Block existing categorical variable(s) \"cluster\": Block using clustering algorithm block_by Variable name(s) grouping (block_type = \"group\") block_vars Variable names clustering (block_type = \"cluster\") block_method Clustering method (block_type = \"cluster\"): \"kmeans\": K-means clustering \"hclust\": Hierarchical clustering n_blocks Target number blocks (clustering) min_left Minimum number left units per block min_right Minimum number right units per block drop_imbalanced Drop blocks extreme imbalance imbalance_threshold Maximum allowed |n_left - n_right| / max(n_left, n_right) return_dropped Include dropped blocks output ... Additional arguments passed clustering function","code":""},{"path":"https://gillescolling.com/couplr/reference/matchmaker.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create blocks for stratified matching — matchmaker","text":"list class \"matchmaker_result\" containing: left: Left data frame block_id column added right: Right data frame block_id column added block_summary: Summary statistics block dropped: Information dropped blocks () info: Metadata blocking process","code":""},{"path":"https://gillescolling.com/couplr/reference/matchmaker.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create blocks for stratified matching — matchmaker","text":"function perform matching - creates block structure. Use match_couples() greedy_couples() perform matching within blocks.","code":""},{"path":"https://gillescolling.com/couplr/reference/matchmaker.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create blocks for stratified matching — matchmaker","text":"","code":"# Group blocking left <- data.frame(id = 1:10, region = rep(c(\"A\", \"B\"), each = 5), x = rnorm(10)) right <- data.frame(id = 11:20, region = rep(c(\"A\", \"B\"), each = 5), x = rnorm(10)) blocks <- matchmaker(left, right, block_type = \"group\", block_by = \"region\") print(blocks$block_summary)  # Clustering blocks <- matchmaker(left, right, block_type = \"cluster\",                      block_vars = \"x\", n_blocks = 3)"},{"path":"https://gillescolling.com/couplr/reference/match_blocks_parallel.html","id":null,"dir":"Reference","previous_headings":"","what":"Match blocks in parallel — match_blocks_parallel","title":"Match blocks in parallel — match_blocks_parallel","text":"Match blocks parallel","code":""},{"path":"https://gillescolling.com/couplr/reference/match_blocks_parallel.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Match blocks in parallel — match_blocks_parallel","text":"","code":"match_blocks_parallel(   blocks,   left,   right,   left_ids,   right_ids,   block_col,   vars,   distance,   weights,   scale,   max_distance,   calipers,   method,   parallel = FALSE )"},{"path":"https://gillescolling.com/couplr/reference/match_blocks_parallel.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Match blocks in parallel — match_blocks_parallel","text":"blocks Vector block IDs left Left dataset block_col right Right dataset block_col left_ids IDs left right_ids IDs right block_col Name blocking column vars Variables matching distance Distance metric weights Variable weights scale Scaling method max_distance Maximum distance calipers Caliper constraints method LAP method parallel Whether use parallel processing","code":""},{"path":"https://gillescolling.com/couplr/reference/match_blocks_parallel.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Match blocks in parallel — match_blocks_parallel","text":"List combined results blocks","code":""},{"path":"https://gillescolling.com/couplr/reference/match_couples.html","id":null,"dir":"Reference","previous_headings":"","what":"Optimal matching using linear assignment — match_couples","title":"Optimal matching using linear assignment — match_couples","text":"Performs optimal one--one matching two datasets using linear assignment problem (LAP) solvers. Supports blocking, distance constraints, various distance metrics.","code":""},{"path":"https://gillescolling.com/couplr/reference/match_couples.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Optimal matching using linear assignment — match_couples","text":"","code":"match_couples(   left,   right = NULL,   vars = NULL,   distance = \"euclidean\",   weights = NULL,   scale = FALSE,   auto_scale = FALSE,   max_distance = Inf,   calipers = NULL,   block_id = NULL,   ignore_blocks = FALSE,   require_full_matching = FALSE,   method = \"auto\",   return_unmatched = TRUE,   return_diagnostics = FALSE,   parallel = FALSE,   check_costs = TRUE )"},{"path":"https://gillescolling.com/couplr/reference/match_couples.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Optimal matching using linear assignment — match_couples","text":"left Data frame \"left\" units (e.g., treated, cases) right Data frame \"right\" units (e.g., control, controls) vars Variable names use distance computation distance Distance metric: \"euclidean\", \"manhattan\", \"mahalanobis\", custom function weights Optional named vector variable weights scale Scaling method: FALSE (none), \"standardize\", \"range\", \"robust\" auto_scale TRUE, automatically check variable health select scaling method (default: FALSE) max_distance Maximum allowed distance (pairs exceeding forbidden) calipers Named list per-variable maximum absolute differences block_id Column name containing block IDs (stratified matching) ignore_blocks TRUE, ignore block_id even present require_full_matching TRUE, error units remain unmatched method LAP solver: \"auto\", \"hungarian\", \"jv\", \"gabow_tarjan\", etc. return_unmatched Include unmatched units output return_diagnostics Include detailed diagnostics output parallel Enable parallel processing blocked matching. Requires 'future' 'future.apply' packages. Can : FALSE: Sequential processing (default) TRUE: Auto-configure parallel backend Character: Specify future plan (e.g., \"multisession\", \"multicore\") check_costs TRUE, check distance distribution potential problems provide helpful warnings matching (default: TRUE)","code":""},{"path":"https://gillescolling.com/couplr/reference/match_couples.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Optimal matching using linear assignment — match_couples","text":"list class \"matching_result\" containing: pairs: Tibble matched pairs distances unmatched: List unmatched left right IDs info: Matching diagnostics metadata","code":""},{"path":"https://gillescolling.com/couplr/reference/match_couples.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Optimal matching using linear assignment — match_couples","text":"function finds matching minimizes total distance among feasible matchings, subject constraints. Use greedy_couples() faster approximate matching large datasets.","code":""},{"path":"https://gillescolling.com/couplr/reference/match_couples.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Optimal matching using linear assignment — match_couples","text":"","code":"# Basic matching left <- data.frame(id = 1:5, x = c(1, 2, 3, 4, 5), y = c(2, 4, 6, 8, 10)) right <- data.frame(id = 6:10, x = c(1.1, 2.2, 3.1, 4.2, 5.1), y = c(2.1, 4.1, 6.2, 8.1, 10.1)) result <- match_couples(left, right, vars = c(\"x\", \"y\")) print(result$pairs)  # With constraints result <- match_couples(left, right, vars = c(\"x\", \"y\"),                         max_distance = 1,                         calipers = list(x = 0.5))  # With blocking left$region <- c(\"A\", \"A\", \"B\", \"B\", \"B\") right$region <- c(\"A\", \"A\", \"B\", \"B\", \"B\") blocks <- matchmaker(left, right, block_type = \"group\", block_by = \"region\") result <- match_couples(blocks$left, blocks$right, vars = c(\"x\", \"y\"))"},{"path":"https://gillescolling.com/couplr/reference/match_couples_blocked.html","id":null,"dir":"Reference","previous_headings":"","what":"Match with blocking (multiple problems) — match_couples_blocked","title":"Match with blocking (multiple problems) — match_couples_blocked","text":"Match blocking (multiple problems)","code":""},{"path":"https://gillescolling.com/couplr/reference/match_couples_blocked.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Match with blocking (multiple problems) — match_couples_blocked","text":"","code":"match_couples_blocked(   left,   right,   left_ids,   right_ids,   block_col,   vars,   distance,   weights,   scale,   max_distance,   calipers,   method,   parallel = FALSE )"},{"path":"https://gillescolling.com/couplr/reference/match_couples_blocked.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Match with blocking (multiple problems) — match_couples_blocked","text":"List pairs tibble matching info.","code":""},{"path":"https://gillescolling.com/couplr/reference/match_couples_from_distance.html","id":null,"dir":"Reference","previous_headings":"","what":"Match from Precomputed Distance Object — match_couples_from_distance","title":"Match from Precomputed Distance Object — match_couples_from_distance","text":"Internal function handle matching distance_object provided","code":""},{"path":"https://gillescolling.com/couplr/reference/match_couples_from_distance.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Match from Precomputed Distance Object — match_couples_from_distance","text":"","code":"match_couples_from_distance(   dist_obj,   max_distance = Inf,   calipers = NULL,   ignore_blocks = FALSE,   require_full_matching = FALSE,   method = \"auto\",   return_unmatched = TRUE,   return_diagnostics = FALSE,   check_costs = TRUE )"},{"path":"https://gillescolling.com/couplr/reference/match_couples_from_distance.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Match from Precomputed Distance Object — match_couples_from_distance","text":"matching_result object pairs, info, optional diagnostics.","code":""},{"path":"https://gillescolling.com/couplr/reference/match_couples_single.html","id":null,"dir":"Reference","previous_headings":"","what":"Match without blocking (single problem) — match_couples_single","title":"Match without blocking (single problem) — match_couples_single","text":"Match without blocking (single problem)","code":""},{"path":"https://gillescolling.com/couplr/reference/match_couples_single.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Match without blocking (single problem) — match_couples_single","text":"","code":"match_couples_single(   left,   right,   left_ids,   right_ids,   vars,   distance,   weights,   scale,   max_distance,   calipers,   method,   check_costs = TRUE )"},{"path":"https://gillescolling.com/couplr/reference/match_couples_single.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Match without blocking (single problem) — match_couples_single","text":"List pairs tibble matching info.","code":""},{"path":"https://gillescolling.com/couplr/reference/parallel_lapply.html","id":null,"dir":"Reference","previous_headings":"","what":"Parallel lapply using future — parallel_lapply","title":"Parallel lapply using future — parallel_lapply","text":"Parallel lapply using future","code":""},{"path":"https://gillescolling.com/couplr/reference/parallel_lapply.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Parallel lapply using future — parallel_lapply","text":"","code":"parallel_lapply(X, FUN, ..., parallel = FALSE)"},{"path":"https://gillescolling.com/couplr/reference/parallel_lapply.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Parallel lapply using future — parallel_lapply","text":"X Vector iterate FUN Function apply ... Additional arguments FUN parallel Whether parallel processing enabled","code":""},{"path":"https://gillescolling.com/couplr/reference/parallel_lapply.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Parallel lapply using future — parallel_lapply","text":"List results","code":""},{"path":"https://gillescolling.com/couplr/reference/pipe.html","id":null,"dir":"Reference","previous_headings":"","what":"Pipe operator — %>%","title":"Pipe operator — %>%","text":"See magrittr::%>% details.","code":""},{"path":"https://gillescolling.com/couplr/reference/pipe.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pipe operator — %>%","text":"","code":"lhs %>% rhs"},{"path":"https://gillescolling.com/couplr/reference/pipe.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pipe operator — %>%","text":"lhs value magrittr placeholder. rhs function call using magrittr semantics.","code":""},{"path":"https://gillescolling.com/couplr/reference/pipe.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Pipe operator — %>%","text":"result calling rhs(lhs).","code":""},{"path":"https://gillescolling.com/couplr/reference/pixel_morph.html","id":null,"dir":"Reference","previous_headings":"","what":"Pixel-level image morphing (final frame only) — pixel_morph","title":"Pixel-level image morphing (final frame only) — pixel_morph","text":"Computes optimal pixel assignment B returns final transported frame (without intermediate animation frames).","code":""},{"path":"https://gillescolling.com/couplr/reference/pixel_morph.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pixel-level image morphing (final frame only) — pixel_morph","text":"","code":"pixel_morph(   imgA,   imgB,   n_frames = 16L,   mode = c(\"color_walk\", \"exact\", \"recursive\"),   lap_method = \"jv\",   maximize = FALSE,   quantize_bits = 5L,   downscale_steps = 0L,   alpha = 1,   beta = 0,   patch_size = 1L,   upscale = 1,   show = interactive() )"},{"path":"https://gillescolling.com/couplr/reference/pixel_morph.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pixel-level image morphing (final frame only) — pixel_morph","text":"imgA Source image (file path magick image object) imgB Target image (file path magick image object) n_frames Internal parameter rendering (default: 16) mode Assignment algorithm: \"color_walk\" (default), \"exact\", \"recursive\" lap_method LAP solver method (default: \"jv\") maximize Logical, maximize instead minimize cost (default: FALSE) quantize_bits Color quantization \"color_walk\" mode (default: 5) downscale_steps Number 2x reductions computing assignment (default: 0) alpha Weight color distance cost function (default: 1) beta Weight spatial distance cost function (default: 0) patch_size Tile size tiled modes (default: 1) upscale Post-rendering upscaling factor (default: 1) show Logical, display result viewer (default: interactive())","code":""},{"path":"https://gillescolling.com/couplr/reference/pixel_morph.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Pixel-level image morphing (final frame only) — pixel_morph","text":"magick image object final transported frame","code":""},{"path":[]},{"path":"https://gillescolling.com/couplr/reference/pixel_morph.html","id":"transport-only-semantics","dir":"Reference","previous_headings":"","what":"Transport-Only Semantics","title":"Pixel-level image morphing (final frame only) — pixel_morph","text":"function returns SHARP, pixel-perfect transport 's pixels positions determined assignment B. Key Points: Assignment computed using: cost = alpha * color_dist + beta * spatial_dist B's COLORS influence assignment appear output Result 's colors arranged match B's layout motion blur (unlike intermediate frames animation) See pixel_morph_animate detailed explanation assignment vs rendering semantics.","code":""},{"path":"https://gillescolling.com/couplr/reference/pixel_morph.html","id":"permutation-warnings","dir":"Reference","previous_headings":"","what":"Permutation Warnings","title":"Pixel-level image morphing (final frame only) — pixel_morph","text":"Assignment guaranteed bijection (permutation) : downscale_steps = 0 (resolution changes) mode = \"exact\" patch_size = 1 downscaling tiled modes, assignment may : Overlaps: Multiple source pixels map destination (last write wins) Holes: destinations never filled (remain transparent) assignment bijection (due downscaling tiling), warning issued. result may contain: Overlapped pixels (multiple sources -> one destination) Transparent holes (destinations unfilled) guaranteed pixel-perfect results, use:","code":"pixel_morph(A, B, mode = \"exact\", downscale_steps = 0)"},{"path":[]},{"path":"https://gillescolling.com/couplr/reference/pixel_morph.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Pixel-level image morphing (final frame only) — pixel_morph","text":"","code":"if (requireNamespace(\"magick\", quietly = TRUE)) {   imgA <- system.file(\"extdata/icons/circleA_40.png\", package = \"couplr\")   imgB <- system.file(\"extdata/icons/circleB_40.png\", package = \"couplr\")   if (nzchar(imgA) && nzchar(imgB)) {     result <- pixel_morph(imgA, imgB, n_frames = 4, show = FALSE)   } }"},{"path":"https://gillescolling.com/couplr/reference/pixel_morph_animate.html","id":null,"dir":"Reference","previous_headings":"","what":"Pixel-level image morphing (animation) — pixel_morph_animate","title":"Pixel-level image morphing (animation) — pixel_morph_animate","text":"Creates animated morph computing optimal pixel assignment image image B, rendering intermediate frames showing transport.","code":""},{"path":"https://gillescolling.com/couplr/reference/pixel_morph_animate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pixel-level image morphing (animation) — pixel_morph_animate","text":"","code":"pixel_morph_animate(   imgA,   imgB,   n_frames = 16L,   fps = 10L,   format = c(\"gif\", \"webp\", \"mp4\"),   outfile = NULL,   show = interactive(),   mode = c(\"color_walk\", \"exact\", \"recursive\"),   lap_method = \"jv\",   maximize = FALSE,   quantize_bits = 5L,   downscale_steps = 0L,   alpha = 1,   beta = 0,   patch_size = 1L,   upscale = 1 )"},{"path":"https://gillescolling.com/couplr/reference/pixel_morph_animate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pixel-level image morphing (animation) — pixel_morph_animate","text":"imgA Source image (file path magick image object) imgB Target image (file path magick image object) n_frames Integer number animation frames (default: 16) fps Frames per second playback (default: 10) format Output format: \"gif\", \"webp\", \"mp4\" outfile Optional output file path show Logical, display animation viewer (default: interactive()) mode Assignment algorithm: \"color_walk\" (default), \"exact\", \"recursive\" lap_method LAP solver method (default: \"jv\") maximize Logical, maximize instead minimize cost (default: FALSE) quantize_bits Color quantization \"color_walk\" mode (default: 5) downscale_steps Number 2x reductions computing assignment (default: 0) alpha Weight color distance cost function (default: 1) beta Weight spatial distance cost function (default: 0) patch_size Tile size tiled modes (default: 1) upscale Post-rendering upscaling factor (default: 1)","code":""},{"path":"https://gillescolling.com/couplr/reference/pixel_morph_animate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Pixel-level image morphing (animation) — pixel_morph_animate","text":"Invisibly returns list animation object metadata: animation magick animation object width Image width pixels height Image height pixels assignment Integer vector 1-based assignment indices (R convention) n_pixels Total number pixels mode Mode used matching upscale Upscaling factor applied","code":""},{"path":[]},{"path":"https://gillescolling.com/couplr/reference/pixel_morph_animate.html","id":"assignment-vs-rendering-semantics","dir":"Reference","previous_headings":"","what":"Assignment vs Rendering Semantics","title":"Pixel-level image morphing (animation) — pixel_morph_animate","text":"CRITICAL: function two separate phases different semantics: Phase 1 - Assignment Computation: assignment computed minimizing: means B's COLORS influence pixels map positions. Phase 2 - Rendering (Transport-): renderer uses 's colors: Intermediate frames: 's pixels move along paths motion blur Final frame: 's pixels assigned positions (sharp, blur) B's colors NEVER appear output Result: get 's colors rearranged match B's geometry/layout.","code":"cost(i,j) = alpha * color_distance(A[i], B[j]) +               beta * spatial_distance(pos_i, pos_j)"},{"path":"https://gillescolling.com/couplr/reference/pixel_morph_animate.html","id":"what-this-means","dir":"Reference","previous_headings":"","what":"What This Means","title":"Pixel-level image morphing (animation) — pixel_morph_animate","text":"B influences pixels go (via similarity cost function) B determine COLORS appear output Final image 's palette arranged mimic B's structure","code":""},{"path":"https://gillescolling.com/couplr/reference/pixel_morph_animate.html","id":"parameter-guidance","dir":"Reference","previous_headings":"","what":"Parameter Guidance","title":"Pixel-level image morphing (animation) — pixel_morph_animate","text":"pure spatial rearrangement (ignore B's colors assignment): color-similarity matching (default): hybrid (color + spatial):","code":"pixel_morph_animate(A, B, alpha = 0, beta = 1) pixel_morph_animate(A, B, alpha = 1, beta = 0) pixel_morph_animate(A, B, alpha = 1, beta = 0.2)"},{"path":"https://gillescolling.com/couplr/reference/pixel_morph_animate.html","id":"permutation-guarantees","dir":"Reference","previous_headings":"","what":"Permutation Guarantees","title":"Pixel-level image morphing (animation) — pixel_morph_animate","text":"Assignment guaranteed bijection (permutation) : downscale_steps = 0 (resolution changes) mode = \"exact\" patch_size = 1 downscaling tiled modes, assignment may : Overlaps: Multiple source pixels map destination (last write wins) Holes: destinations never filled (remain transparent) warning issued overlaps/holes detected final frame.","code":""},{"path":"https://gillescolling.com/couplr/reference/pixel_morph_animate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Pixel-level image morphing (animation) — pixel_morph_animate","text":"","code":"if (requireNamespace(\"magick\", quietly = TRUE)) {   imgA <- system.file(\"extdata/icons/circleA_40.png\", package = \"couplr\")   imgB <- system.file(\"extdata/icons/circleB_40.png\", package = \"couplr\")   if (nzchar(imgA) && nzchar(imgB)) {     outfile <- tempfile(fileext = \".gif\")     pixel_morph_animate(imgA, imgB, outfile = outfile, n_frames = 4, show = FALSE)   } }"},{"path":"https://gillescolling.com/couplr/reference/plot.balance_diagnostics.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot method for balance diagnostics — plot.balance_diagnostics","title":"Plot method for balance diagnostics — plot.balance_diagnostics","text":"Produces Love plot (dot plot) standardized differences.","code":""},{"path":"https://gillescolling.com/couplr/reference/plot.balance_diagnostics.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot method for balance diagnostics — plot.balance_diagnostics","text":"","code":"# S3 method for class 'balance_diagnostics' plot(x, type = c(\"love\", \"histogram\", \"variance\"), threshold = 0.1, ...)"},{"path":"https://gillescolling.com/couplr/reference/plot.balance_diagnostics.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot method for balance diagnostics — plot.balance_diagnostics","text":"x balance_diagnostics object type Type plot: \"love\" (default), \"histogram\", \"variance\" threshold Threshold line standardized differences (default: 0.1) ... Additional arguments passed plotting functions","code":""},{"path":"https://gillescolling.com/couplr/reference/plot.balance_diagnostics.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot method for balance diagnostics — plot.balance_diagnostics","text":"balance_diagnostics object (invisibly)","code":""},{"path":"https://gillescolling.com/couplr/reference/plot.matching_result.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot method for matching results — plot.matching_result","title":"Plot method for matching results — plot.matching_result","text":"Produces histogram pairwise distances matching result.","code":""},{"path":"https://gillescolling.com/couplr/reference/plot.matching_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot method for matching results — plot.matching_result","text":"","code":"# S3 method for class 'matching_result' plot(x, type = c(\"histogram\", \"density\", \"ecdf\"), ...)"},{"path":"https://gillescolling.com/couplr/reference/plot.matching_result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot method for matching results — plot.matching_result","text":"x matching_result object type Type plot: \"histogram\" (default), \"density\", \"ecdf\" ... Additional arguments passed plotting functions","code":""},{"path":"https://gillescolling.com/couplr/reference/plot.matching_result.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot method for matching results — plot.matching_result","text":"matching_result object (invisibly)","code":""},{"path":"https://gillescolling.com/couplr/reference/preprocess_matching_vars.html","id":null,"dir":"Reference","previous_headings":"","what":"Preprocess matching variables with automatic checks and scaling — preprocess_matching_vars","title":"Preprocess matching variables with automatic checks and scaling — preprocess_matching_vars","text":"Main preprocessing function orchestrates variable health checks, categorical encoding, automatic scaling selection.","code":""},{"path":"https://gillescolling.com/couplr/reference/preprocess_matching_vars.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Preprocess matching variables with automatic checks and scaling — preprocess_matching_vars","text":"","code":"preprocess_matching_vars(   left,   right,   vars,   auto_scale = TRUE,   scale_method = \"auto\",   check_health = TRUE,   remove_problematic = TRUE,   verbose = TRUE )"},{"path":"https://gillescolling.com/couplr/reference/preprocess_matching_vars.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Preprocess matching variables with automatic checks and scaling — preprocess_matching_vars","text":"left Data frame left units right Data frame right units vars Character vector variable names auto_scale Logical, whether perform automatic preprocessing (default: TRUE) scale_method Scaling method: \"auto\", \"standardize\", \"range\", \"robust\", FALSE check_health Logical, whether check variable health (default: TRUE) remove_problematic Logical, automatically exclude constant/-NA variables (default: TRUE) verbose Logical, whether print warnings (default: TRUE)","code":""},{"path":"https://gillescolling.com/couplr/reference/preprocess_matching_vars.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Preprocess matching variables with automatic checks and scaling — preprocess_matching_vars","text":"list class \"preprocessing_result\" containing: left: Preprocessed left data frame right: Preprocessed right data frame vars: Final variable names (exclusions) health: Variable health diagnostics scaling_method: Selected scaling method excluded_vars: Variables excluded warnings: List warnings issued","code":""},{"path":"https://gillescolling.com/couplr/reference/print.balance_diagnostics.html","id":null,"dir":"Reference","previous_headings":"","what":"Print Method for Balance Diagnostics — print.balance_diagnostics","title":"Print Method for Balance Diagnostics — print.balance_diagnostics","text":"Print Method Balance Diagnostics","code":""},{"path":"https://gillescolling.com/couplr/reference/print.balance_diagnostics.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print Method for Balance Diagnostics — print.balance_diagnostics","text":"","code":"# S3 method for class 'balance_diagnostics' print(x, ...)"},{"path":"https://gillescolling.com/couplr/reference/print.balance_diagnostics.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print Method for Balance Diagnostics — print.balance_diagnostics","text":"x balance_diagnostics object ... Additional arguments (ignored)","code":""},{"path":"https://gillescolling.com/couplr/reference/print.balance_diagnostics.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print Method for Balance Diagnostics — print.balance_diagnostics","text":"Invisibly returns input object x.","code":""},{"path":"https://gillescolling.com/couplr/reference/print.distance_object.html","id":null,"dir":"Reference","previous_headings":"","what":"Print Method for Distance Objects — print.distance_object","title":"Print Method for Distance Objects — print.distance_object","text":"Print Method Distance Objects","code":""},{"path":"https://gillescolling.com/couplr/reference/print.distance_object.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print Method for Distance Objects — print.distance_object","text":"","code":"# S3 method for class 'distance_object' print(x, ...)"},{"path":"https://gillescolling.com/couplr/reference/print.distance_object.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print Method for Distance Objects — print.distance_object","text":"x distance_object ... Additional arguments (ignored)","code":""},{"path":"https://gillescolling.com/couplr/reference/print.distance_object.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print Method for Distance Objects — print.distance_object","text":"Invisibly returns input object x.","code":""},{"path":"https://gillescolling.com/couplr/reference/print.lap_solve_batch_result.html","id":null,"dir":"Reference","previous_headings":"","what":"Print method for batch assignment results — print.lap_solve_batch_result","title":"Print method for batch assignment results — print.lap_solve_batch_result","text":"Prints summary table results batch assignment problems solved lap_solve_batch().","code":""},{"path":"https://gillescolling.com/couplr/reference/print.lap_solve_batch_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print method for batch assignment results — print.lap_solve_batch_result","text":"","code":"# S3 method for class 'lap_solve_batch_result' print(x, ...)"},{"path":"https://gillescolling.com/couplr/reference/print.lap_solve_batch_result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print method for batch assignment results — print.lap_solve_batch_result","text":"x lap_solve_batch_result object. ... Additional arguments passed print(). Currently ignored.","code":""},{"path":"https://gillescolling.com/couplr/reference/print.lap_solve_batch_result.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print method for batch assignment results — print.lap_solve_batch_result","text":"Invisibly returns input object x.","code":""},{"path":"https://gillescolling.com/couplr/reference/print.lap_solve_kbest_result.html","id":null,"dir":"Reference","previous_headings":"","what":"Print method for k-best assignment results — print.lap_solve_kbest_result","title":"Print method for k-best assignment results — print.lap_solve_kbest_result","text":"Print method k-best assignment results","code":""},{"path":"https://gillescolling.com/couplr/reference/print.lap_solve_kbest_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print method for k-best assignment results — print.lap_solve_kbest_result","text":"","code":"# S3 method for class 'lap_solve_kbest_result' print(x, ...)"},{"path":"https://gillescolling.com/couplr/reference/print.lap_solve_kbest_result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print method for k-best assignment results — print.lap_solve_kbest_result","text":"x lap_solve_kbest_result. ... Additional arguments passed print(). Ignored.","code":""},{"path":"https://gillescolling.com/couplr/reference/print.lap_solve_kbest_result.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print method for k-best assignment results — print.lap_solve_kbest_result","text":"Invisibly returns input object x.","code":""},{"path":"https://gillescolling.com/couplr/reference/print.lap_solve_result.html","id":null,"dir":"Reference","previous_headings":"","what":"Print method for assignment results — print.lap_solve_result","title":"Print method for assignment results — print.lap_solve_result","text":"Nicely prints lap_solve_result object, including assignments, total cost, method used.","code":""},{"path":"https://gillescolling.com/couplr/reference/print.lap_solve_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print method for assignment results — print.lap_solve_result","text":"","code":"# S3 method for class 'lap_solve_result' print(x, ...)"},{"path":"https://gillescolling.com/couplr/reference/print.lap_solve_result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print method for assignment results — print.lap_solve_result","text":"x lap_solve_result object. ... Additional arguments passed print(). Currently ignored.","code":""},{"path":"https://gillescolling.com/couplr/reference/print.lap_solve_result.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print method for assignment results — print.lap_solve_result","text":"Invisibly returns input object x.","code":""},{"path":"https://gillescolling.com/couplr/reference/print.matching_result.html","id":null,"dir":"Reference","previous_headings":"","what":"Print method for matching results — print.matching_result","title":"Print method for matching results — print.matching_result","text":"Print method matching results","code":""},{"path":"https://gillescolling.com/couplr/reference/print.matching_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print method for matching results — print.matching_result","text":"","code":"# S3 method for class 'matching_result' print(x, ...)"},{"path":"https://gillescolling.com/couplr/reference/print.matching_result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print method for matching results — print.matching_result","text":"x matching_result object ... Additional arguments (ignored)","code":""},{"path":"https://gillescolling.com/couplr/reference/print.matching_result.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print method for matching results — print.matching_result","text":"Invisibly returns input object x.","code":""},{"path":"https://gillescolling.com/couplr/reference/print.matchmaker_result.html","id":null,"dir":"Reference","previous_headings":"","what":"Print method for matchmaker results — print.matchmaker_result","title":"Print method for matchmaker results — print.matchmaker_result","text":"Print method matchmaker results","code":""},{"path":"https://gillescolling.com/couplr/reference/print.matchmaker_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print method for matchmaker results — print.matchmaker_result","text":"","code":"# S3 method for class 'matchmaker_result' print(x, ...)"},{"path":"https://gillescolling.com/couplr/reference/print.matchmaker_result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print method for matchmaker results — print.matchmaker_result","text":"x matchmaker_result object ... Additional arguments (ignored)","code":""},{"path":"https://gillescolling.com/couplr/reference/print.matchmaker_result.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print method for matchmaker results — print.matchmaker_result","text":"Invisibly returns input object x.","code":""},{"path":"https://gillescolling.com/couplr/reference/print.preprocessing_result.html","id":null,"dir":"Reference","previous_headings":"","what":"Print method for preprocessing result — print.preprocessing_result","title":"Print method for preprocessing result — print.preprocessing_result","text":"Print method preprocessing result","code":""},{"path":"https://gillescolling.com/couplr/reference/print.preprocessing_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print method for preprocessing result — print.preprocessing_result","text":"","code":"# S3 method for class 'preprocessing_result' print(x, ...)"},{"path":"https://gillescolling.com/couplr/reference/print.preprocessing_result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print method for preprocessing result — print.preprocessing_result","text":"x preprocessing_result object ... Additional arguments (ignored)","code":""},{"path":"https://gillescolling.com/couplr/reference/print.preprocessing_result.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print method for preprocessing result — print.preprocessing_result","text":"Invisibly returns input object x.","code":""},{"path":"https://gillescolling.com/couplr/reference/print.variable_health.html","id":null,"dir":"Reference","previous_headings":"","what":"Print method for variable health — print.variable_health","title":"Print method for variable health — print.variable_health","text":"Print method variable health","code":""},{"path":"https://gillescolling.com/couplr/reference/print.variable_health.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print method for variable health — print.variable_health","text":"","code":"# S3 method for class 'variable_health' print(x, ...)"},{"path":"https://gillescolling.com/couplr/reference/print.variable_health.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print method for variable health — print.variable_health","text":"x variable_health object ... Additional arguments (ignored)","code":""},{"path":"https://gillescolling.com/couplr/reference/print.variable_health.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print method for variable health — print.variable_health","text":"Invisibly returns input object x.","code":""},{"path":"https://gillescolling.com/couplr/reference/restore_parallel.html","id":null,"dir":"Reference","previous_headings":"","what":"Restore original parallel plan — restore_parallel","title":"Restore original parallel plan — restore_parallel","text":"Restore original parallel plan","code":""},{"path":"https://gillescolling.com/couplr/reference/restore_parallel.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Restore original parallel plan — restore_parallel","text":"","code":"restore_parallel(parallel_state)"},{"path":"https://gillescolling.com/couplr/reference/restore_parallel.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Restore original parallel plan — restore_parallel","text":"parallel_state State setup_parallel()","code":""},{"path":"https://gillescolling.com/couplr/reference/restore_parallel.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Restore original parallel plan — restore_parallel","text":"return value, called side effects (restores parallel plan).","code":""},{"path":"https://gillescolling.com/couplr/reference/setup_parallel.html","id":null,"dir":"Reference","previous_headings":"","what":"Setup parallel processing with future — setup_parallel","title":"Setup parallel processing with future — setup_parallel","text":"Setup parallel processing future","code":""},{"path":"https://gillescolling.com/couplr/reference/setup_parallel.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Setup parallel processing with future — setup_parallel","text":"","code":"setup_parallel(parallel = FALSE, n_workers = NULL)"},{"path":"https://gillescolling.com/couplr/reference/setup_parallel.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Setup parallel processing with future — setup_parallel","text":"parallel Logical plan specification n_workers Number workers (NULL auto-detect)","code":""},{"path":"https://gillescolling.com/couplr/reference/setup_parallel.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Setup parallel processing with future — setup_parallel","text":"List original plan whether set parallelization","code":""},{"path":"https://gillescolling.com/couplr/reference/sinkhorn.html","id":null,"dir":"Reference","previous_headings":"","what":"'Sinkhorn-Knopp' optimal transport solver — sinkhorn","title":"'Sinkhorn-Knopp' optimal transport solver — sinkhorn","text":"Compute entropy-regularized optimal transport plan using 'Sinkhorn-Knopp' algorithm. Unlike LAP solvers return hard 1--1 assignment, returns soft assignment (doubly stochastic matrix).","code":""},{"path":"https://gillescolling.com/couplr/reference/sinkhorn.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"'Sinkhorn-Knopp' optimal transport solver — sinkhorn","text":"","code":"sinkhorn(   cost,   lambda = 10,   tol = 1e-09,   max_iter = 1000,   r_weights = NULL,   c_weights = NULL )"},{"path":"https://gillescolling.com/couplr/reference/sinkhorn.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"'Sinkhorn-Knopp' optimal transport solver — sinkhorn","text":"cost Numeric matrix transport costs. NA Inf entries treated high cost (effectively forbidden). lambda Regularization parameter (default 10). Higher values produce sharper (deterministic) transport plans; lower values produce smoother distributions. Typical range: 1-100. tol Convergence tolerance (default 1e-9). max_iter Maximum iterations (default 1000). r_weights Optional numeric vector row marginals (source distribution). Default uniform. normalized sum 1. c_weights Optional numeric vector column marginals (target distribution). Default uniform. normalized sum 1.","code":""},{"path":"https://gillescolling.com/couplr/reference/sinkhorn.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"'Sinkhorn-Knopp' optimal transport solver — sinkhorn","text":"list elements: transport_plan — numeric matrix, optimal transport plan P. Row sums approximate r_weights, column sums approximate c_weights. cost — transport cost <C, P> (without entropy term). u, v — scaling vectors (P = diag(u) * K * diag(v) K = exp(-lambda*C)). converged — logical, whether algorithm converged. iterations — number iterations used. lambda — regularization parameter used.","code":""},{"path":"https://gillescolling.com/couplr/reference/sinkhorn.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"'Sinkhorn-Knopp' optimal transport solver — sinkhorn","text":"'Sinkhorn-Knopp' algorithm solves entropy-regularized optimal transport problem: $$P^* = \\arg\\min_P \\langle C, P \\rangle - \\frac{1}{\\lambda} H(P)$$ subject row sums = r_weights column sums = c_weights. entropy term H(P) encourages spread transport plan. lambda -> Inf, solution approaches standard (unregularized) optimal transport. Key differences standard LAP solvers: Returns soft assignment (probabilities) hard 1--1 matching Supports unequal marginals (weighted distributions) Differentiable, making useful ML pipelines fast: O(n^2) per iteration typically O(1/tol^2) iterations Use sinkhorn_to_assignment() round soft assignment hard matching.","code":""},{"path":"https://gillescolling.com/couplr/reference/sinkhorn.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"'Sinkhorn-Knopp' optimal transport solver — sinkhorn","text":"Cuturi, M. (2013). 'Sinkhorn Distances': Lightspeed Computation Optimal Transport. Advances Neural Information Processing Systems, 26.","code":""},{"path":[]},{"path":"https://gillescolling.com/couplr/reference/sinkhorn.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"'Sinkhorn-Knopp' optimal transport solver — sinkhorn","text":"","code":"cost <- matrix(c(1, 2, 3, 4, 5, 6, 7, 8, 9), nrow = 3, byrow = TRUE)  # Soft assignment with default parameters result <- sinkhorn(cost) print(round(result$transport_plan, 3))  # Sharper assignment (higher lambda) result_sharp <- sinkhorn(cost, lambda = 50) print(round(result_sharp$transport_plan, 3))  # With custom marginals (more mass from row 1) result_weighted <- sinkhorn(cost, r_weights = c(0.5, 0.25, 0.25)) print(round(result_weighted$transport_plan, 3))  # Round to hard assignment hard_match <- sinkhorn_to_assignment(result) print(hard_match)"},{"path":"https://gillescolling.com/couplr/reference/sinkhorn_to_assignment.html","id":null,"dir":"Reference","previous_headings":"","what":"Round 'Sinkhorn' transport plan to hard assignment — sinkhorn_to_assignment","title":"Round 'Sinkhorn' transport plan to hard assignment — sinkhorn_to_assignment","text":"Convert soft transport plan sinkhorn() hard 1--1 assignment using greedy rounding.","code":""},{"path":"https://gillescolling.com/couplr/reference/sinkhorn_to_assignment.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Round 'Sinkhorn' transport plan to hard assignment — sinkhorn_to_assignment","text":"","code":"sinkhorn_to_assignment(result)"},{"path":"https://gillescolling.com/couplr/reference/sinkhorn_to_assignment.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Round 'Sinkhorn' transport plan to hard assignment — sinkhorn_to_assignment","text":"result Either result sinkhorn() transport plan matrix.","code":""},{"path":"https://gillescolling.com/couplr/reference/sinkhorn_to_assignment.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Round 'Sinkhorn' transport plan to hard assignment — sinkhorn_to_assignment","text":"Integer vector column assignments (1-based), format assignment().","code":""},{"path":"https://gillescolling.com/couplr/reference/sinkhorn_to_assignment.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Round 'Sinkhorn' transport plan to hard assignment — sinkhorn_to_assignment","text":"Greedy rounding iteratively assigns row probable column, ensuring column assigned twice. may give globally optimal hard assignment; , use transport plan cost matrix assignment().","code":""},{"path":[]},{"path":"https://gillescolling.com/couplr/reference/sinkhorn_to_assignment.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Round 'Sinkhorn' transport plan to hard assignment — sinkhorn_to_assignment","text":"","code":"cost <- matrix(c(1, 2, 3, 4, 5, 6, 7, 8, 9), nrow = 3, byrow = TRUE) result <- sinkhorn(cost, lambda = 20) hard_match <- sinkhorn_to_assignment(result) print(hard_match)"},{"path":"https://gillescolling.com/couplr/reference/standardized_difference.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Standardized Difference — standardized_difference","title":"Calculate Standardized Difference — standardized_difference","text":"Computes standardized mean difference two groups. key metric assessing balance matched samples.","code":""},{"path":"https://gillescolling.com/couplr/reference/standardized_difference.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Standardized Difference — standardized_difference","text":"","code":"standardized_difference(x1, x2, pooled = TRUE)"},{"path":"https://gillescolling.com/couplr/reference/standardized_difference.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Standardized Difference — standardized_difference","text":"x1 Numeric vector group 1 x2 Numeric vector group 2 pooled Logical, TRUE use pooled standard deviation (default), FALSE use group 1 standard deviation","code":""},{"path":"https://gillescolling.com/couplr/reference/standardized_difference.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Standardized Difference — standardized_difference","text":"Numeric value representing standardized difference","code":""},{"path":"https://gillescolling.com/couplr/reference/standardized_difference.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate Standardized Difference — standardized_difference","text":"Standardized difference = (mean1 - mean2) / pooled_sd pooled_sd = sqrt((sd1^2 + sd2^2) / 2) Common thresholds: less 0.1 excellent balance, 0.1-0.25 good balance, 0.25-0.5 acceptable balance, greater 0.5 poor balance.","code":""},{"path":"https://gillescolling.com/couplr/reference/success_good_balance.html","id":null,"dir":"Reference","previous_headings":"","what":"Perfect balance success message — success_good_balance","title":"Perfect balance success message — success_good_balance","text":"Perfect balance success message","code":""},{"path":"https://gillescolling.com/couplr/reference/success_good_balance.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Perfect balance success message — success_good_balance","text":"","code":"success_good_balance(mean_std_diff)"},{"path":"https://gillescolling.com/couplr/reference/success_good_balance.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Perfect balance success message — success_good_balance","text":"return value, called side effects (issues message).","code":""},{"path":"https://gillescolling.com/couplr/reference/suggest_scaling.html","id":null,"dir":"Reference","previous_headings":"","what":"Suggest scaling method based on variable characteristics — suggest_scaling","title":"Suggest scaling method based on variable characteristics — suggest_scaling","text":"Analyzes variable distributions suggests appropriate scaling methods.","code":""},{"path":"https://gillescolling.com/couplr/reference/suggest_scaling.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Suggest scaling method based on variable characteristics — suggest_scaling","text":"","code":"suggest_scaling(left, right, vars)"},{"path":"https://gillescolling.com/couplr/reference/suggest_scaling.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Suggest scaling method based on variable characteristics — suggest_scaling","text":"left Data frame left units right Data frame right units vars Character vector variable names","code":""},{"path":"https://gillescolling.com/couplr/reference/suggest_scaling.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Suggest scaling method based on variable characteristics — suggest_scaling","text":"character string suggested scaling method: \"standardize\", \"range\", \"robust\", \"none\"","code":""},{"path":"https://gillescolling.com/couplr/reference/summarize_blocks.html","id":null,"dir":"Reference","previous_headings":"","what":"Summarize block structure — summarize_blocks","title":"Summarize block structure — summarize_blocks","text":"Summarize block structure","code":""},{"path":"https://gillescolling.com/couplr/reference/summarize_blocks.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summarize block structure — summarize_blocks","text":"","code":"summarize_blocks(left, right, block_vars = NULL)"},{"path":"https://gillescolling.com/couplr/reference/summarize_blocks.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summarize block structure — summarize_blocks","text":"Tibble block_id, n_left, n_right, optional variable means.","code":""},{"path":"https://gillescolling.com/couplr/reference/summary.balance_diagnostics.html","id":null,"dir":"Reference","previous_headings":"","what":"Summary method for balance diagnostics — summary.balance_diagnostics","title":"Summary method for balance diagnostics — summary.balance_diagnostics","text":"Summary method balance diagnostics","code":""},{"path":"https://gillescolling.com/couplr/reference/summary.balance_diagnostics.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summary method for balance diagnostics — summary.balance_diagnostics","text":"","code":"# S3 method for class 'balance_diagnostics' summary(object, ...)"},{"path":"https://gillescolling.com/couplr/reference/summary.balance_diagnostics.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summary method for balance diagnostics — summary.balance_diagnostics","text":"object balance_diagnostics object ... Additional arguments (ignored)","code":""},{"path":"https://gillescolling.com/couplr/reference/summary.balance_diagnostics.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summary method for balance diagnostics — summary.balance_diagnostics","text":"list containing summary statistics (invisibly)","code":""},{"path":"https://gillescolling.com/couplr/reference/summary.distance_object.html","id":null,"dir":"Reference","previous_headings":"","what":"Summary Method for Distance Objects — summary.distance_object","title":"Summary Method for Distance Objects — summary.distance_object","text":"Summary Method Distance Objects","code":""},{"path":"https://gillescolling.com/couplr/reference/summary.distance_object.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summary Method for Distance Objects — summary.distance_object","text":"","code":"# S3 method for class 'distance_object' summary(object, ...)"},{"path":"https://gillescolling.com/couplr/reference/summary.distance_object.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summary Method for Distance Objects — summary.distance_object","text":"object distance_object ... Additional arguments (ignored)","code":""},{"path":"https://gillescolling.com/couplr/reference/summary.distance_object.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summary Method for Distance Objects — summary.distance_object","text":"Invisibly returns input object.","code":""},{"path":"https://gillescolling.com/couplr/reference/summary.lap_solve_kbest_result.html","id":null,"dir":"Reference","previous_headings":"","what":"Get summary of k-best results — summary.lap_solve_kbest_result","title":"Get summary of k-best results — summary.lap_solve_kbest_result","text":"Extract summary information k-best assignment results.","code":""},{"path":"https://gillescolling.com/couplr/reference/summary.lap_solve_kbest_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get summary of k-best results — summary.lap_solve_kbest_result","text":"","code":"# S3 method for class 'lap_solve_kbest_result' summary(object, ...)"},{"path":"https://gillescolling.com/couplr/reference/summary.lap_solve_kbest_result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get summary of k-best results — summary.lap_solve_kbest_result","text":"object object class lap_solve_kbest_result. ... Additional arguments (unused).","code":""},{"path":"https://gillescolling.com/couplr/reference/summary.lap_solve_kbest_result.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get summary of k-best results — summary.lap_solve_kbest_result","text":"tibble one row per solution containing: rank: solution rank solution_id: solution identifier total_cost: total cost solution n_assignments: number assignments solution","code":""},{"path":"https://gillescolling.com/couplr/reference/summary.matching_result.html","id":null,"dir":"Reference","previous_headings":"","what":"Summary method for matching results — summary.matching_result","title":"Summary method for matching results — summary.matching_result","text":"Summary method matching results","code":""},{"path":"https://gillescolling.com/couplr/reference/summary.matching_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summary method for matching results — summary.matching_result","text":"","code":"# S3 method for class 'matching_result' summary(object, ...)"},{"path":"https://gillescolling.com/couplr/reference/summary.matching_result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summary method for matching results — summary.matching_result","text":"object matching_result object ... Additional arguments (ignored)","code":""},{"path":"https://gillescolling.com/couplr/reference/summary.matching_result.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summary method for matching results — summary.matching_result","text":"list containing summary statistics (invisibly)","code":""},{"path":"https://gillescolling.com/couplr/reference/update_constraints.html","id":null,"dir":"Reference","previous_headings":"","what":"Update Constraints on Distance Object — update_constraints","title":"Update Constraints on Distance Object — update_constraints","text":"Apply new constraints precomputed distance object without recomputing underlying distances. useful exploring different constraint scenarios quickly.","code":""},{"path":"https://gillescolling.com/couplr/reference/update_constraints.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Update Constraints on Distance Object — update_constraints","text":"","code":"update_constraints(dist_obj, max_distance = Inf, calipers = NULL)"},{"path":"https://gillescolling.com/couplr/reference/update_constraints.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Update Constraints on Distance Object — update_constraints","text":"dist_obj distance_object compute_distances() max_distance Maximum allowed distance (pairs distance > max_distance become Inf) calipers Named list per-variable calipers","code":""},{"path":"https://gillescolling.com/couplr/reference/update_constraints.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Update Constraints on Distance Object — update_constraints","text":"new distance_object updated cost_matrix","code":""},{"path":"https://gillescolling.com/couplr/reference/update_constraints.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Update Constraints on Distance Object — update_constraints","text":"function creates new distance_object modified constraints applied cost matrix. original distance_object modified. Constraints: max_distance: Sets cost Inf pairs exceeding threshold calipers: Per-variable restrictions (e.g., calipers = list(age = 5)) function returns new object rather modifying place, following R's copy--modify semantics.","code":""},{"path":"https://gillescolling.com/couplr/reference/update_constraints.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Update Constraints on Distance Object — update_constraints","text":"","code":"left <- data.frame(id = 1:5, age = c(25, 30, 35, 40, 45)) right <- data.frame(id = 6:10, age = c(24, 29, 36, 41, 44)) dist_obj <- compute_distances(left, right, vars = \"age\")  # Apply constraints constrained <- update_constraints(dist_obj, max_distance = 2) result <- match_couples(constrained)"},{"path":"https://gillescolling.com/couplr/reference/use_emoji.html","id":null,"dir":"Reference","previous_headings":"","what":"Check if emoji should be used — use_emoji","title":"Check if emoji should be used — use_emoji","text":"Check emoji used","code":""},{"path":"https://gillescolling.com/couplr/reference/use_emoji.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check if emoji should be used — use_emoji","text":"","code":"use_emoji()"},{"path":"https://gillescolling.com/couplr/reference/use_emoji.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check if emoji should be used — use_emoji","text":"Logical indicating whether emoji used.","code":""},{"path":"https://gillescolling.com/couplr/reference/validate_calipers.html","id":null,"dir":"Reference","previous_headings":"","what":"Validate calipers parameter — validate_calipers","title":"Validate calipers parameter — validate_calipers","text":"Validate calipers parameter","code":""},{"path":"https://gillescolling.com/couplr/reference/validate_calipers.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Validate calipers parameter — validate_calipers","text":"","code":"validate_calipers(calipers, vars)"},{"path":"https://gillescolling.com/couplr/reference/validate_calipers.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Validate calipers parameter — validate_calipers","text":"Validated calipers (list named numeric), NULL none.","code":""},{"path":"https://gillescolling.com/couplr/reference/validate_cost_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Validate and prepare cost data — validate_cost_data","title":"Validate and prepare cost data — validate_cost_data","text":"Internal helper ensures numeric, non-empty cost matrix.","code":""},{"path":"https://gillescolling.com/couplr/reference/validate_cost_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Validate and prepare cost data — validate_cost_data","text":"","code":"validate_cost_data(x, forbidden = NA)"},{"path":"https://gillescolling.com/couplr/reference/validate_cost_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Validate and prepare cost data — validate_cost_data","text":"x Cost matrix data frame forbidden Value representing forbidden assignments (use NA Inf)","code":""},{"path":"https://gillescolling.com/couplr/reference/validate_cost_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Validate and prepare cost data — validate_cost_data","text":"Numeric cost matrix","code":""},{"path":"https://gillescolling.com/couplr/reference/validate_matching_inputs.html","id":null,"dir":"Reference","previous_headings":"","what":"Validate matching inputs — validate_matching_inputs","title":"Validate matching inputs — validate_matching_inputs","text":"Validate matching inputs","code":""},{"path":"https://gillescolling.com/couplr/reference/validate_matching_inputs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Validate matching inputs — validate_matching_inputs","text":"","code":"validate_matching_inputs(left, right, vars = NULL)"},{"path":"https://gillescolling.com/couplr/reference/validate_matching_inputs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Validate matching inputs — validate_matching_inputs","text":"Invisibly returns TRUE validation passes; otherwise throws error.","code":""},{"path":"https://gillescolling.com/couplr/reference/validate_weights.html","id":null,"dir":"Reference","previous_headings":"","what":"Validate weights parameter — validate_weights","title":"Validate weights parameter — validate_weights","text":"Validate weights parameter","code":""},{"path":"https://gillescolling.com/couplr/reference/validate_weights.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Validate weights parameter — validate_weights","text":"","code":"validate_weights(weights, vars)"},{"path":"https://gillescolling.com/couplr/reference/validate_weights.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Validate weights parameter — validate_weights","text":"Numeric vector validated weights.","code":""},{"path":"https://gillescolling.com/couplr/reference/warn_constant_distance.html","id":null,"dir":"Reference","previous_headings":"","what":"All distances identical warning — warn_constant_distance","title":"All distances identical warning — warn_constant_distance","text":"distances identical warning","code":""},{"path":"https://gillescolling.com/couplr/reference/warn_constant_distance.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"All distances identical warning — warn_constant_distance","text":"","code":"warn_constant_distance(value)"},{"path":"https://gillescolling.com/couplr/reference/warn_constant_distance.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"All distances identical warning — warn_constant_distance","text":"return value, called side effects (issues warning).","code":""},{"path":"https://gillescolling.com/couplr/reference/warn_constant_var.html","id":null,"dir":"Reference","previous_headings":"","what":"Constant variable warning — warn_constant_var","title":"Constant variable warning — warn_constant_var","text":"Constant variable warning","code":""},{"path":"https://gillescolling.com/couplr/reference/warn_constant_var.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Constant variable warning — warn_constant_var","text":"","code":"warn_constant_var(var)"},{"path":"https://gillescolling.com/couplr/reference/warn_constant_var.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Constant variable warning — warn_constant_var","text":"return value, called side effects (issues warning).","code":""},{"path":"https://gillescolling.com/couplr/reference/warn_extreme_costs.html","id":null,"dir":"Reference","previous_headings":"","what":"Extreme cost ratio warning — warn_extreme_costs","title":"Extreme cost ratio warning — warn_extreme_costs","text":"Extreme cost ratio warning","code":""},{"path":"https://gillescolling.com/couplr/reference/warn_extreme_costs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extreme cost ratio warning — warn_extreme_costs","text":"","code":"warn_extreme_costs(p95, p99, ratio, problem_vars = NULL)"},{"path":"https://gillescolling.com/couplr/reference/warn_extreme_costs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extreme cost ratio warning — warn_extreme_costs","text":"return value, called side effects (issues warning).","code":""},{"path":"https://gillescolling.com/couplr/reference/warn_many_forbidden.html","id":null,"dir":"Reference","previous_headings":"","what":"Many forbidden pairs warning — warn_many_forbidden","title":"Many forbidden pairs warning — warn_many_forbidden","text":"Many forbidden pairs warning","code":""},{"path":"https://gillescolling.com/couplr/reference/warn_many_forbidden.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Many forbidden pairs warning — warn_many_forbidden","text":"","code":"warn_many_forbidden(pct_forbidden, n_valid, n_left)"},{"path":"https://gillescolling.com/couplr/reference/warn_many_forbidden.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Many forbidden pairs warning — warn_many_forbidden","text":"return value, called side effects (issues warning).","code":""},{"path":"https://gillescolling.com/couplr/reference/warn_many_zeros.html","id":null,"dir":"Reference","previous_headings":"","what":"Too many zeros warning — warn_many_zeros","title":"Too many zeros warning — warn_many_zeros","text":"many zeros warning","code":""},{"path":"https://gillescolling.com/couplr/reference/warn_many_zeros.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Too many zeros warning — warn_many_zeros","text":"","code":"warn_many_zeros(pct, n_zeros)"},{"path":"https://gillescolling.com/couplr/reference/warn_many_zeros.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Too many zeros warning — warn_many_zeros","text":"return value, called side effects (issues warning).","code":""},{"path":"https://gillescolling.com/couplr/reference/warn_parallel_unavailable.html","id":null,"dir":"Reference","previous_headings":"","what":"Parallel package missing warning (reuse from matching_parallel.R) — warn_parallel_unavailable","title":"Parallel package missing warning (reuse from matching_parallel.R) — warn_parallel_unavailable","text":"Parallel package missing warning (reuse matching_parallel.R)","code":""},{"path":"https://gillescolling.com/couplr/reference/warn_parallel_unavailable.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Parallel package missing warning (reuse from matching_parallel.R) — warn_parallel_unavailable","text":"","code":"warn_parallel_unavailable()"},{"path":"https://gillescolling.com/couplr/reference/warn_parallel_unavailable.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Parallel package missing warning (reuse from matching_parallel.R) — warn_parallel_unavailable","text":"return value, called side effects (issues warning).","code":""},{"path":"https://gillescolling.com/couplr/reference/warn_poor_quality.html","id":null,"dir":"Reference","previous_headings":"","what":"High distance matches warning — warn_poor_quality","title":"High distance matches warning — warn_poor_quality","text":"High distance matches warning","code":""},{"path":"https://gillescolling.com/couplr/reference/warn_poor_quality.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"High distance matches warning — warn_poor_quality","text":"","code":"warn_poor_quality(pct_poor, threshold)"},{"path":"https://gillescolling.com/couplr/reference/warn_poor_quality.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"High distance matches warning — warn_poor_quality","text":"return value, called side effects (issues warning).","code":""},{"path":[]},{"path":"https://gillescolling.com/couplr/todo.html","id":"completed","dir":"","previous_headings":"","what":"Completed","title":"couplr Algorithm Integration TODO","text":"Network Simplex implementation (20 tests passing) Orlin-Ahuja solver Push-Relabel solver Ramshaw-Tarjan rectangular solver Assignment duals extraction algorithms added assignment() main routine Run devtools::document() regenerate .Rd documentation Update _pkgdown.yml new functions (assignment_duals, bottleneck_assignment, sinkhorn, sinkhorn_to_assignment) Rebuild pkgdown website using build_site.R Commit network simplex changes (b9a3094) Update CLAUDE.md new algorithms (7861e87) Reorganized @param method categorized groups Expanded algorithms vignette 6 new algorithm sections Added specialized functions section (duals, bottleneck, sinkhorn) Updated quick reference performance tables","code":""},{"path":[]},{"path":[]},{"path":"https://gillescolling.com/couplr/VIGNETTE_IMPROVEMENT_PLAN.html","id":"executive-summary","dir":"","previous_headings":"","what":"Executive Summary","title":"Vignette Improvement Plan for couplr","text":"document outlines comprehensive plan address structural, narrative, meta-explanatory weaknesses identified four couplr vignettes. improvements focus : Unified documentation ecosystem cross-references consistent structure Shared example dataset recurs across vignettes Explicit audience guidance difficulty indicators Progressive narrative flow concept example interpretation Discussion limitations, edge cases, failure modes Clear positioning package R ecosystem","code":""},{"path":[]},{"path":"https://gillescolling.com/couplr/VIGNETTE_IMPROVEMENT_PLAN.html","id":"id_1-create-a-unified-introduction-section","dir":"","previous_headings":"Cross-Cutting Improvements (All Vignettes)","what":"1. Create a Unified Introduction Section","title":"Vignette Improvement Plan for couplr","text":"Add consistent introductory block vignette : States purpose target audience Positions vignette within documentation ecosystem Provides difficulty/prerequisite indicators Links related vignettes Template add start vignette (Overview):","code":"### Who This Vignette Is For  **Audience**: [Beginners | Intermediate users | Advanced users / Algorithm developers]  **Prerequisites**: - [List any required vignettes or knowledge] - [e.g., \"Basic R knowledge\", \"Familiarity with matching concepts\"]  **What You'll Learn**: - [3-5 specific takeaways]  **Time to Complete**: [Approximate reading/working time]  ### Documentation Roadmap  The couplr documentation is organized as follows:  | Vignette | Focus | Difficulty | |----------|-------|------------| | **Getting Started** | Basic LAP solving, API introduction | Beginner | | **Algorithms** | Mathematical foundations, solver selection | Intermediate | | **Matching Workflows** | Production matching pipelines | Intermediate | | **Pixel Morphing** | Scientific applications, approximations | Advanced |  *You are here: [Current vignette]*"},{"path":"https://gillescolling.com/couplr/VIGNETTE_IMPROVEMENT_PLAN.html","id":"id_2-introduce-a-shared-example-dataset","dir":"","previous_headings":"Cross-Cutting Improvements (All Vignettes)","what":"2. Introduce a Shared Example Dataset","title":"Vignette Improvement Plan for couplr","text":"Create recurring dataset appears across vignettes, establishing coherence: Proposal: “Hospital Staff Scheduling” dataset Basic form (getting-started): 10 nurses × 10 shifts, simple cost matrix Extended form (algorithms): problem different cost structures demonstrate algorithm differences Matching form (matching-workflows): 200 nurses needing matched 300 controls study Large-scale form (pixel-morphing): Analogy visual matching, demonstrate approximations needed Implementation: Add data/ hospital_example documentation R/data.R","code":""},{"path":"https://gillescolling.com/couplr/VIGNETTE_IMPROVEMENT_PLAN.html","id":"id_3-add-limitations-and-edge-cases-sections","dir":"","previous_headings":"Cross-Cutting Improvements (All Vignettes)","what":"3. Add “Limitations and Edge Cases” Sections","title":"Vignette Improvement Plan for couplr","text":"vignette include dedicated section discussing: method breaks Common failure modes Performance bottlenecks Infeasibility conditions Numerical issues","code":""},{"path":"https://gillescolling.com/couplr/VIGNETTE_IMPROVEMENT_PLAN.html","id":"id_4-establish-narrative-transitions","dir":"","previous_headings":"Cross-Cutting Improvements (All Vignettes)","what":"4. Establish Narrative Transitions","title":"Vignette Improvement Plan for couplr","text":"Add explicit transition paragraphs major sections : Summarize just covered Preview comes next Explain transition makes sense","code":""},{"path":[]},{"path":[]},{"path":"https://gillescolling.com/couplr/VIGNETTE_IMPROVEMENT_PLAN.html","id":"current-state","dir":"","previous_headings":"1. Getting Started (getting-started.Rmd)","what":"Current State","title":"Vignette Improvement Plan for couplr","text":"394 lines Jumps directly examples Good technical content reads like reference documentation Missing orientation positioning","code":""},{"path":[]},{"path":"https://gillescolling.com/couplr/VIGNETTE_IMPROVEMENT_PLAN.html","id":"a-add-explicit-orientation-new-section-after-line-22","dir":"","previous_headings":"1. Getting Started (getting-started.Rmd) > Improvements","what":"A. Add Explicit Orientation (New Section After Line 22)","title":"Vignette Improvement Plan for couplr","text":"Insert “## Overview”:","code":"### Why couplr?  The linear assignment problem (LAP) appears throughout data science, operations research, and scientific computing. While other R packages address LAP (see Comparison below), couplr distinguishes itself through:  1. **Tidy integration**: First-class support for tibbles, dplyr workflows, and grouped data 2. **Algorithm selection**: 12+ algorithms with automatic selection based on problem structure 3. **Production matching**: High-level matching functions for observational studies (v1.0.0) 4. **Visual applications**: Pixel morphing and transport visualization  **Alternative packages**: - `clue`: General purpose optimization (LAP is one feature among many) - `lpSolve`: Linear programming focus, less specialized for assignment - `RcppHungarian`: Single algorithm, no tidy interface  couplr focuses specifically on assignment problems with a user-friendly API and modern R idioms.  ### Who This Vignette Is For  **Audience**: Beginners to couplr, R users familiar with basic matrix operations  **Prerequisites**: - Basic R knowledge (data frames, functions) - Understanding of what a \"cost\" or \"distance\" matrix means  **What You'll Learn**: - How to solve basic assignment problems with `lap_solve()` - Working with data frames, rectangular problems, and forbidden assignments - Batch solving and finding multiple solutions - When to use different algorithms  **Time to Complete**: 20-30 minutes"},{"path":"https://gillescolling.com/couplr/VIGNETTE_IMPROVEMENT_PLAN.html","id":"b-add-narrative-frame-follow-one-problem-through","dir":"","previous_headings":"1. Getting Started (getting-started.Rmd) > Improvements","what":"B. Add Narrative Frame: Follow One Problem Through","title":"Vignette Improvement Plan for couplr","text":"Restructure vignette around single problem evolves: Introduction: Hospital shift scheduling (simple 3×3) Data frame input: problem database Rectangular: shifts nurses Forbidden: nurses can’t work certain shifts Maximization: Preference scores instead costs Batch: Multiple days scheduling K-best: Alternative schedules flexibility Modification existing content: Keep current examples frame variations hospital problem. Add narrative transitions like: “Now can solve basic problem, happens shifts nurses fill ?”","code":""},{"path":"https://gillescolling.com/couplr/VIGNETTE_IMPROVEMENT_PLAN.html","id":"c-add-common-pitfalls-section-before-summary","dir":"","previous_headings":"1. Getting Started (getting-started.Rmd) > Improvements","what":"C. Add “Common Pitfalls” Section (Before Summary)","title":"Vignette Improvement Plan for couplr","text":"","code":"## Common Pitfalls and Troubleshooting  ### Problem: \"All assignments have Inf cost\"  **Cause**: Too many forbidden entries (NA/Inf) make the problem infeasible.  **Solution**: Check that a feasible solution exists. For rectangular problems with forbidden entries, ensure at least one valid assignment exists for each source.  ```r # Check feasibility feasible <- rowSums(is.finite(cost)) > 0 if (!all(feasible)) {   warning(\"Sources \", which(!feasible), \" have no valid targets\") }"},{"path":"https://gillescolling.com/couplr/VIGNETTE_IMPROVEMENT_PLAN.html","id":"problem-unexpected-assignments","dir":"","previous_headings":"1. Getting Started (getting-started.Rmd)","what":"Problem: Unexpected assignments","title":"Vignette Improvement Plan for couplr","text":"Cause: Cost matrix orientation wrong (rows vs columns swapped). Solution: Remember: rows = sources, columns = targets. result match vector length = nrow, match[] column assigned row .","code":""},{"path":"https://gillescolling.com/couplr/VIGNETTE_IMPROVEMENT_PLAN.html","id":"problem-different-results-with-different-methods","dir":"","previous_headings":"1. Getting Started (getting-started.Rmd)","what":"Problem: Different results with different methods","title":"Vignette Improvement Plan for couplr","text":"Cause: Multiple optimal solutions may exist. Different algorithms may find different optima total cost. Solution: need deterministic results, set seed use method = \"hungarian\" deterministic tie-breaking.","code":""},{"path":"https://gillescolling.com/couplr/VIGNETTE_IMPROVEMENT_PLAN.html","id":"problem-slow-performance-on-large-problems","dir":"","previous_headings":"1. Getting Started (getting-started.Rmd)","what":"Problem: Slow performance on large problems","title":"Vignette Improvement Plan for couplr","text":"Cause: O(n³) complexity exact algorithms. Solution: - n > 1000: Consider method = \"auction\" - n > 5000: Use blocking greedy matching (vignette(\"matching-workflows\")) - n > 10000: Use approximation strategies (vignette(\"pixel-morphing\"))","code":"#### D. Improve Section Transitions  Add transition paragraphs. Example between \"Basic Usage\" and \"Working with Rectangular Problems\":  > \"The examples above assumed equal numbers of sources and targets. But real-world problems rarely have this symmetry—a hospital may have 20 nurses but need to cover 30 shifts, or have 50 tasks but only budget for 40 workers. couplr handles these rectangular problems automatically.\"  ---  ## 2. Algorithms (algorithms.Rmd)  ### Current State - 667 lines - Good mathematical content - Stays at intuitive level, lacks formal structure - No explicit comparison between algorithms - No failure modes discussed  ### Improvements  #### A. Add Structured Algorithm Template  Restructure each algorithm section to follow a consistent pattern:  ```markdown ### [Algorithm Name]  **Complexity**: [Big-O notation]  **When to Use**: - [Bullet points of ideal conditions]  **When NOT to Use**: - [Bullet points of poor conditions]  #### Core Idea  [1-2 paragraph intuitive explanation]  #### Formal Description  [Mathematical formulation with LaTeX]  **Input**: [Describe input requirements]  **Output**: [Describe output guarantees]  **Algorithm Steps**: 1. [Numbered steps with mathematical notation]  #### Implementation Notes  [Practical considerations, numerical issues]  #### Example  [Code demonstrating the algorithm]  #### Failure Modes and Edge Cases  - [When the algorithm may fail or perform poorly] - [Numerical stability concerns] - [Special cases to watch for]"},{"path":"https://gillescolling.com/couplr/VIGNETTE_IMPROVEMENT_PLAN.html","id":"b-add-comparative-analysis-section","dir":"","previous_headings":"1. Getting Started (getting-started.Rmd) > Problem: Slow performance on large problems","what":"B. Add Comparative Analysis Section","title":"Vignette Improvement Plan for couplr","text":"Insert “## Algorithms couplr” (around line 68):","code":"### Algorithm Selection Guide  Before diving into individual algorithms, here's a decision framework: Is the cost matrix binary (0/1)?                           |           ┌───────────────┴───────────────┐           Yes                             No           |                               |       Use HK01                    Is sparsity > 50%?                                           |                           ┌───────────────┴───────────────┐                           Yes                             No                           |                               |                       Use SAP                      Is n > 1000?                                                           |                                           ┌───────────────┴───────────────┐                                           Yes                             No                                           |                               |                                       Use Auction              Use JV (default)                                       or consider                                       approximations ### Head-to-Head Comparisons  | Scenario | Hungarian | JV | Auction | SAP | HK01 | |----------|-----------|----|---------|----|------| | Dense 100×100 | ✓✓✓ | ✓✓✓ | ✓✓ | ✓ | N/A | | Dense 1000×1000 | ✓ | ✓✓✓ | ✓✓✓ | ✓ | N/A | | Sparse 80% forbidden | ✓ | ✓✓ | ✓ | ✓✓✓ | N/A | | Binary costs | ✓ | ✓ | ✓ | ✓ | ✓✓✓ | | Rectangular n×2n | ✗ | ✓✓ | ✗ | ✓✓✓ | ✓✓ | | Numerical precision | ✓✓✓ | ✓✓ | ✓ | ✓✓ | ✓✓✓ |  ✓✓✓ = Excellent, ✓✓ = Good, ✓ = Acceptable, ✗ = Not recommended"},{"path":"https://gillescolling.com/couplr/VIGNETTE_IMPROVEMENT_PLAN.html","id":"c-add-limitations-and-numerical-issues-section","dir":"","previous_headings":"1. Getting Started (getting-started.Rmd) > Problem: Slow performance on large problems","what":"C. Add “Limitations and Numerical Issues” Section","title":"Vignette Improvement Plan for couplr","text":"Detection: Check rowSums(.finite(cost)) > 0 rows. 2. Nearly Degenerate Problems many costs nearly equal, small numerical errors can cause: - Different algorithms finding different solutions - Cycling auction algorithms - Incorrect optimality certification Mitigation: Use method = \"hungarian\" maximum numerical stability, add small random perturbations. 3. Overflow Dual Variables large cost ranges (> 10^10), dual variable updates may overflow: Mitigation: Scale costs reasonable range (0 10^6) solving.","code":"## Limitations and Numerical Issues  ### When LAP Algorithms Fail  **1. Infeasible Problems**  If too many entries are forbidden (NA/Inf), no valid assignment may exist:  ```r # Infeasible: no column reachable from row 2 cost <- matrix(c(1, 2, Inf, Inf), nrow = 2) # lap_solve(cost) will error or return partial solution # Problematic: cost range is 10^15 cost <- matrix(c(1e-5, 1e10, 1e10, 1e-5), nrow = 2)"},{"path":"https://gillescolling.com/couplr/VIGNETTE_IMPROVEMENT_PLAN.html","id":"algorithm-specific-issues","dir":"","previous_headings":"1. Getting Started (getting-started.Rmd)","what":"Algorithm-Specific Issues","title":"Vignette Improvement Plan for couplr","text":"Sources (rows) Targets (columns) Edge weights = costs Goal: Select one edge per source, one per target, minimizing total weight","code":"#### D. Add Conceptual Diagram Section  **Insert after Formal Definition (around line 45):**  ```markdown ### Visualizing the Assignment Problem  **Bipartite Graph Representation**  Imagine the LAP as a weighted bipartite graph: S₁ ───────2──────── T₁  │ ╲     ╱         ╱│  │  ╲4  ╱3        ╱ │  3   ╲ ╱        5   1  │    ╳          ╱  │  │   ╱ ╲       ╱    │ S₂ ─╱───╲──1──╱──── T₂    ╱     ╲   ╱     ╱   ╱       ╲ ╱    2 S₃ ────3───╳───── T₃ **Complementary Slackness Intuition**  At optimality, think of dual variables as \"prices\": - $u_i$ = how much source $i$ is willing to pay - $v_j$ = how much target $j$ is worth  An assignment $(i,j)$ is used only if $u_i + v_j = c_{ij}$ (price equals cost)."},{"path":[]},{"path":"https://gillescolling.com/couplr/VIGNETTE_IMPROVEMENT_PLAN.html","id":"current-state-1","dir":"","previous_headings":"3. Matching Workflows (matching-workflows.Rmd)","what":"Current State","title":"Vignette Improvement Plan for couplr","text":"1134 lines (longest vignette) Applied concrete Reads like isolated steps rather cohesive journey Missing interpretation guidance pitfall discussion Good real-world example end comes late","code":""},{"path":[]},{"path":"https://gillescolling.com/couplr/VIGNETTE_IMPROVEMENT_PLAN.html","id":"a-move-real-world-example-earlier","dir":"","previous_headings":"3. Matching Workflows (matching-workflows.Rmd) > Improvements","what":"A. Move Real-World Example Earlier","title":"Vignette Improvement Plan for couplr","text":"Restructure follow real-world example throughout: Introduction: Present job training evaluation scenario Basic matching: First attempt match_couples() Preprocessing: need auto_scale = TRUE Balance assessment: match good enough? Refinements: Adding calipers, trying greedy Publication output: Tables effect estimates makes vignette narrative journey rather feature catalog.","code":""},{"path":"https://gillescolling.com/couplr/VIGNETTE_IMPROVEMENT_PLAN.html","id":"b-add-what-can-go-wrong-section","dir":"","previous_headings":"3. Matching Workflows (matching-workflows.Rmd) > Improvements","what":"B. Add “What Can Go Wrong” Section","title":"Vignette Improvement Plan for couplr","text":"Insert “## Automatic Preprocessing” (around line 189): Solutions: - Relax caliper - Use coarser blocking - Consider propensity score matching wider bands","code":"### What Can Go Wrong  #### 1. Poor Match Quality Despite Convergence  **Symptom**: `match_couples()` completes but balance diagnostics show |std diff| > 0.25.  **Causes**: - Fundamental differences between groups that matching cannot overcome - Important confounders not included in matching variables - Caliper too loose  **Solutions**: - Add more matching variables - Tighten caliper (accept fewer matches) - Consider different estimand (ATT vs ATE) - Report sensitivity analysis  #### 2. Few or No Matches  **Symptom**: `n_matched` is much smaller than expected.  **Causes**: - Caliper too strict - Non-overlapping support (groups truly different) - Blocking variables create small strata  **Diagnosis**: ```r # Check overlap ggplot(bind_rows(left, right), aes(x = age, fill = group)) +   geom_density(alpha = 0.5)"},{"path":"https://gillescolling.com/couplr/VIGNETTE_IMPROVEMENT_PLAN.html","id":"id_3-imbalanced-but-optimal","dir":"","previous_headings":"3. Matching Workflows (matching-workflows.Rmd) > Improvements","what":"3. Imbalanced but Optimal","title":"Vignette Improvement Plan for couplr","text":"Symptom: Optimal matching completes balance worse greedy. Reality: Optimal minimizes total distance, balance metrics. globally optimal solution may sacrifice balance one variable gain another. Solutions: - Try greedy matching (may find different local optimum) - Add explicit balance constraints (future feature) - Use matching replacement (different estimand)","code":""},{"path":"https://gillescolling.com/couplr/VIGNETTE_IMPROVEMENT_PLAN.html","id":"id_4-computational-issues","dir":"","previous_headings":"3. Matching Workflows (matching-workflows.Rmd) > Improvements","what":"4. Computational Issues","title":"Vignette Improvement Plan for couplr","text":"Symptom: match_couples() takes > 1 minute crashes. Causes: - n > 5000 optimal matching - Full cost matrix doesn’t fit memory Solutions: read : Overall assessment: well-balanced match. Proceed analysis. balance poor (|std_diff| > 0.25): 1. Check outliers problematic variable 2. Consider adding variable blocking 3. Tighten caliper 4. Report discuss limitations","code":"# For n > 5000: use greedy result <- greedy_couples(left, right, vars = vars, strategy = \"sorted\")  # For n > 10000: use blocking blocks <- matchmaker(left, right, block_type = \"cluster\", n_blocks = 20) result <- match_couples(blocks$left, blocks$right, vars = vars, block_id = \"block_id\") #### C. Add Interpretation Guidance Throughout  After each balance diagnostic output, add interpretation:  ```markdown ### Interpreting Balance Results  ```r print(balance) #> Balance Diagnostics #> ------------------- #> Variables: age, income, education #> #> Variable Statistics: #>   variable mean_left mean_right std_diff var_ratio ks_stat ks_p #>   age      45.2      45.8       -0.08    0.95      0.06    0.89 #>   income   58000     56500      0.12     1.08      0.09    0.45 #>   education 2.1      2.0        0.15     0.98      0.08    0.62 #### D. Add Section Transitions  Example transition after \"Basic Usage\":  > \"We've created our first matched sample, but how do we know it's any good? A match that pairs units with wildly different characteristics defeats the purpose. In the next section, we examine how automatic preprocessing prevents common data problems from degrading match quality.\"  ---  ## 4. Pixel Morphing (pixel-morphing.Rmd)  ### Current State - 884 lines - Excellent pedagogical intent - Conceptually rich but jumps between intuition and application - Purpose not fully clear (teach intuition? show feature? provide motivation?) - No connection to practical workflows  ### Improvements  #### A. Clarify Purpose Upfront  **Replace current Overview with:**  ```markdown ## Overview  This vignette serves three purposes:  1. **Visual intuition**: Use image morphing to build intuition for assignment problems. Pixels are entities, colors are features, positions are spatial coordinates—a direct analog to scientific matching.  2. **Scalability strategies**: Demonstrate three approximation approaches when exact LAP becomes infeasible (n > 1000).  3. **Scientific applications**: Show how the same algorithms apply to ecology, physics, and chemistry.  **This vignette is unusual**: Unlike the other couplr documentation, it emphasizes *understanding* over *doing*. If you're looking to solve a matching problem, start with `vignette(\"getting-started\")` or `vignette(\"matching-workflows\")`. Come here when you want to understand *why* these algorithms work and *when* approximations are appropriate.  ### Who This Vignette Is For  **Audience**: Advanced users, researchers, algorithm developers  **Prerequisites**: - Familiarity with `lap_solve()` (`vignette(\"getting-started\")`) - Basic understanding of complexity (Big-O notation) - Interest in algorithm design or scientific applications  **What You'll Learn**: - Why exact LAP becomes infeasible for large n - Three approximation strategies and their trade-offs - How matching problems appear in ecology, physics, and chemistry - Mathematical connections to optimal transport theory  **Time to Complete**: 45-60 minutes (conceptual reading)"},{"path":"https://gillescolling.com/couplr/VIGNETTE_IMPROVEMENT_PLAN.html","id":"b-add-explicit-conceptual-scaffolding","dir":"","previous_headings":"3. Matching Workflows (matching-workflows.Rmd) > Improvements","what":"B. Add Explicit Conceptual Scaffolding","title":"Vignette Improvement Plan for couplr","text":"Insert Overview, “General Matching Problem”: Exact Solution Approximation Strategies Applications (Foundation) (exact fails) (Real-world) │ │ │ ▼ ▼ ▼ 1. Feature quantization Ecology: plots matching problem? 2. Hierarchical decomp. Physics: particles │ 3. Resolution reduction Chemistry: atoms │ │ │ ▼ ▼ ▼ Visual demo: Visual comparison Pseudocode pixel morphing approximations domain","code":"## How This Vignette Is Organized  We follow a specific arc: **Key insight**: The pixel morph is not just decoration—it's a computational testbed. Each pixel is an entity with features (color) and position, making the abstract matching problem concrete and visual."},{"path":"https://gillescolling.com/couplr/VIGNETTE_IMPROVEMENT_PLAN.html","id":"c-add-connection-to-workflows-section","dir":"","previous_headings":"3. Matching Workflows (matching-workflows.Rmd) > Improvements","what":"C. Add “Connection to Workflows” Section","title":"Vignette Improvement Plan for couplr","text":"Insert Summary: n > 10000: n > 50000: Consider approximation strategies vignette, implemented via custom code using lap_solve() subproblems.","code":"## Connection to couplr Workflows  ### When Do These Strategies Apply?  The approximation strategies in this vignette become relevant in couplr's matching functions:  | Strategy | couplr Implementation | When to Use | |----------|----------------------|-------------| | Exact LAP | `match_couples(method = \"hungarian\")` | n < 3000 | | Feature quantization | Implicit in `scale = \"robust\"` | Reduces effective feature space | | Hierarchical | `matchmaker(block_type = \"cluster\")` | n > 3000, use blocking | | Resolution reduction | Future feature | Very large n |  ### Practical Recommendations  **For n < 3000**: Use `match_couples()` with exact algorithms. Runtime is seconds.  **For 3000 < n < 10000**: ```r # Use blocking to create smaller subproblems blocks <- matchmaker(left, right, block_type = \"cluster\", n_blocks = 10) result <- match_couples(blocks$left, blocks$right, vars, block_id = \"block_id\") # Use greedy matching result <- greedy_couples(left, right, vars, strategy = \"sorted\") #### D. Add Limitations Section  ```markdown ## Limitations of Approximation Strategies  ### Feature Quantization  **Works well when**: Features cluster naturally into distinct groups (e.g., vegetation types, particle species, atom types).  **Fails when**: - Feature space is continuous with no natural clusters - Important distinctions exist within clusters - Spatial structure doesn't align with feature groups  **Artifacts**: Band-like motion, loss of individual trajectories, discrete jumps.  ### Hierarchical Decomposition  **Works well when**: Spatial locality is meaningful (nearby entities should match nearby).  **Fails when**: - Optimal matches cross spatial boundaries (e.g., long-distance particle transport) - Patch boundaries cut through important structures - Hierarchy depth is mismatched to problem structure  **Artifacts**: Boundary discontinuities, suboptimal cross-region matches.  ### Resolution Reduction  **Works well when**: Coarse structure is sufficient, fine detail is noise.  **Fails when**: - Fine-grained structure matters (individual atom positions, exact pixel colors) - Upscaling introduces ambiguity  **Artifacts**: Blocky results, non-bijective mappings (multiple fine entities per coarse cell)."},{"path":[]},{"path":"https://gillescolling.com/couplr/VIGNETTE_IMPROVEMENT_PLAN.html","id":"phase-1-cross-cutting-do-first","dir":"","previous_headings":"Implementation Checklist","what":"Phase 1: Cross-Cutting (Do First)","title":"Vignette Improvement Plan for couplr","text":"Create shared example dataset (hospital_example) Write standard documentation roadmap block Create transition paragraph templates","code":""},{"path":"https://gillescolling.com/couplr/VIGNETTE_IMPROVEMENT_PLAN.html","id":"phase-2-getting-started","dir":"","previous_headings":"Implementation Checklist","what":"Phase 2: Getting Started","title":"Vignette Improvement Plan for couplr","text":"Add orientation paragraph (couplr, positioning) Add “Vignette ” block Restructure around hospital scheduling narrative Add “Common Pitfalls” section Add section transitions Review improve cross-references","code":""},{"path":"https://gillescolling.com/couplr/VIGNETTE_IMPROVEMENT_PLAN.html","id":"phase-3-algorithms","dir":"","previous_headings":"Implementation Checklist","what":"Phase 3: Algorithms","title":"Vignette Improvement Plan for couplr","text":"Apply structured algorithm template algorithm Add comparative analysis section decision tree Add “Limitations Numerical Issues” section Add conceptual diagram (bipartite graph) Add algorithm-specific failure modes Improve cross-references","code":""},{"path":"https://gillescolling.com/couplr/VIGNETTE_IMPROVEMENT_PLAN.html","id":"phase-4-matching-workflows","dir":"","previous_headings":"Implementation Checklist","what":"Phase 4: Matching Workflows","title":"Vignette Improvement Plan for couplr","text":"Restructure follow job training example throughout Add “Can Go Wrong” section Add interpretation guidance diagnostic Add section transitions Shorten/consolidate redundant sections Improve cross-references","code":""},{"path":"https://gillescolling.com/couplr/VIGNETTE_IMPROVEMENT_PLAN.html","id":"phase-5-pixel-morphing","dir":"","previous_headings":"Implementation Checklist","what":"Phase 5: Pixel Morphing","title":"Vignette Improvement Plan for couplr","text":"Clarify purpose Overview Add conceptual scaffolding diagram Add “Connection Workflows” section Add limitations approximation strategies Improve cross-references","code":""},{"path":"https://gillescolling.com/couplr/VIGNETTE_IMPROVEMENT_PLAN.html","id":"phase-6-final-integration","dir":"","previous_headings":"Implementation Checklist","what":"Phase 6: Final Integration","title":"Vignette Improvement Plan for couplr","text":"Verify cross-references work Check shared dataset used consistently Build vignettes verify rendering Review narrative flow across vignettes Final copyedit pass","code":""},{"path":"https://gillescolling.com/couplr/VIGNETTE_IMPROVEMENT_PLAN.html","id":"estimated-effort","dir":"","previous_headings":"","what":"Estimated Effort","title":"Vignette Improvement Plan for couplr","text":"Total estimated effort: 3-5 focused work sessions","code":""},{"path":"https://gillescolling.com/couplr/VIGNETTE_IMPROVEMENT_PLAN.html","id":"success-criteria","dir":"","previous_headings":"","what":"Success Criteria","title":"Vignette Improvement Plan for couplr","text":"improvements, vignette : Clearly state ’s ’ll learn Position within documentation ecosystem Follow narrative builds logically Provide interpretation just mechanics Discuss limitations honestly Cross-reference related vignettes appropriately Use shared dataset appropriate coherence documentation whole feel like chapters book rather independent reference documents.","code":""},{"path":[]},{"path":"https://gillescolling.com/couplr/news/index.html","id":"bug-fixes-1-0-7","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"couplr 1.0.7","text":"Fixed undefined behavior (UB) Gabow-Tarjan algorithm: replaced left bit-shift potentially negative values multiplication avoid sanitizer errors M1-SAN checks Fixed namespace conflict select() vignettes using explicit dplyr::select() prevent masking MASS packages","code":""},{"path":"https://gillescolling.com/couplr/news/index.html","id":"couplr-106","dir":"Changelog","previous_headings":"","what":"couplr 1.0.6","title":"couplr 1.0.6","text":"CRAN release: 2026-01-20","code":""},{"path":"https://gillescolling.com/couplr/news/index.html","id":"documentation-1-0-6","dir":"Changelog","previous_headings":"","what":"Documentation","title":"couplr 1.0.6","text":"Added Overview section algorithms vignette audience prerequisites Fixed workflow diagram dark mode text handling matching-workflows vignette Improved SVG theme-awareness multi-line text labels Removed grid lines matching-workflows plots cleaner appearance Added threshold labels balance comparison plot","code":""},{"path":[]},{"path":[]},{"path":"https://gillescolling.com/couplr/news/index.html","id":"automatic-preprocessing-and-scaling-1-0-0","dir":"Changelog","previous_headings":"Major New Features (2025-11-19 Update)","what":"Automatic Preprocessing and Scaling","title":"couplr 1.0.0","text":"package now includes intelligent preprocessing improve matching quality: New auto_scale parameter match_couples() greedy_couples() enables automatic preprocessing Constant columns (SD = 0) automatically excluded warnings High missingness (>50%) triggers warnings Extreme skewness (|skewness| > 2) flagged “robust” scaling using median MAD (resistant outliers) “standardize” traditional mean-centering SD scaling “range” min-max normalization New preprocess_matching_vars() function manual preprocessing control Categorical variable encoding binary ordered factors","code":""},{"path":"https://gillescolling.com/couplr/news/index.html","id":"balance-diagnostics-1-0-0","dir":"Changelog","previous_headings":"Major New Features (2025-11-19 Update)","what":"Balance Diagnostics","title":"couplr 1.0.0","text":"Comprehensive tools assess matching quality: Standardized differences: (mean_left - mean_right) / pooled_sd Variance ratios: SD_left / SD_right Kolmogorov-Smirnov tests distribution comparison Overall balance metrics (mean, max, % large imbalance) |Std Diff| < 0.10: Excellent balance |Std Diff| 0.10-0.25: Good balance |Std Diff| 0.25-0.50: Acceptable balance |Std Diff| > 0.50: Poor balance Per-block statistics quality ratings blocking used balance_table() creates publication-ready formatted tables Informative print methods interpretation guides","code":""},{"path":"https://gillescolling.com/couplr/news/index.html","id":"joined-matched-dataset-output-1-0-0","dir":"Changelog","previous_headings":"Major New Features (2025-11-19 Update)","what":"Joined Matched Dataset Output","title":"couplr 1.0.0","text":"Create analysis-ready datasets directly matching results: Joins matched pairs original left right datasets Eliminates manual data wrangling matching Select specific variables via left_vars right_vars parameters Customizable suffixes (default: _left, _right) overlapping columns Optional metadata: pair_id, distance, block_id Works optimal greedy matching S3 method following broom package conventions Sensible defaults quick exploration Supports join_matched() parameters include_distance - Include/exclude matching distance include_pair_id - Include/exclude sequential pair IDs include_block_id - Include/exclude block identifiers Custom ID column support via left_id right_id Clean column ordering: pair_id → IDs → distance → block → variables","code":""},{"path":"https://gillescolling.com/couplr/news/index.html","id":"precomputed-and-reusable-distances-1-0-0","dir":"Changelog","previous_headings":"Major New Features (2025-11-19 Update)","what":"Precomputed and Reusable Distances","title":"couplr 1.0.0","text":"Performance optimization exploring multiple matching strategies: Compute distances , reuse across multiple matching operations Store complete metadata: variables, distance metric, scaling method, timestamps Preserve original datasets seamless integration join_matched() Enable rapid exploration different matching parameters Performance improvement: ~60% faster trying multiple matching strategies Self-contained: cost matrix, IDs, metadata, original data Works match_couples() greedy_couples() Pass first argument instead datasets: match_couples(dist_obj, max_distance = 5) Informative print summary methods distance statistics Apply new max_distance calipers without recomputing distances Creates new distance object following copy--modify semantics Experiment different constraints efficiently Modified function signatures: match_couples(left, right = NULL, vars = NULL, ...) Automatically detects distance objects vs. datasets existing code continues work unchanged","code":""},{"path":"https://gillescolling.com/couplr/news/index.html","id":"parallel-processing-1-0-0","dir":"Changelog","previous_headings":"Major New Features (2025-11-19 Update)","what":"Parallel Processing","title":"couplr 1.0.0","text":"Speed blocked matching multi-core processing: Enable parallel = TRUE automatic configuration Specify plan parallel = \"multisession\" future plan Works number blocks - automatically determines beneficial Gracefully falls back future packages installed Cross-platform support (Windows, Unix/Mac, clusters) Respects user-configured parallel backends Automatic worker management Clean restoration original plan execution Best 10+ blocks 50+ units per block Speedup scales number cores complexity Minimal overhead small problems Works blocking methods (exact, fuzzy, clustering) Compatible distance caching Step 4 Supports matching parameters (constraints, calipers, scaling)","code":""},{"path":"https://gillescolling.com/couplr/news/index.html","id":"fun-error-messages-and-cost-checking-1-0-0","dir":"Changelog","previous_headings":"Major New Features (2025-11-19 Update)","what":"Fun Error Messages and Cost Checking","title":"couplr 1.0.0","text":"Like testthat, couplr makes errors light, memorable, helpful couple-themed messages: Automatically checks distance distributions matching Provides friendly, actionable warnings common problems Set FALSE skip checks production code 💔 “matches made - can’t couple without candidates!” 🔍 “constraints strict. Love can’t bloom vacuum!” ✨ Helpful suggestions: “Try increasing max_distance relaxing calipers” 💖 Success messages: “Excellent balance! couples well-matched!” many zeros: Warns duplicates identical values (>10% zero distances) Extreme costs: Detects skewed distributions (99th percentile > 10x 95th) Many forbidden pairs: Warns constraints eliminate >50% valid pairs Constant distances: Alerts distances identical Constant variables: Detects excludes variables variation Comprehensive analysis cost distributions Variable-specific problem detection Actionable suggestions fixes Quality rating (good/fair/poor) Emoji control: Disable options(couplr.emoji = FALSE) preferred Philosophy: Errors less intimidating, memorable, provide clear guidance","code":""},{"path":"https://gillescolling.com/couplr/news/index.html","id":"new-functions-1-0-0","dir":"Changelog","previous_headings":"Major New Features (2025-11-19 Update)","what":"New Functions","title":"couplr 1.0.0","text":"preprocess_matching_vars() - Main preprocessing orchestrator balance_diagnostics() - Comprehensive balance assessment balance_table() - Formatted balance tables reporting join_matched() - Create analysis-ready datasets matching results augment.matching_result() - Broom-style interface joined data compute_distances() - Precompute cache distance matrices update_constraints() - Modify constraints distance objects is_distance_object() - Type checking distance objects diagnose_distance_matrix() - Comprehensive distance diagnostics check_cost_distribution() - Check distribution problems Added robust scaling method using median MAD","code":""},{"path":"https://gillescolling.com/couplr/news/index.html","id":"documentation--examples-1-0-0","dir":"Changelog","previous_headings":"Major New Features (2025-11-19 Update)","what":"Documentation & Examples","title":"couplr 1.0.0","text":"examples/auto_scale_demo.R - 5 preprocessing demonstrations examples/balance_diagnostics_demo.R - 6 balance diagnostic examples examples/join_matched_demo.R - 8 joined dataset demonstrations examples/distance_cache_demo.R - Distance caching reuse examples examples/parallel_matching_demo.R - 7 parallel processing examples examples/error_messages_demo.R - 10 fun error message demonstrations Complete implementation documentation (claude/IMPLEMENTATION_STEP1.md STEP6.md) functions full Roxygen documentation","code":""},{"path":"https://gillescolling.com/couplr/news/index.html","id":"tests-1-0-0","dir":"Changelog","previous_headings":"Major New Features (2025-11-19 Update)","what":"Tests","title":"couplr 1.0.0","text":"Added 34+ new tests (10 preprocessing, 11 balance diagnostics, 13 joined datasets, tests distance caching) tests passing full backward compatibility","code":""},{"path":[]},{"path":"https://gillescolling.com/couplr/news/index.html","id":"package-renamed-lapr--couplr-1-0-0","dir":"Changelog","previous_headings":"Major Changes (Initial 1.0.0 Release)","what":"Package Renamed: lapr → couplr","title":"couplr 1.0.0","text":"package renamed lapr couplr better reflect purpose general pairing matching toolkit. couplr = Optimal pairing matching via linear assignment","code":""},{"path":"https://gillescolling.com/couplr/news/index.html","id":"clean-release-1-0-0","dir":"Changelog","previous_headings":"Major Changes (Initial 1.0.0 Release)","what":"Clean 1.0.0 Release","title":"couplr 1.0.0","text":"First official stable release clean, well-organized codebase.","code":""},{"path":[]},{"path":"https://gillescolling.com/couplr/news/index.html","id":"r-code-1-0-0","dir":"Changelog","previous_headings":"New Organization","what":"R Code","title":"couplr 1.0.0","text":"Eliminated 3 redundant files Consistent morph_* naming prefix Two-layer API: assignment() (low-level) + lap_solve() (tidy) 10 well-organized files (13)","code":""},{"path":"https://gillescolling.com/couplr/news/index.html","id":"c-code-1-0-0","dir":"Changelog","previous_headings":"New Organization","what":"C++ Code","title":"couplr 1.0.0","text":"src/core/ - Utilities headers src/interface/ - Rcpp exports src/solvers/ - 14 LAP algorithms src/gabow_tarjan/ - Gabow-Tarjan solver src/morph/ - Image morphing","code":""},{"path":[]},{"path":"https://gillescolling.com/couplr/news/index.html","id":"solvers-1-0-0","dir":"Changelog","previous_headings":"Features","what":"Solvers","title":"couplr 1.0.0","text":"Hungarian, Jonker-Volgenant, Auction (3 variants), SAP/SSP, SSAP-Bucket, Cost-scaling, Cycle-cancel, Gabow-Tarjan, Hopcroft-Karp, Line-metric, Brute-force, Auto-select","code":""},{"path":"https://gillescolling.com/couplr/news/index.html","id":"high-level-1-0-0","dir":"Changelog","previous_headings":"Features","what":"High-Level","title":"couplr 1.0.0","text":"✅ Tidy tibble interface ✅ Matrix & data frame inputs ✅ Grouped data frames ✅ Batch solving + parallelization ✅ K-best solutions (Murty, Lawler) ✅ Rectangular matrices ✅ Forbidden assignments (NA/Inf) ✅ Maximize/minimize ✅ Pixel morphing visualization","code":""},{"path":"https://gillescolling.com/couplr/news/index.html","id":"api-1-0-0","dir":"Changelog","previous_headings":"","what":"API","title":"couplr 1.0.0","text":"lap_solve() - Main tidy interface lap_solve_batch() - Batch solving lap_solve_kbest() - K-best solutions assignment() - Low-level solver Utilities: get_total_cost(), as_assignment_matrix(), etc. Visualization: pixel_morph(), pixel_morph_animate() Development history “lapr” available git log v1.0.0.","code":""}]
