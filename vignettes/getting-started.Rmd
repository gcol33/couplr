---
title: "Quick Start"
author: "Gilles Colling"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Quick Start}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 7,
  fig.height = 5
)
library(couplr)
```

## What couplr Does

couplr solves the Linear Assignment Problem (LAP): given a cost matrix where entry (i, j) represents the cost of assigning source i to target j, find the one-to-one assignment that minimizes total cost. It also provides production-ready matching workflows for observational studies (see `vignette("matching-workflows")`).

## Interface Hierarchy

couplr provides three levels of interface:

### Level 1: LAP Solvers

**lap_solve()** - Core assignment problem solver:

- Accepts matrices, data frames, or grouped data
- Returns tidy tibble output
- Automatic algorithm selection

**assignment()** - Low-level solver:

- Direct C++ backend access
- Returns list with match vector

### Level 2: Extended Solving

**lap_solve_batch()** - Solve many problems at once:

- List of cost matrices input
- Optional parallel execution
- Efficient for many small problems

**lap_solve_kbest()** - Find multiple solutions:

- Returns k-best assignments (Murty's algorithm)
- Useful for robustness analysis

### Level 3: Matching Workflows

**match_couples()** - Optimal one-to-one matching:

- Automatic preprocessing and scaling
- Balance diagnostics
- Production-ready for observational studies

**greedy_couples()** - Fast approximate matching:

- 10-100x faster than optimal
- Three strategy options

---

## Quick Examples

### lap_solve(): Basic Assignment

```{r}
library(couplr)

# Cost matrix: 3 nurses × 3 shifts
cost <- matrix(c(
  4, 2, 5,
  3, 3, 6,
  7, 5, 4
), nrow = 3, byrow = TRUE)

result <- lap_solve(cost)
print(result)
```

**Reading the output**: Row 1 shows source 1 assigned to target 2 with cost 2. The `total_cost` column shows the cumulative cost (9).

### Data Frame Input

```{r}
library(dplyr)

# Long-format data frame
schedule_df <- tibble(

  nurse = rep(1:3, each = 3),
  shift = rep(1:3, times = 3),
  cost = c(4, 2, 5, 3, 3, 6, 7, 5, 4)
)

# Solve using column names
lap_solve(schedule_df, nurse, shift, cost)
```

### Rectangular Problems

```{r}
# 3 nurses, 5 shifts - assign each nurse to one shift
cost_rect <- matrix(c(
  1, 2, 3, 4, 5,
  6, 5, 4, 3, 2,
  2, 3, 4, 5, 6
), nrow = 3, byrow = TRUE)

lap_solve(cost_rect)
```

When rows < columns, each row gets one column, and some columns remain unassigned.

### Forbidden Assignments

Use `NA` or `Inf` to mark impossible assignments:

```{r}
cost_forbidden <- matrix(c(
  4, 2, NA,   # Source 1 cannot go to target 3
  Inf, 3, 6,  # Source 2 cannot go to target 1
  7, 5, 4
), nrow = 3, byrow = TRUE)

lap_solve(cost_forbidden)
```

---

## Maximization Problems

Switch to maximization with `maximize = TRUE`:

```{r}
# Preference scores (higher = better)
preferences <- matrix(c(
  8, 5, 3,
  4, 7, 6,
  2, 4, 9
), nrow = 3, byrow = TRUE)

lap_solve(preferences, maximize = TRUE)
```

---

## Grouped Data

Solve multiple problems at once with grouped data frames:
```{r}
# Weekly schedule: 3 days × 3 nurses × 3 shifts
weekly_df <- tibble(
  day = rep(c("Mon", "Tue", "Wed"), each = 9),
  nurse = rep(rep(1:3, each = 3), times = 3),
  shift = rep(1:3, times = 9),
  cost = runif(27, 1, 10)
)

# Solve all days at once
weekly_df |>
  group_by(day) |>
  lap_solve(nurse, shift, cost) |>
  group_by(day) |>
  summarise(total_cost = sum(cost), .groups = "drop")
```

---

## Batch Solving

For many independent problems, use `lap_solve_batch()`:

```{r}
# 100 random cost matrices
set.seed(123)
cost_list <- lapply(1:100, function(i) matrix(runif(9, 1, 10), 3, 3))

# Solve all at once
batch_results <- lap_solve_batch(cost_list)

# Summary
batch_results |>
  distinct(problem_id, total_cost) |>
  summarise(
    n_problems = n(),
    mean_cost = mean(total_cost),
    min_cost = min(total_cost),
    max_cost = max(total_cost)
  )
```

Enable parallel processing for large batches:

```{r, eval=FALSE}
lap_solve_batch(cost_list, n_threads = 4)
```

---

## K-Best Solutions

Find multiple near-optimal solutions:

```{r}
cost <- matrix(c(1, 2, 3, 4, 3, 2, 5, 4, 1), nrow = 3, byrow = TRUE)

# Find top 5 solutions
kbest <- lap_solve_kbest(cost, k = 5)
print(kbest)
```

Useful for exploring alternatives when the optimal solution is infeasible in practice.

---

## Algorithm Selection

couplr includes 12+ algorithms with automatic selection:

```{r}
# Let couplr choose (default)
result <- lap_solve(cost, method = "auto")
get_method_used(result)
```

Force specific algorithms:

```{r, eval=FALSE}
lap_solve(cost, method = "jv")         # Jonker-Volgenant (general purpose)
lap_solve(cost, method = "hungarian")  # Hungarian algorithm
lap_solve(cost, method = "auction")    # Auction algorithm
lap_solve(cost, method = "hk01")       # For binary (0/1) costs
```

**Selection guide:**

| Problem Type | Recommended Method |
|--------------|-------------------|
| General case | `"auto"` or `"jv"` |
| Binary costs (0/1) | `"hk01"` |
| Large dense (n > 1000) | `"auction"` |
| Sparse/many forbidden | `"sap"` |

---

## Utility Functions

```{r}
result <- lap_solve(cost)

# Extract total cost
get_total_cost(result)

# Get algorithm used
get_method_used(result)

# Convert to binary assignment matrix
as_assignment_matrix(result)
```

---

## Performance Guide

| Problem Size | Typical Runtime | Notes |
|--------------|-----------------|-------|
| < 100×100 | < 0.01s | Any method works |
| 100-500 | 0.01-0.1s | `method = "auto"` |
| 500-1000 | 0.1-1s | Consider `"jv"` |
| 1000-3000 | 1-30s | Use `"auction"` |
| > 3000 | > 30s | See `vignette("matching-workflows")` |

---

## Common Issues

### "All assignments have Inf cost"

**Cause**: Too many forbidden entries make the problem infeasible.

**Solution**: Ensure each row has at least one finite value.

```{r}
cost_check <- matrix(c(1, NA, NA, NA, NA, NA, NA, 2, 3), nrow = 3, byrow = TRUE)
feasible <- rowSums(is.finite(cost_check)) > 0
if (!all(feasible)) cat("Infeasible rows:", which(!feasible), "\n")
```

### Different results with different methods

**Cause**: Multiple optimal solutions may exist.

**Solution**: Use `method = "hungarian"` for deterministic tie-breaking, or verify total costs match.

### Slow performance on large problems

**Solutions**:

- n > 1000: Use `method = "auction"`
- n > 3000: Use blocking via `vignette("matching-workflows")`
- n > 5000: Use `greedy_couples()` for approximate solutions

---

## See Also

- `vignette("algorithms")` - Mathematical foundations and solver internals
- `vignette("matching-workflows")` - Production matching for observational studies
- `vignette("pixel-morphing")` - Large-scale approximation strategies
- `?lap_solve`, `?lap_solve_batch`, `?lap_solve_kbest`, `?match_couples`
